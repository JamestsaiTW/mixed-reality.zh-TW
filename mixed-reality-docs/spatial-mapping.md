---
title: 空間對應
description: 空間對應提供 HoloLens 周圍環境中實際表面的詳細標記法。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間對應，HoloLens，混合現實，表面重建，網格
ms.openlocfilehash: c4e2f9e49cfe4df9cf875d18b19d62e25c200d76
ms.sourcegitcommit: 2cf3f19146d6a7ba71bbc4697a59064b4822b539
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/12/2019
ms.locfileid: "73926741"
---
# <a name="spatial-mapping"></a><span data-ttu-id="3106d-104">空間對應</span><span class="sxs-lookup"><span data-stu-id="3106d-104">Spatial mapping</span></span>

<span data-ttu-id="3106d-105">空間對應提供 HoloLens 環境中實際表面的詳細標記法，讓開發人員能夠建立一項「說服混合」現實體驗。</span><span class="sxs-lookup"><span data-stu-id="3106d-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="3106d-106">藉由將真實世界與虛擬世界合併，應用程式就可以讓全息影像看起來很真實。</span><span class="sxs-lookup"><span data-stu-id="3106d-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="3106d-107">應用程式也可以藉由提供熟悉的真實世界行為和互動，更自然地配合使用者的期望。</span><span class="sxs-lookup"><span data-stu-id="3106d-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a><span data-ttu-id="3106d-108">裝置支援</span><span class="sxs-lookup"><span data-stu-id="3106d-108">Device support</span></span>

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><span data-ttu-id="3106d-109"><strong>特徵</strong></span><span class="sxs-lookup"><span data-stu-id="3106d-109"><strong>Feature</strong></span></span></td>
        <td><span data-ttu-id="3106d-110"><a href="hololens-hardware-details.md"><strong>HoloLens (第 1 代)</strong></a></span><span class="sxs-lookup"><span data-stu-id="3106d-110"><a href="hololens-hardware-details.md"><strong>HoloLens (1st gen)</strong></a></span></span></td>
        <td><span data-ttu-id="3106d-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span><span class="sxs-lookup"><span data-stu-id="3106d-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span></span></td>
        <td><span data-ttu-id="3106d-112"><a href="immersive-headset-hardware-details.md"><strong>沉浸式頭戴裝置</strong></a></span><span class="sxs-lookup"><span data-stu-id="3106d-112"><a href="immersive-headset-hardware-details.md"><strong>Immersive headsets</strong></a></span></span></td>
    </tr>
     <tr>
        <td><span data-ttu-id="3106d-113">空間對應</span><span class="sxs-lookup"><span data-stu-id="3106d-113">Spatial mapping</span></span></td>
        <td><span data-ttu-id="3106d-114">✔️</span><span class="sxs-lookup"><span data-stu-id="3106d-114">✔️</span></span></td>
        <td><span data-ttu-id="3106d-115">✔️</span><span class="sxs-lookup"><span data-stu-id="3106d-115">✔️</span></span></td>
        <td>❌</td>
    </tr>
</table>


## <a name="why-is-spatial-mapping-important"></a><span data-ttu-id="3106d-116">為什麼空間對應很重要？</span><span class="sxs-lookup"><span data-stu-id="3106d-116">Why is spatial mapping important?</span></span>

<span data-ttu-id="3106d-117">空間對應可以讓使用者將物件放置在實際的表面上。</span><span class="sxs-lookup"><span data-stu-id="3106d-117">Spatial mapping makes it possible to place objects on real surfaces.</span></span> <span data-ttu-id="3106d-118">這有助於錨定使用者世界中的物件，並利用真實世界的深度提示。根據其他全息影像和真實世界物件 Occluding 您的全息影像，有助於說服使用者這些全息影像實際上在其空間中。</span><span class="sxs-lookup"><span data-stu-id="3106d-118">This helps anchor objects in the user's world and takes advantage of real world depth cues. Occluding your holograms based on other holograms and real world objects helps convince the user that these holograms are actually in their space.</span></span> <span data-ttu-id="3106d-119">在空間中浮動或與使用者移動的全息影像，將不會覺得真實。</span><span class="sxs-lookup"><span data-stu-id="3106d-119">Holograms floating in space or moving with the user will not feel as real.</span></span> <span data-ttu-id="3106d-120">可能的話，請將專案放在緩和之下。</span><span class="sxs-lookup"><span data-stu-id="3106d-120">When possible, place items for comfort.</span></span>

<span data-ttu-id="3106d-121">在放置或移動全息影像時將表面視覺化（使用簡單的投影方格）。</span><span class="sxs-lookup"><span data-stu-id="3106d-121">Visualize surfaces when placing or moving holograms (use a simple projected grid).</span></span> <span data-ttu-id="3106d-122">這可協助使用者知道他們可以在哪裡放置其全息影像，並在使用者嘗試放置全息全像的位置尚未進行對應的情況下顯示。</span><span class="sxs-lookup"><span data-stu-id="3106d-122">This will help the user know where they can best place their holograms, and shows the user if the spot they are trying to place the hologram hasn't been mapped yet.</span></span> <span data-ttu-id="3106d-123">如果使用者的角度過多，您可以將「佈告欄專案」導向至使用者。</span><span class="sxs-lookup"><span data-stu-id="3106d-123">You can "billboard items" toward the user if they end up at too much of an angle.</span></span>

## <a name="conceptual-overview"></a><span data-ttu-id="3106d-124">概念總覽</span><span class="sxs-lookup"><span data-stu-id="3106d-124">Conceptual overview</span></span>

<span data-ttu-id="3106d-125">涵蓋空間的 ![網格介面](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="3106d-125">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="3106d-126">*涵蓋房間的空間對應網格範例*</span><span class="sxs-lookup"><span data-stu-id="3106d-126">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="3106d-127">用於空間對應的兩個主要物件類型是「空間介面觀察者」和「空間介面」。</span><span class="sxs-lookup"><span data-stu-id="3106d-127">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="3106d-128">應用程式會提供具有一或多個周框磁片區的空間介面觀察者，以定義應用程式希望接收空間對應資料的空間區域。</span><span class="sxs-lookup"><span data-stu-id="3106d-128">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="3106d-129">空間對應會針對每個磁片區，提供應用程式一組空間表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-129">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="3106d-130">這些磁片區可能是固定的（位於與真實世界相關的固定位置），也可以附加至 HoloLens （它們會移動，但不會旋轉，因為 HoloLens 會在環境中移動）。</span><span class="sxs-lookup"><span data-stu-id="3106d-130">These volumes may be stationary (in a fixed location with respect to the real world) or they may be attached to the HoloLens (they move, but do not rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="3106d-131">每個空間表面都會以少量的空間來描述真實世界的表面，以連接到世界鎖定[空間座標系統](coordinate-systems.md)的三角形網格來表示。</span><span class="sxs-lookup"><span data-stu-id="3106d-131">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="3106d-132">當 HoloLens 收集有關環境的新資料，而且在環境發生變更時，空間表面會出現、消失和變更。</span><span class="sxs-lookup"><span data-stu-id="3106d-132">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear and change.</span></span>

## <a name="spatial-mapping-vs-scene-understanding-worldmesh"></a><span data-ttu-id="3106d-133">空間對應與場景瞭解 WorldMesh</span><span class="sxs-lookup"><span data-stu-id="3106d-133">Spatial Mapping vs. Scene Understanding WorldMesh</span></span>
<span data-ttu-id="3106d-134">對於 HoloLens 2，可以使用「[場景理解 SDK](scene-understanding-SDK.md) 」（EnableWorldMesh 設定）來查詢空間對應資料的靜態版本。</span><span class="sxs-lookup"><span data-stu-id="3106d-134">For HoloLens 2, it is possible to query a static version of the spatial mapping data using [Scene understanding SDK](scene-understanding-SDK.md) (EnableWorldMesh setting).</span></span> <span data-ttu-id="3106d-135">以下是存取空間對應資料的兩種方式之間的差異：</span><span class="sxs-lookup"><span data-stu-id="3106d-135">Here are the differences between two way of accessing the spatial mapping data:</span></span>
* <span data-ttu-id="3106d-136">空間對應 API：</span><span class="sxs-lookup"><span data-stu-id="3106d-136">Spatial Mapping API:</span></span>
   * <span data-ttu-id="3106d-137">有限範圍：應用程式的空間對應資料可用於大小有限的快取使用者周圍的「冒泡」。</span><span class="sxs-lookup"><span data-stu-id="3106d-137">Limited range: the spatial mapping data available to applications in a limited size cached 'bubble' around the user.</span></span>
   * <span data-ttu-id="3106d-138">透過 SurfacesChanged 事件提供已變更網格區域的低延遲更新。</span><span class="sxs-lookup"><span data-stu-id="3106d-138">Provides low latency updates of changed mesh regions through SurfacesChanged events.</span></span>
   * <span data-ttu-id="3106d-139">依每個立方計量參數的三角形所控制之詳細資料的變數層級。</span><span class="sxs-lookup"><span data-stu-id="3106d-139">Variable level of details controlled by Triangles Per Cubic Meter parameter.</span></span>
* <span data-ttu-id="3106d-140">場景理解 SDK：</span><span class="sxs-lookup"><span data-stu-id="3106d-140">Scene understanding SDK:</span></span>
   * <span data-ttu-id="3106d-141">無限制的範圍-提供查詢半徑內所有已掃描的空間對應資料。</span><span class="sxs-lookup"><span data-stu-id="3106d-141">Unlimited range - provides all the scanned spatial mapping data within the query radius.</span></span>
   * <span data-ttu-id="3106d-142">提供空間對應資料的靜態快照集。</span><span class="sxs-lookup"><span data-stu-id="3106d-142">Provides a static snapshot of the spatial mapping data.</span></span> <span data-ttu-id="3106d-143">取得更新的空間對應資料需要針對整個網格執行新的查詢。</span><span class="sxs-lookup"><span data-stu-id="3106d-143">Getting the updated spatial mapping data requires running a new query for the whole mesh.</span></span>
   * <span data-ttu-id="3106d-144">依 RequestedMeshLevelOfDetail 設定所控制的一致詳細資料層級。</span><span class="sxs-lookup"><span data-stu-id="3106d-144">Consistent level of details controlled by RequestedMeshLevelOfDetail setting.</span></span>

## <a name="what-influences-spatial-mapping-quality"></a><span data-ttu-id="3106d-145">什麼會影響空間對應品質？</span><span class="sxs-lookup"><span data-stu-id="3106d-145">What influences spatial mapping quality?</span></span>

<span data-ttu-id="3106d-146">[這裡](environment-considerations-for-hololens.md)詳述的幾個因素可能會影響這些錯誤的頻率和嚴重性。</span><span class="sxs-lookup"><span data-stu-id="3106d-146">Several factors, detailed [here](environment-considerations-for-hololens.md), can affect the frequency and severity of these errors.</span></span>  <span data-ttu-id="3106d-147">不過，您應該設計應用程式，讓使用者即使在空間對應資料中出現錯誤，也能夠達到其目標。</span><span class="sxs-lookup"><span data-stu-id="3106d-147">However, you should design your application so that the user is able to achieve their goals even in the presence of errors in the spatial mapping data.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="3106d-148">常見使用案例</span><span class="sxs-lookup"><span data-stu-id="3106d-148">Common usage scenarios</span></span>

![一般空間對應使用案例的圖例：位置、遮蔽、物理和流覽](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="3106d-150">位置</span><span class="sxs-lookup"><span data-stu-id="3106d-150">Placement</span></span>

<span data-ttu-id="3106d-151">空間對應讓應用程式有機會對使用者呈現自然且熟悉的互動形式;將您的電話放在桌上有何自然？</span><span class="sxs-lookup"><span data-stu-id="3106d-151">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing your phone down on the desk?</span></span>

<span data-ttu-id="3106d-152">將全息影像的位置（或更廣泛地說，空間位置的任何選擇）限制為位於表面上，可提供從3D （點在空間）到2D （點在表面上）的自然對應。</span><span class="sxs-lookup"><span data-stu-id="3106d-152">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="3106d-153">這會減少使用者必須提供給應用程式的資訊量，因而讓使用者的互動速度更快、更簡單、更精確。</span><span class="sxs-lookup"><span data-stu-id="3106d-153">This reduces the amount of information the user needs to provide to the application and thus makes the user's interactions faster, easier and more precise.</span></span> <span data-ttu-id="3106d-154">這一點特別重要，因為「距離遠離」並不是我們用來實際與其他人或電腦進行通訊的東西。</span><span class="sxs-lookup"><span data-stu-id="3106d-154">This is particularly true because 'distance away' is not something that we are used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="3106d-155">當我們指向手指時，就是指定方向，而不是距離。</span><span class="sxs-lookup"><span data-stu-id="3106d-155">When we point with our finger, we are specifying a direction but not a distance.</span></span>

<span data-ttu-id="3106d-156">這裡要注意的一點是，當應用程式從方向推斷距離時（例如，沿著使用者的注視方向執行 raycast 以尋找最近的空間表面），這必須產生使用者能夠可靠地進行預測的結果。</span><span class="sxs-lookup"><span data-stu-id="3106d-156">An important caveat here is that when an application infers distance from direction (for example by performing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user is able to reliably predict.</span></span> <span data-ttu-id="3106d-157">否則，使用者將喪失控制項的意義，而這可能很快就會變得令人沮喪。</span><span class="sxs-lookup"><span data-stu-id="3106d-157">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="3106d-158">有一種方法可協助您執行多個 raycasts，而不只是一個。</span><span class="sxs-lookup"><span data-stu-id="3106d-158">One method that helps with this is to perform multiple raycasts instead of just one.</span></span> <span data-ttu-id="3106d-159">匯總結果應該更平滑且更可預測，較不容易受到暫時性「極端」結果的影響（可能是因為光線通過小型洞，或遇到使用者不知道的小型幾何）。</span><span class="sxs-lookup"><span data-stu-id="3106d-159">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user is not aware of).</span></span> <span data-ttu-id="3106d-160">您也可以在一段時間內執行匯總或平滑處理;例如，您可以限制全息的最大速度，與使用者之間的距離可能有所不同。</span><span class="sxs-lookup"><span data-stu-id="3106d-160">Aggregation or smoothing can also be performed over time; for example you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="3106d-161">只是限制 [最小值] 和 [最大距離] 值也可以提供協助，因此移動的全息影像不會突然進入距離或損毀到使用者的臉部。</span><span class="sxs-lookup"><span data-stu-id="3106d-161">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved does not suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="3106d-162">應用程式也可以使用表面的形狀和方向來引導全息影像位置。</span><span class="sxs-lookup"><span data-stu-id="3106d-162">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="3106d-163">全像攝影的椅子不應穿透牆，而且應該與樓層齊平，即使它有點不平均。</span><span class="sxs-lookup"><span data-stu-id="3106d-163">A holographic chair should not penetrate through walls and should sit flush with the floor even if it is slightly uneven.</span></span> <span data-ttu-id="3106d-164">這類功能可能會依賴物理衝突，而不只是 raycasts，但也會套用類似的問題。</span><span class="sxs-lookup"><span data-stu-id="3106d-164">This kind of functionality would likely rely upon the use of physics collisions rather than just raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="3106d-165">如果要放置的全像投影片上有許多很小的多邊形，像是椅子上的腿，則將這些多邊形的物理表示擴充為更寬且更平滑的東西，讓它們能夠更輕鬆地滑出空間表面，而不需要畫面.</span><span class="sxs-lookup"><span data-stu-id="3106d-165">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they are more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="3106d-166">在極端的情況下，使用者輸入可以完全簡化，而空間表面則可以用來執行完全自動的全像投影位置。</span><span class="sxs-lookup"><span data-stu-id="3106d-166">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to perform entirely automatic hologram placement.</span></span> <span data-ttu-id="3106d-167">例如，應用程式可能會在牆上的某處放置全像攝影燈，讓使用者按下。</span><span class="sxs-lookup"><span data-stu-id="3106d-167">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="3106d-168">關於可預測性的相同注意事項適用于這裡：如果使用者希望能夠控制全像投影位置，但應用程式不一定會在其預期的地方放入全息影像（如果燈出現在使用者無法觸達的地方），這會是令人沮喪的體驗。</span><span class="sxs-lookup"><span data-stu-id="3106d-168">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application does not always place holograms where they expect (if the light-switch appears somewhere that the user cannot reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="3106d-169">實際上，執行需要使用者更正的自動放置可能會更糟，而不只是要求使用者一律自行執行放置;因為*預期*會自動放置成功，所以手動更正會感覺像是一種負擔！</span><span class="sxs-lookup"><span data-stu-id="3106d-169">It can actually be worse to perform automatic placement that requires user correction some of the time, than to just require the user to always perform placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="3106d-170">另請注意，應用程式使用空間介面進行放置的能力，主要取決於應用程式的[掃描經驗](spatial-mapping.md#the-environment-scanning-experience)。</span><span class="sxs-lookup"><span data-stu-id="3106d-170">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="3106d-171">如果表面尚未掃描，則無法用於放置。</span><span class="sxs-lookup"><span data-stu-id="3106d-171">If a surface has not been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="3106d-172">應用程式會自行決定是否要讓使用者清楚清除，讓他們可以協助掃描新的表面或選取新的位置。</span><span class="sxs-lookup"><span data-stu-id="3106d-172">It is up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="3106d-173">在放置過程中，對使用者的視覺效果回饋十分重要。</span><span class="sxs-lookup"><span data-stu-id="3106d-173">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="3106d-174">使用者必須知道全息與[接地效果](spatial-mapping.md#visualization)最接近的表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-174">The user needs to know where the hologram is in relation to the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="3106d-175">他們應該瞭解為什麼會限制其全息影像的移動（例如，因為與另一個附近的表面發生衝突）。</span><span class="sxs-lookup"><span data-stu-id="3106d-175">They should understand why the movement of their hologram is being constrained (for example, due to collision with another nearby surface).</span></span> <span data-ttu-id="3106d-176">如果他們無法將全息圖形放在目前的位置，則視覺效果的意見反應應該清楚說明為什麼不這麼做。</span><span class="sxs-lookup"><span data-stu-id="3106d-176">If they cannot place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="3106d-177">例如，如果使用者嘗試將全像攝影的沙發放在牆中，那麼牆後方的沙發部分應該會以生氣的色彩 pulsate。</span><span class="sxs-lookup"><span data-stu-id="3106d-177">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="3106d-178">相反地，如果應用程式在使用者可以看到實際表面的位置找不到空間介面，則應用程式應該讓這一點清楚。</span><span class="sxs-lookup"><span data-stu-id="3106d-178">Or conversely, if the application cannot find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="3106d-179">在此區域中，明顯不會產生接地效果，可能會達成此目的。</span><span class="sxs-lookup"><span data-stu-id="3106d-179">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="3106d-180">遮蔽</span><span class="sxs-lookup"><span data-stu-id="3106d-180">Occlusion</span></span>

<span data-ttu-id="3106d-181">空間對應介面的主要用途之一，就是遮蔽的全息影像。</span><span class="sxs-lookup"><span data-stu-id="3106d-181">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="3106d-182">這種簡單的行為會對觀察到的全息影像真實性產生巨大的影響，協助建立真正占與使用者相同之實體空間的 visceral 意義。</span><span class="sxs-lookup"><span data-stu-id="3106d-182">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabit the same physical space as the user.</span></span>

<span data-ttu-id="3106d-183">遮蔽也會提供資訊給使用者;當全像投影表面 pixels occluded 時，這會提供其他視覺效果意見反應給世界上該全息圖形的空間位置。</span><span class="sxs-lookup"><span data-stu-id="3106d-183">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides additional visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="3106d-184">相反地，遮蔽也可以常見*隱藏*使用者的資訊;occluding 牆後方的全息影像可以直覺地減少視覺雜亂的情形。</span><span class="sxs-lookup"><span data-stu-id="3106d-184">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="3106d-185">若要隱藏或顯示全息影像，使用者只需要移動其標題。</span><span class="sxs-lookup"><span data-stu-id="3106d-185">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="3106d-186">遮蔽也可用來根據熟悉的實體互動，將自然使用者介面的期望如果某個表面 pixels occluded 了全息影像，這是因為該表面是實心的，因此使用者應該預期全息影像會與該介面發生*衝突*，而不只是通過它。</span><span class="sxs-lookup"><span data-stu-id="3106d-186">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not simply pass through it.</span></span>

<span data-ttu-id="3106d-187">有時候不需要遮蔽的全息影像。</span><span class="sxs-lookup"><span data-stu-id="3106d-187">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="3106d-188">如果使用者需要能夠與全像投影互動，則他們必須能夠看到它，即使是在實際表面後面也一樣。</span><span class="sxs-lookup"><span data-stu-id="3106d-188">If a user needs to be able to interact with a hologram, then they need to be able to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="3106d-189">在這種情況下，在 pixels occluded （例如，藉由減少其亮度）時，呈現這類全息影像通常是合理的。</span><span class="sxs-lookup"><span data-stu-id="3106d-189">In such cases, it usually makes sense to render such a hologram differently when it is occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="3106d-190">如此一來，使用者將能夠以視覺化方式找出全像投影，但是仍會察覺到它的背後。</span><span class="sxs-lookup"><span data-stu-id="3106d-190">This way, the user will be able to visually locate the hologram, but they will still be aware that it is behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="3106d-191">物理</span><span class="sxs-lookup"><span data-stu-id="3106d-191">Physics</span></span>

<span data-ttu-id="3106d-192">使用物理模擬的另一種方式，是使用空間對應來強化使用者實體空間中的全息*顯示*。</span><span class="sxs-lookup"><span data-stu-id="3106d-192">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="3106d-193">當我的全像說，我的全像是從桌上折得，然後在沙發下彈跳並消失時，我可能很難相信這不是真正的。</span><span class="sxs-lookup"><span data-stu-id="3106d-193">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not really there.</span></span>

<span data-ttu-id="3106d-194">物理模擬也讓應用程式有機會使用自然且熟悉的物理互動。</span><span class="sxs-lookup"><span data-stu-id="3106d-194">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="3106d-195">如果傢俱以適當的慣性和摩擦在地面之間滑動，則移動地面上的全像攝影傢俱可能會更容易。</span><span class="sxs-lookup"><span data-stu-id="3106d-195">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="3106d-196">為了產生實際的實體行為，您可能需要執行一些[網格處理](spatial-mapping.md#mesh-processing)，例如填滿孔、移除浮動 hallucinations 和平滑表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-196">In order to generate realistic physical behaviors, you will likely need to perform some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="3106d-197">您也必須考慮應用程式的[掃描體驗](spatial-mapping.md#the-environment-scanning-experience)會如何影響其物理模擬。</span><span class="sxs-lookup"><span data-stu-id="3106d-197">You will also need to consider how your application's [scanning experience](spatial-mapping.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="3106d-198">首先，遺漏的表面不會與任何專案衝突;當橡膠球在 corridor 和已知世界結束時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="3106d-198">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="3106d-199">其次，您必須決定是否要在一段時間後繼續回應環境中的變更。</span><span class="sxs-lookup"><span data-stu-id="3106d-199">Secondly, you need to decide whether you will continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="3106d-200">在某些情況下，您會想要儘快回應;比方說，如果使用者使用門和傢俱作為 tempest 的內送羅馬箭號的 barricades。</span><span class="sxs-lookup"><span data-stu-id="3106d-200">In some cases, you will want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="3106d-201">但在其他情況下，您可能會想要忽略新的更新;如果您的狗決定坐在一軌的中間，讓您的全像 racetrack 在地面上推動全像運動車，可能會突然不那麼有趣。</span><span class="sxs-lookup"><span data-stu-id="3106d-201">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="3106d-202">瀏覽</span><span class="sxs-lookup"><span data-stu-id="3106d-202">Navigation</span></span>

<span data-ttu-id="3106d-203">應用程式可以使用空間對應資料來授與全像攝影的字元（或代理程式）能夠以真實人員的相同方式來流覽真實世界。</span><span class="sxs-lookup"><span data-stu-id="3106d-203">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="3106d-204">這有助於加強全像攝影字元的存在，方法是將它們限制為與使用者及其朋友的同一組自然、熟悉的行為。</span><span class="sxs-lookup"><span data-stu-id="3106d-204">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="3106d-205">流覽功能對使用者也很有用。</span><span class="sxs-lookup"><span data-stu-id="3106d-205">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="3106d-206">在特定區域內建導覽地圖之後，您就可以共用它，為不熟悉該位置的新使用者提供全像攝影方向。</span><span class="sxs-lookup"><span data-stu-id="3106d-206">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="3106d-207">這個對應可以設計來協助讓地下的「流量」順暢地流動，或避免在危險位置（例如結構網站）中發生意外的情況。</span><span class="sxs-lookup"><span data-stu-id="3106d-207">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="3106d-208">執行導覽功能時所牽涉到的重要技術挑戰，將會可靠地偵測 walkable 介面（人類不會引導資料表！），並對環境中的變更進行適當的調整（人類不會逐步解說）。</span><span class="sxs-lookup"><span data-stu-id="3106d-208">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="3106d-209">網格可能需要先進行一些[處理](spatial-mapping.md#mesh-processing)，才能用於路徑規劃和導覽（透過虛擬字元）。</span><span class="sxs-lookup"><span data-stu-id="3106d-209">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it is usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="3106d-210">將網格平滑化和移除 hallucinations，可協助避免字元變得停滯。</span><span class="sxs-lookup"><span data-stu-id="3106d-210">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="3106d-211">您也可能想要大幅簡化網格，以便加速字元的路徑規劃和導覽計算。</span><span class="sxs-lookup"><span data-stu-id="3106d-211">You may also wish to drastically simplify the mesh in order to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="3106d-212">這些挑戰在開發 videogame 技術方面已經有很大的注意，而且這些主題提供了豐富的研究文獻。</span><span class="sxs-lookup"><span data-stu-id="3106d-212">These challenges have received a great deal of attention in the development of videogame technology, and there is a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="3106d-213">請注意，Unity 中的內建 NavMesh 功能無法與空間對應介面搭配使用。</span><span class="sxs-lookup"><span data-stu-id="3106d-213">Note that the built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="3106d-214">這是因為在應用程式啟動之前，空間對應介面不是已知的，而 NavMesh 資料檔案必須事先從來源資產產生。</span><span class="sxs-lookup"><span data-stu-id="3106d-214">This is because spatial mapping surfaces are not known until the application starts, whereas NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="3106d-215">另請注意，空間對應系統不會提供與使用者目前位置[非常遠之表面的相關資訊](spatial-mapping.md#the-environment-scanning-experience)。</span><span class="sxs-lookup"><span data-stu-id="3106d-215">Also note that, the spatial mapping system will not provide [information about surfaces very far away](spatial-mapping.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="3106d-216">因此，如果應用程式要建立非常大區域的對應，就必須「記住」自己的表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-216">So the application must 'remember' surfaces itself if it is to build a map of a very large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="3106d-217">化</span><span class="sxs-lookup"><span data-stu-id="3106d-217">Visualization</span></span>

<span data-ttu-id="3106d-218">大部分時間都適用于空間表面不可見;以最小化視覺效果，並讓真實世界自行溝通。</span><span class="sxs-lookup"><span data-stu-id="3106d-218">Most of the time it is appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="3106d-219">不過，有時候直接將空間對應介面視覺化會很有用，儘管實際的對應專案已經看得見。</span><span class="sxs-lookup"><span data-stu-id="3106d-219">However, sometimes it is useful to visualize spatial mapping surfaces directly, despite the fact that their real-world counterparts are already visible.</span></span>

<span data-ttu-id="3106d-220">例如，當使用者嘗試將全息影像放在表面上（比方說，在牆上放置全像攝影的機櫃）時，將陰影轉型為介面，就可以「地面」。</span><span class="sxs-lookup"><span data-stu-id="3106d-220">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="3106d-221">如此一來，使用者就能更清楚地瞭解全息影像與表面之間的確切實體鄰近性。</span><span class="sxs-lookup"><span data-stu-id="3106d-221">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="3106d-222">這也是在使用者認可之前，以視覺化方式「預覽」變更的一般作法範例。</span><span class="sxs-lookup"><span data-stu-id="3106d-222">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="3106d-223">藉由視覺化表面，應用程式可以與使用者對環境的瞭解進行共用。</span><span class="sxs-lookup"><span data-stu-id="3106d-223">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="3106d-224">例如，「全像攝影面板」遊戲可以將其識別為「資料表」的水準表面視覺化，讓使用者知道他們應該前往何處互動。</span><span class="sxs-lookup"><span data-stu-id="3106d-224">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="3106d-225">視覺化表面是一個很實用的方式，可顯示隱藏于 view 之外的使用者附近空白。</span><span class="sxs-lookup"><span data-stu-id="3106d-225">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="3106d-226">這可能會提供簡單的方法，讓使用者從他們的聊天室存取廚房（以及所有內含的全息影像）。</span><span class="sxs-lookup"><span data-stu-id="3106d-226">This could provide a simple way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="3106d-227">空間對應所提供的表面網格可能不會特別「清除」。</span><span class="sxs-lookup"><span data-stu-id="3106d-227">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="3106d-228">因此，請務必適當地將它們視覺化。</span><span class="sxs-lookup"><span data-stu-id="3106d-228">Thus it is important to visualize them appropriately.</span></span> <span data-ttu-id="3106d-229">傳統光源計算可能會以視覺上分散的方式反白顯示介面法線中的錯誤，而投影到表面的「清除」紋理可能有助於提供整齊的外觀。</span><span class="sxs-lookup"><span data-stu-id="3106d-229">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, whilst 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="3106d-230">在呈現表面之前，也可以執行[網格處理](spatial-mapping.md#mesh-processing)來改善網格屬性。</span><span class="sxs-lookup"><span data-stu-id="3106d-230">It is also possible to perform [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

> [!NOTE]
> <span data-ttu-id="3106d-231">HoloLens 2 實行新的[場景理解運行](scene-understanding.md)時間，為混合式現實開發人員提供結構化的高階環境標記法，其設計目的是為了簡化放置、遮蔽、物理和流覽的執行。</span><span class="sxs-lookup"><span data-stu-id="3106d-231">HoloLens 2 implements a new [Scene Understanding Runtime](scene-understanding.md), that provides Mixed Reality developers with a structured, high-level environment representation designed to simplify the implementation of placement, occlusion, physics and navigation.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="3106d-232">使用 Surface 觀察者</span><span class="sxs-lookup"><span data-stu-id="3106d-232">Using The Surface Observer</span></span>

<span data-ttu-id="3106d-233">空間對應的起點是「表面觀察者」。</span><span class="sxs-lookup"><span data-stu-id="3106d-233">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="3106d-234">程式流程如下所示：</span><span class="sxs-lookup"><span data-stu-id="3106d-234">Program flow is as follows:</span></span>
* <span data-ttu-id="3106d-235">建立 surface observer 物件</span><span class="sxs-lookup"><span data-stu-id="3106d-235">Create a surface observer object</span></span>
   * <span data-ttu-id="3106d-236">提供一或多個空間磁片區，以定義應用程式希望接收空間對應資料的相關區域。</span><span class="sxs-lookup"><span data-stu-id="3106d-236">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="3106d-237">空間磁片區只是定義空間區域（例如球體或方塊）的圖形。</span><span class="sxs-lookup"><span data-stu-id="3106d-237">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="3106d-238">使用具有全球鎖定空間座標系統的空間磁片區，以識別實體世界的固定區域。</span><span class="sxs-lookup"><span data-stu-id="3106d-238">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="3106d-239">使用空間磁片區，以主體鎖定的空間座標系統更新每個框架，以識別與使用者移動（但不會旋轉）的空間區域。</span><span class="sxs-lookup"><span data-stu-id="3106d-239">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but does not rotate) with the user.</span></span>
   * <span data-ttu-id="3106d-240">當應用程式或使用者的狀態變更時，這些空間磁片區可能會在稍後變更。</span><span class="sxs-lookup"><span data-stu-id="3106d-240">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="3106d-241">使用輪詢或通知來抓取空間表面的相關資訊</span><span class="sxs-lookup"><span data-stu-id="3106d-241">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="3106d-242">您可以隨時「輪詢」「介面觀察器」的空間表面狀態。</span><span class="sxs-lookup"><span data-stu-id="3106d-242">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="3106d-243">或者，您可以註冊 surface 觀察者的「表面已變更」事件，這會在空間表面變更時通知應用程式。</span><span class="sxs-lookup"><span data-stu-id="3106d-243">Alternatively, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="3106d-244">對於動態空間磁片區（例如，視圖截維或主體鎖定的卷），應用程式必須藉由設定感關注的區域，然後取得目前的空間表面集合，來輪詢每個畫面格的變更。</span><span class="sxs-lookup"><span data-stu-id="3106d-244">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="3106d-245">對於靜態磁片區（例如涵蓋單一房間的全球鎖定 cube），應用程式可能會註冊「介面已變更」事件，以在該磁片區中的空間表面可能已變更時收到通知。</span><span class="sxs-lookup"><span data-stu-id="3106d-245">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="3106d-246">進程表面變更</span><span class="sxs-lookup"><span data-stu-id="3106d-246">Process surfaces changes</span></span>
   * <span data-ttu-id="3106d-247">逐一查看提供的空間表面集合。</span><span class="sxs-lookup"><span data-stu-id="3106d-247">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="3106d-248">將空間表面分類為已加入、已變更或已移除。</span><span class="sxs-lookup"><span data-stu-id="3106d-248">Classify spatial surfaces as added, changed or removed.</span></span>
   * <span data-ttu-id="3106d-249">針對每個新增或變更的空間介面，如果適當地提交非同步要求以接收更新的網格，表示介面在所需的詳細資料層級上的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="3106d-249">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="3106d-250">處理非同步網狀要求（下列各節中有更多詳細資料）。</span><span class="sxs-lookup"><span data-stu-id="3106d-250">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="3106d-251">網格快取</span><span class="sxs-lookup"><span data-stu-id="3106d-251">Mesh Caching</span></span>

<span data-ttu-id="3106d-252">空間表面是以密集三角形網格來表示。</span><span class="sxs-lookup"><span data-stu-id="3106d-252">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="3106d-253">儲存、轉譯和處理這些網格可能會耗用大量的計算和儲存資源。</span><span class="sxs-lookup"><span data-stu-id="3106d-253">Storing, rendering and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="3106d-254">因此，每個應用程式都應該採用適合其需求的網格快取配置，以便將用於網格處理和儲存的資源降至最低。</span><span class="sxs-lookup"><span data-stu-id="3106d-254">As such, each application should adopt a mesh caching scheme appropriate to its needs, in order to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="3106d-255">此配置應該會決定要保留哪些網格以及要捨棄哪些，以及何時要更新每個空間介面的網格。</span><span class="sxs-lookup"><span data-stu-id="3106d-255">This scheme should determine which meshes to retain and which to discard, as well as when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="3106d-256">這裡討論的許多考慮都會直接通知應用程式應該如何處理網格快取。</span><span class="sxs-lookup"><span data-stu-id="3106d-256">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="3106d-257">您應該考慮到使用者如何在環境中移動、觀察到不同的表面，以及何時應該捕捉環境中的變更。</span><span class="sxs-lookup"><span data-stu-id="3106d-257">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="3106d-258">當您解讀 surface 觀察者所提供的「表面已變更」事件時，基本網格快取邏輯如下所示：</span><span class="sxs-lookup"><span data-stu-id="3106d-258">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="3106d-259">如果應用程式看到先前尚未看到的空間表面識別碼，則應該將它視為新的空間介面。</span><span class="sxs-lookup"><span data-stu-id="3106d-259">If the application sees a spatial surface ID that it has not seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="3106d-260">如果應用程式看到具有已知識別碼的空間介面，但具有新的更新時間，則應該將此視為已更新的空間介面。</span><span class="sxs-lookup"><span data-stu-id="3106d-260">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="3106d-261">如果應用程式不再看到具有已知識別碼的空間介面，則應該將它視為已移除的空間介面。</span><span class="sxs-lookup"><span data-stu-id="3106d-261">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="3106d-262">而是由每個應用程式決定，然後進行下列選擇：</span><span class="sxs-lookup"><span data-stu-id="3106d-262">It is up to each application to then make the following choices:</span></span>
* <span data-ttu-id="3106d-263">針對新的空間表面，應該會要求網格嗎？</span><span class="sxs-lookup"><span data-stu-id="3106d-263">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="3106d-264">通常應該立即針對新的空間表面要求網格，這可能會對使用者提供有用的新資訊。</span><span class="sxs-lookup"><span data-stu-id="3106d-264">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="3106d-265">不過，在使用者附近和前方的新空間表面應具有優先順序，而且應該先要求其網格。</span><span class="sxs-lookup"><span data-stu-id="3106d-265">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="3106d-266">如果不需要新的網格，例如應用程式已永久或暫時「凍結」其環境模型，則不應要求。</span><span class="sxs-lookup"><span data-stu-id="3106d-266">If the new mesh is not needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it should not be requested.</span></span>
* <span data-ttu-id="3106d-267">針對已更新的空間表面，應要求網格嗎？</span><span class="sxs-lookup"><span data-stu-id="3106d-267">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="3106d-268">已更新使用者附近和前方的空間表面，應優先取得，而且應該先要求其網格。</span><span class="sxs-lookup"><span data-stu-id="3106d-268">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="3106d-269">您也可以在新表面上給予較高的優先順序，而不是更新的表面，特別是在掃描體驗期間。</span><span class="sxs-lookup"><span data-stu-id="3106d-269">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="3106d-270">為了限制處理成本，應用程式可能想要節流處理更新至空間表面的速率。</span><span class="sxs-lookup"><span data-stu-id="3106d-270">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="3106d-271">您可以推斷空間介面的變更是次要的，例如，如果表面的界限很小，在此情況下，更新可能不夠重要而無法處理。</span><span class="sxs-lookup"><span data-stu-id="3106d-271">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="3106d-272">在使用者感興趣的目前區域外的空間表面更新可能會完全忽略，不過在此情況下，修改 surface 觀察者使用的空間界限磁片區可能會更有效率。</span><span class="sxs-lookup"><span data-stu-id="3106d-272">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="3106d-273">針對已移除的空間表面，是否應該捨棄網格？</span><span class="sxs-lookup"><span data-stu-id="3106d-273">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="3106d-274">通常應該針對已移除的空間表面立即捨棄網格，讓全息影像遮蔽保持正確。</span><span class="sxs-lookup"><span data-stu-id="3106d-274">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="3106d-275">不過，如果應用程式有理由相信空間介面很快就會重新出現（也許是根據使用者經驗的設計），那麼保留它比捨棄網格並稍後重新建立，可能會更有效率。</span><span class="sxs-lookup"><span data-stu-id="3106d-275">However, if the application has reason to believe that a spatial surface will reappear shortly (perhaps based upon the design of the user experience), then it may be more efficient to retain it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="3106d-276">如果應用程式正在建立使用者環境的大規模模型，則可能不想要捨棄任何網格。</span><span class="sxs-lookup"><span data-stu-id="3106d-276">If the application is building a large-scale model of the user's environment then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="3106d-277">不過，它仍然需要限制資源使用量，可能是因為空間表面消失，而將網格緩衝處理到磁片上。</span><span class="sxs-lookup"><span data-stu-id="3106d-277">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="3106d-278">請注意，在空間介面產生期間，某些較罕見的事件可能會導致空間表面被類似位置中的新空間表面取代，但使用不同的識別碼。</span><span class="sxs-lookup"><span data-stu-id="3106d-278">Note that some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="3106d-279">因此，選擇不捨棄已移除表面的應用程式，應該不會注意到涵蓋相同位置的多個高度重迭空間介面網格。</span><span class="sxs-lookup"><span data-stu-id="3106d-279">Consequently, applications that choose not to discard a removed surface should take care not to end up with multiple highly-overlapped spatial surface meshes covering the same location.</span></span>
* <span data-ttu-id="3106d-280">是否應該針對其他任何空間表面捨棄網格？</span><span class="sxs-lookup"><span data-stu-id="3106d-280">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="3106d-281">即使空間表面存在，如果它不再適用于使用者的經驗，則應該將其捨棄。</span><span class="sxs-lookup"><span data-stu-id="3106d-281">Even while a spatial surface exists, if it is no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="3106d-282">例如，如果應用程式「取代」門口另一端的房間，還有替代虛擬空間，那麼該房間內的空間表面就不再重要。</span><span class="sxs-lookup"><span data-stu-id="3106d-282">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="3106d-283">以下是使用空間和時態性遲滯的範例網格快取策略：</span><span class="sxs-lookup"><span data-stu-id="3106d-283">Here is an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="3106d-284">假設有一個應用程式想要在使用者看起來前後，使用類似的錐狀空間量，</span><span class="sxs-lookup"><span data-stu-id="3106d-284">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="3106d-285">空間表面可能會暫時消失于此磁片區，這是因為使用者看起來遠離表面或從其外部的步驟 .。。請稍後再回頭查看或移動更接近的時間。</span><span class="sxs-lookup"><span data-stu-id="3106d-285">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="3106d-286">在此情況下，捨棄並重新建立此介面的網格代表許多多餘的處理。</span><span class="sxs-lookup"><span data-stu-id="3106d-286">In this case, discarding and re-creating the mesh for this surface represents a lot of redundant processing.</span></span>
* <span data-ttu-id="3106d-287">為了減少已處理的變更數目，應用程式會使用兩個空間表面觀察器，其中一個會包含在另一個範圍內。</span><span class="sxs-lookup"><span data-stu-id="3106d-287">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="3106d-288">較大的磁片區是球形，並遵循使用者的「延遲」;只有在必要時才會移動，以確保其中心位於使用者的 2.0 metres 內。</span><span class="sxs-lookup"><span data-stu-id="3106d-288">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its centre is within 2.0 metres of the user.</span></span>
* <span data-ttu-id="3106d-289">新的和更新的空間表面網格一律會從較小的內部介面觀察器進行處理，但是網格會快取，直到它們從較大的外部表面觀察器消失為止。</span><span class="sxs-lookup"><span data-stu-id="3106d-289">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="3106d-290">這可讓應用程式避免因本機使用者移動而處理許多多餘的變更。</span><span class="sxs-lookup"><span data-stu-id="3106d-290">This allows the application to avoid processing many redundant changes due to local user movement.</span></span>
* <span data-ttu-id="3106d-291">由於空間表面可能也會因為追蹤遺失而暫時消失，因此應用程式也會在追蹤遺失期間，延遲捨棄已移除的空間表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-291">Since a spatial surface may also disappear temporarily due to tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="3106d-292">一般而言，應用程式應該評估減少更新處理和增加記憶體使用量之間的取捨，以判斷其理想的快取策略。</span><span class="sxs-lookup"><span data-stu-id="3106d-292">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="3106d-293">轉譯</span><span class="sxs-lookup"><span data-stu-id="3106d-293">Rendering</span></span>

<span data-ttu-id="3106d-294">空間對應網格通常用於轉譯的主要方式有三種：</span><span class="sxs-lookup"><span data-stu-id="3106d-294">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="3106d-295">針對表面視覺效果</span><span class="sxs-lookup"><span data-stu-id="3106d-295">For surface visualization</span></span>
   * <span data-ttu-id="3106d-296">直接將空間表面視覺化通常會很有用。</span><span class="sxs-lookup"><span data-stu-id="3106d-296">It is often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="3106d-297">例如，將「陰影」從物件轉換成空間表面，可以在使用者將全息影像放在表面上時，為他們提供有用的視覺回饋。</span><span class="sxs-lookup"><span data-stu-id="3106d-297">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they are placing holograms on surfaces.</span></span>
   * <span data-ttu-id="3106d-298">有一點要注意的是，空間網格與3D 演出者可能建立的網格類型不同。</span><span class="sxs-lookup"><span data-stu-id="3106d-298">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="3106d-299">三角形拓撲不會像人類建立的拓撲一樣「清除」，而且網格會受到[各種錯誤](spatial-mapping.md#what-influences-spatial-mapping-quality)的影響。</span><span class="sxs-lookup"><span data-stu-id="3106d-299">The triangle topology will not be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="3106d-300">為了建立令人滿意的視覺效果美觀，您可能會想要執行一些[網格處理](spatial-mapping.md#mesh-processing)，例如填滿洞或平滑表面法線。</span><span class="sxs-lookup"><span data-stu-id="3106d-300">In order to create a pleasing visual aesthetic, you may thus want to perform some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="3106d-301">您也可能想要使用著色器，將演出者設計的材質投影到網格上，而不是直接視覺化網格拓朴和法線。</span><span class="sxs-lookup"><span data-stu-id="3106d-301">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="3106d-302">適用于真實世界表面的 occluding 全息影像</span><span class="sxs-lookup"><span data-stu-id="3106d-302">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="3106d-303">空間表面可以在僅影響[深度緩衝區](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)且不會影響色彩呈現目標的深度傳遞中轉譯。</span><span class="sxs-lookup"><span data-stu-id="3106d-303">Spatial surfaces can be rendered in a depth-only pass which only affects the [depth buffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) and does not affect color render targets.</span></span>
   * <span data-ttu-id="3106d-304">這會質數深度緩衝區，以遮蔽後續呈現的空間表面後置影像。</span><span class="sxs-lookup"><span data-stu-id="3106d-304">This primes the depth buffer to occlude subsequently-rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="3106d-305">準確遮蔽的全息影像可增強全息影像真正存在於使用者的實體空間中的意義。</span><span class="sxs-lookup"><span data-stu-id="3106d-305">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="3106d-306">若要啟用僅深度轉譯，請更新 blend 狀態，將所有色彩呈現目標的[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)設定為零。</span><span class="sxs-lookup"><span data-stu-id="3106d-306">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) to zero for all color render targets.</span></span>
* <span data-ttu-id="3106d-307">修改真實世界表面所 pixels occluded 的全息影像外觀</span><span class="sxs-lookup"><span data-stu-id="3106d-307">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="3106d-308">在 pixels occluded 時，通常會隱藏呈現的幾何。</span><span class="sxs-lookup"><span data-stu-id="3106d-308">Normally rendered geometry is hidden when it is occluded.</span></span> <span data-ttu-id="3106d-309">這是藉由將[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中的深度函式設定為「小於或等於」來達成，這會使幾何只有在**靠近**相機的位置才可見，而不是所有先前呈現的幾何。</span><span class="sxs-lookup"><span data-stu-id="3106d-309">This is achieved by setting the depth function in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) to "less than or equal", which causes geometry to be visible only where it is **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="3106d-310">不過，即使在 pixels occluded 時仍然可以看到某些幾何，並在 pixels occluded 為對使用者提供視覺化回應的方式時修改其外觀，可能會有説明。</span><span class="sxs-lookup"><span data-stu-id="3106d-310">However, it may be useful to keep certain geometry visible even when it is occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="3106d-311">例如，這可讓應用程式向使用者顯示物件的位置，同時讓它清楚呈現在真實世界的表面上。</span><span class="sxs-lookup"><span data-stu-id="3106d-311">For example, this allows the application to show the user the location of an object whilst making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="3106d-312">若要達到此目的，請使用不同的著色器第二次轉譯幾何，以建立所需的 ' pixels occluded ' 外觀。</span><span class="sxs-lookup"><span data-stu-id="3106d-312">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="3106d-313">第二次呈現幾何之前，請對[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)進行兩個變更。</span><span class="sxs-lookup"><span data-stu-id="3106d-313">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="3106d-314">首先，將深度函式設定為「大於或等於」，如此一來，只有**在與所有**先前呈現的幾何相比，才會看到幾何的位置。</span><span class="sxs-lookup"><span data-stu-id="3106d-314">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it is **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="3106d-315">第二，將 DepthWriteMask 設定為零，如此就不會修改深度緩衝區（深度緩衝區應該會繼續代表**最接近**相機的幾何深度）。</span><span class="sxs-lookup"><span data-stu-id="3106d-315">Second, set the DepthWriteMask to zero, so that the depth buffer will not be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="3106d-316">在轉譯空間對應網格時，[效能](understanding-performance-for-mixed-reality.md)是很重要的考慮。</span><span class="sxs-lookup"><span data-stu-id="3106d-316">[Performance](understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="3106d-317">以下是呈現空間對應網格特有的一些轉譯效能技術：</span><span class="sxs-lookup"><span data-stu-id="3106d-317">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="3106d-318">調整三角形密度</span><span class="sxs-lookup"><span data-stu-id="3106d-318">Adjust triangle density</span></span>
   * <span data-ttu-id="3106d-319">當您從 surface 觀察者要求空間表面網格時，請要求可滿足您需求的最小三角形網格密度。</span><span class="sxs-lookup"><span data-stu-id="3106d-319">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="3106d-320">根據表面與使用者的距離，以及其與使用者體驗的相關性，可能會有意義地改變表面上的三角形密度。</span><span class="sxs-lookup"><span data-stu-id="3106d-320">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="3106d-321">減少三角形計數可減少 GPU 上的記憶體使用量和頂點處理成本，但不會影響圖元處理成本。</span><span class="sxs-lookup"><span data-stu-id="3106d-321">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it will not affect pixel processing costs.</span></span>
* <span data-ttu-id="3106d-322">執行截錐剔除</span><span class="sxs-lookup"><span data-stu-id="3106d-322">Perform frustum culling</span></span>
   * <span data-ttu-id="3106d-323">「截錐」剔除會略過無法看到的繪圖物件，因為它們不在目前的顯示為「截錐」。</span><span class="sxs-lookup"><span data-stu-id="3106d-323">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="3106d-324">這可降低 CPU 和 GPU 處理成本。</span><span class="sxs-lookup"><span data-stu-id="3106d-324">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="3106d-325">由於會針對每個網格來執行剔除，而空間表面可能會很大，因此，將每個空間表面網格細分成較小的區塊，可能會導致更有效率的剔除（會轉譯較少的螢幕三角形）。</span><span class="sxs-lookup"><span data-stu-id="3106d-325">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="3106d-326">不過，有一種取捨，您擁有的網格越多，您必須進行的繪製呼叫越多，這可能會增加 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="3106d-326">There is a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="3106d-327">在極端的情況下，截量的剔除計算本身甚至可以有可測量的 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="3106d-327">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="3106d-328">調整轉譯順序</span><span class="sxs-lookup"><span data-stu-id="3106d-328">Adjust rendering order</span></span>
   * <span data-ttu-id="3106d-329">空間表面通常會很大，因為它們代表使用者周圍的整個環境。</span><span class="sxs-lookup"><span data-stu-id="3106d-329">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="3106d-330">GPU 上的圖元處理成本可能會很高，特別是在有多個可見幾何層級的情況下（包括空間表面和其他全息影像）。</span><span class="sxs-lookup"><span data-stu-id="3106d-330">Pixel processing costs on the GPU can thus be high, especially in cases where there is more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="3106d-331">在此情況下，最接近使用者的圖層將會進一步 occluding 任何圖層，因此，所花費的任何 GPU 時間都會浪費較遠的層級。</span><span class="sxs-lookup"><span data-stu-id="3106d-331">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="3106d-332">為了減少 GPU 上的這項多餘的工作，它有助於以前後順序呈現不透明的表面（較接近的介面，最後一項則更遠）。</span><span class="sxs-lookup"><span data-stu-id="3106d-332">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="3106d-333">藉由「不透明」，我們表示在您的[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中，DepthWriteMask 設定為一個的表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-333">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="3106d-334">呈現最接近的表面時，會將深度緩衝區質數，使 GPU 上的圖元處理器可以有效率地略過較遠的表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-334">When the nearest surfaces are rendered, they will prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="3106d-335">網格處理</span><span class="sxs-lookup"><span data-stu-id="3106d-335">Mesh Processing</span></span>

<span data-ttu-id="3106d-336">應用程式可能會想要在空間 surface 網格上執行[各種作業](spatial-mapping.md#mesh-processing)，以符合其需求。</span><span class="sxs-lookup"><span data-stu-id="3106d-336">An application may want to perform [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="3106d-337">每個空間 surface 網格提供的索引和頂點資料，會使用與用來在所有新式轉譯 Api 中呈現三角形網格的[頂點和索引緩衝區](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)相同的熟悉配置。</span><span class="sxs-lookup"><span data-stu-id="3106d-337">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="3106d-338">不過，要注意的一個重要事實是，空間對應三角形具有**front 順時針的纏繞順序**。</span><span class="sxs-lookup"><span data-stu-id="3106d-338">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="3106d-339">每個三角形都會以網格的索引緩衝區中的三個頂點索引來表示，而這些索引會在從**前端**觀看三角形時，以**順時針**順序識別三角形的頂點。</span><span class="sxs-lookup"><span data-stu-id="3106d-339">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="3106d-340">空間 surface 網格的前端（或外部）與實際表面的正面（可見）邊緣相對應。</span><span class="sxs-lookup"><span data-stu-id="3106d-340">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="3106d-341">應用程式應該只在表面觀察器所提供的最粗略三角形密度仍能力不佳粗糙時，才執行網格簡化-這項工作的計算成本很高，且執行時間已執行，以產生各種不同的提供的詳細資料層級。</span><span class="sxs-lookup"><span data-stu-id="3106d-341">Applications should only perform mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="3106d-342">由於每個介面觀察者都可以提供多個未連接的空間介面，因此某些應用程式可能會想要彼此裁剪這些空間表面網格，然後將它們 zipper 在一起。</span><span class="sxs-lookup"><span data-stu-id="3106d-342">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="3106d-343">一般而言，裁剪步驟是必要的，因為附近的空間介面網格通常會稍微重迭。</span><span class="sxs-lookup"><span data-stu-id="3106d-343">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="3106d-344">Raycasting 和碰撞</span><span class="sxs-lookup"><span data-stu-id="3106d-344">Raycasting and Collision</span></span>

<span data-ttu-id="3106d-345">為了讓物理 API （例如[Havok](https://www.havok.com/)）為應用程式提供空間表面的 raycasting 和碰撞功能，應用程式必須提供空間介面網格給物理 api。</span><span class="sxs-lookup"><span data-stu-id="3106d-345">In order for a physics API (such as [Havok](https://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="3106d-346">用於物理的網格通常具有下列屬性：</span><span class="sxs-lookup"><span data-stu-id="3106d-346">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="3106d-347">它們只包含少量的三角形。</span><span class="sxs-lookup"><span data-stu-id="3106d-347">They contain only small numbers of triangles.</span></span> <span data-ttu-id="3106d-348">物理運算比轉譯作業更密集。</span><span class="sxs-lookup"><span data-stu-id="3106d-348">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="3106d-349">它們是「水緊密」。</span><span class="sxs-lookup"><span data-stu-id="3106d-349">They are 'water-tight'.</span></span> <span data-ttu-id="3106d-350">預期為實心的表面不應該有小孔;即使是太小而無法顯示的漏洞，也可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="3106d-350">Surfaces intended to be solid should not have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="3106d-351">它們會轉換成凸 hulls。</span><span class="sxs-lookup"><span data-stu-id="3106d-351">They are converted into convex hulls.</span></span> <span data-ttu-id="3106d-352">凸 hulls 有幾個多邊形，而且沒有洞，而且比原始三角形網格更有效率地處理。</span><span class="sxs-lookup"><span data-stu-id="3106d-352">Convex hulls have few polygons and are free of holes, and they are much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="3106d-353">針對空間表面執行 raycasts 時，請記住，這些表面通常是很複雜、雜亂的圖案，而且有雜亂的細節，就像您的辦公桌一樣！</span><span class="sxs-lookup"><span data-stu-id="3106d-353">When performing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="3106d-354">這表示單一 raycast 通常不足以提供介面圖形的足夠資訊，以及接近其附近的空白空間的形狀。</span><span class="sxs-lookup"><span data-stu-id="3106d-354">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="3106d-355">因此，在小型區域中執行許多 raycasts，以及使用匯總結果來衍生更可靠的介面瞭解，通常是個不錯的主意。</span><span class="sxs-lookup"><span data-stu-id="3106d-355">It is thus usually a good idea to perform many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="3106d-356">例如，使用單一 raycast 的平均 10 raycasts 來引導全息影像放置在表面上，會產生更流暢且較少的「抖動」結果。</span><span class="sxs-lookup"><span data-stu-id="3106d-356">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="3106d-357">不過，請記住，每個 raycast 都有高計算成本。</span><span class="sxs-lookup"><span data-stu-id="3106d-357">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="3106d-358">因此，視您的使用案例而定，您應該將其他 raycasts （每個框架執行）的計算成本與[網格處理](spatial-mapping.md#mesh-processing)的計算成本進行取捨，以平滑和移除空間介面中的漏洞（在空間時執行）網格已更新）。</span><span class="sxs-lookup"><span data-stu-id="3106d-358">Thus depending on your usage scenario you should trade off the computational cost of additional raycasts (performed every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (performed when spatial meshes are updated).</span></span>

## <a name="the-environment-scanning-experience"></a><span data-ttu-id="3106d-359">環境掃描體驗</span><span class="sxs-lookup"><span data-stu-id="3106d-359">The environment scanning experience</span></span>

<span data-ttu-id="3106d-360">每個使用空間對應的應用程式都應該考慮提供「掃描經驗」;應用程式用來引導使用者掃描應用程式正常運作所需表面的進程。</span><span class="sxs-lookup"><span data-stu-id="3106d-360">Each application that uses spatial mapping should consider providing a 'scanning experience'; the process through which the application guides the user to scan surfaces that are necessary for the application to function correctly.</span></span>

<span data-ttu-id="3106d-361">![掃描](images/sr-mixedworld-140429-8pm-00068-1000px.png) 的範例</span><span class="sxs-lookup"><span data-stu-id="3106d-361">![Example of scanning](images/sr-mixedworld-140429-8pm-00068-1000px.png)</span></span><br>
<span data-ttu-id="3106d-362">*掃描的範例*</span><span class="sxs-lookup"><span data-stu-id="3106d-362">*Example of scanning*</span></span>

<span data-ttu-id="3106d-363">此掃描體驗的本質可能會因為每個應用程式的需求而有很大的差異，但兩個主要原則應該會引導其設計。</span><span class="sxs-lookup"><span data-stu-id="3106d-363">The nature of this scanning experience can vary greatly depending upon each application's needs, but two main principles should guide its design.</span></span>

<span data-ttu-id="3106d-364">首先，**與使用者進行明確通訊是主要的考慮**。</span><span class="sxs-lookup"><span data-stu-id="3106d-364">Firstly, **clear communication with the user is the primary concern**.</span></span> <span data-ttu-id="3106d-365">使用者應該一律知道是否符合應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="3106d-365">The user should always be aware of whether the application's requirements are being met.</span></span> <span data-ttu-id="3106d-366">如果不符合這些條件，使用者應該立即清楚知道這是什麼，而且應該很快就會採取適當的動作。</span><span class="sxs-lookup"><span data-stu-id="3106d-366">When they are not being met, it should be immediately clear to the user why this is so and they should be quickly led to take the appropriate action.</span></span>

<span data-ttu-id="3106d-367">其次，**應用程式應該嘗試在效率和可靠性之間取得平衡**。</span><span class="sxs-lookup"><span data-stu-id="3106d-367">Secondly, **applications should attempt to strike a balance between efficiency and reliability**.</span></span> <span data-ttu-id="3106d-368">當可以**可靠地**執行此動作時，應用程式應該會自動分析空間對應資料以節省使用者時間。</span><span class="sxs-lookup"><span data-stu-id="3106d-368">When it is possible to do so **reliably**, applications should automatically analyze spatial mapping data to save the user time.</span></span> <span data-ttu-id="3106d-369">當您無法可靠地執行此動作時，應用程式應該改為讓使用者快速提供所需的其他資訊給應用程式。</span><span class="sxs-lookup"><span data-stu-id="3106d-369">When it is not possible to do so reliably, applications should instead enable the user to quickly provide the application with the additional information it requires.</span></span>

<span data-ttu-id="3106d-370">為了協助設計正確的掃描經驗，請考慮下列何種可能適用于您的應用程式：</span><span class="sxs-lookup"><span data-stu-id="3106d-370">To help design the right scanning experience, consider which of the following possibilities are applicable to your application:</span></span>

* <span data-ttu-id="3106d-371">**沒有掃描經驗**</span><span class="sxs-lookup"><span data-stu-id="3106d-371">**No scanning experience**</span></span>
   * <span data-ttu-id="3106d-372">應用程式可以順利運作，而不需要任何引導式掃描體驗;它將瞭解在自然使用者移動期間觀察到的表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-372">An application may function perfectly without any guided scanning experience; it will learn about surfaces that are observed in the course of natural user movement.</span></span>
   * <span data-ttu-id="3106d-373">例如，可讓使用者在使用全像攝影的表面上繪製的應用程式，只需要知道使用者目前可以看見的表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-373">For example an application that lets the user draw on surfaces with holographic spray paint requires knowledge only of the surfaces currently visible to the user.</span></span>
   * <span data-ttu-id="3106d-374">如果環境是使用者已花很多時間使用 HoloLens 的情況，則可能已完全掃描該環境。</span><span class="sxs-lookup"><span data-stu-id="3106d-374">The environment may be completely scanned already if it is one in which the user has already spent a lot of time using the HoloLens.</span></span>
   * <span data-ttu-id="3106d-375">但請記住，空間對應所使用的相機只能看到使用者前方的 3.1 m，因此空間對應將不會知道任何更遠的表面，除非使用者已從較近的距離觀察到它們。</span><span class="sxs-lookup"><span data-stu-id="3106d-375">Bear in mind however that the camera used by spatial mapping can only see 3.1m in front of the user, so spatial mapping will not know about any more distant surfaces unless the user has observed them from a closer distance in the past.</span></span>
   * <span data-ttu-id="3106d-376">因此，使用者瞭解已掃描的表面，應用程式應該為此效果提供視覺化的意見反應，例如，將虛擬陰影轉型為掃描的表面，可以協助使用者在這些表面上放置全息影像。</span><span class="sxs-lookup"><span data-stu-id="3106d-376">So the user understands which surfaces have been scanned, the application should provide visual feedback to this effect, for example casting virtual shadows onto scanned surfaces may help the user place holograms on those surfaces.</span></span>
   * <span data-ttu-id="3106d-377">在此情況下，空間介面觀察者的周框應將每個框架更新為主體鎖定的[空間座標系統](coordinate-systems.md)，使其遵循使用者。</span><span class="sxs-lookup"><span data-stu-id="3106d-377">For this case, the spatial surface observer's bounding volumes should be updated each frame to a body-locked [spatial coordinate system](coordinate-systems.md), so that they follow the user.</span></span>

* <span data-ttu-id="3106d-378">**尋找適當的位置**</span><span class="sxs-lookup"><span data-stu-id="3106d-378">**Find a suitable location**</span></span>
   * <span data-ttu-id="3106d-379">應用程式可以設計成在具有特定需求的位置中使用。</span><span class="sxs-lookup"><span data-stu-id="3106d-379">An application may be designed for use in a location with specific requirements.</span></span>
   * <span data-ttu-id="3106d-380">例如，應用程式可能需要使用者附近的空白區域，才能安全地練習全像 kung-fu。</span><span class="sxs-lookup"><span data-stu-id="3106d-380">For example, the application may require an empty area around the user so they can safely practice holographic kung-fu.</span></span>
   * <span data-ttu-id="3106d-381">應用程式應該將任何特定的需求傳遞給使用者，並以清楚的視覺效果回饋來加強。</span><span class="sxs-lookup"><span data-stu-id="3106d-381">Applications should communicate any specific requirements to the user up-front, and reinforce them with clear visual feedback.</span></span>
   * <span data-ttu-id="3106d-382">在此範例中，應用程式應該將所需空白區域的範圍視覺化，並以視覺化方式反白顯示此區域內任何不想要的物件。</span><span class="sxs-lookup"><span data-stu-id="3106d-382">In this example, the application should visualize the extent of the required empty area and visually highlight the presence of any undesired objects within this zone.</span></span>
   * <span data-ttu-id="3106d-383">在此情況下，空間表面觀察器的周框磁片區應該在選擇的位置中使用世界鎖定的[空間座標系統](coordinate-systems.md)。</span><span class="sxs-lookup"><span data-stu-id="3106d-383">For this case, the spatial surface observer's bounding volumes should use a world-locked [spatial coordinate system](coordinate-systems.md) in the chosen location.</span></span>

* <span data-ttu-id="3106d-384">**尋找適當的表面設定**</span><span class="sxs-lookup"><span data-stu-id="3106d-384">**Find a suitable configuration of surfaces**</span></span>
   * <span data-ttu-id="3106d-385">應用程式可能需要特定的介面設定，例如兩個大型、平面、相反的牆，以建立非全像的鏡像大廳。</span><span class="sxs-lookup"><span data-stu-id="3106d-385">An application may require a specific configuration of surfaces, for example two large, flat, opposing walls to create a holographic hall of mirrors.</span></span>
   * <span data-ttu-id="3106d-386">在這種情況下，應用程式必須分析空間對應所提供的表面，以偵測適當的表面，並將使用者導向至這些介面。</span><span class="sxs-lookup"><span data-stu-id="3106d-386">In such cases the application will need to analyze the surfaces provided by spatial mapping to detect suitable surfaces, and direct the user toward them.</span></span>
   * <span data-ttu-id="3106d-387">如果應用程式的表面分析不完全可靠，使用者應該有一個 fallback 選項。</span><span class="sxs-lookup"><span data-stu-id="3106d-387">The user should have a fallback option if the application's surface analysis is not completely reliable.</span></span> <span data-ttu-id="3106d-388">例如，如果應用程式不正確地將門口識別為平面，則使用者需要一個簡單的方法來更正此錯誤。</span><span class="sxs-lookup"><span data-stu-id="3106d-388">For example, if the application incorrectly identifies a doorway as a flat wall, the user needs a simple way to correct this error.</span></span>

* <span data-ttu-id="3106d-389">**掃描環境的一部分**</span><span class="sxs-lookup"><span data-stu-id="3106d-389">**Scan part of the environment**</span></span>
   * <span data-ttu-id="3106d-390">應用程式可能只想要依使用者的指示來捕捉部分的環境。</span><span class="sxs-lookup"><span data-stu-id="3106d-390">An application may wish to only capture part of the environment, as directed by the user.</span></span>
   * <span data-ttu-id="3106d-391">例如，應用程式會掃描部分房間，讓使用者可以針對想要銷售的傢俱張貼全像的分類廣告。</span><span class="sxs-lookup"><span data-stu-id="3106d-391">For example, the application scans part of a room so the user may post a holographic classified ad for furniture they wish to sell.</span></span>
   * <span data-ttu-id="3106d-392">在此情況下，應用程式應該在使用者于其掃描期間觀察到的區域內，捕獲空間對應資料。</span><span class="sxs-lookup"><span data-stu-id="3106d-392">In this case, the application should capture spatial mapping data within the regions observed by the user during their scan.</span></span>

* <span data-ttu-id="3106d-393">**掃描整個聊天室**</span><span class="sxs-lookup"><span data-stu-id="3106d-393">**Scan the whole room**</span></span>
   * <span data-ttu-id="3106d-394">應用程式可能需要掃描目前房間中的所有介面，包括使用者背後的表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-394">An application may require a scan of all of the surfaces in the current room, including those behind the user.</span></span>
   * <span data-ttu-id="3106d-395">例如，遊戲可能會將使用者 Gulliver 的角色，siege 從所有方向接近數百個小型 Lilliputians。</span><span class="sxs-lookup"><span data-stu-id="3106d-395">For example, a game may put the user in the role of Gulliver, under siege from hundreds of tiny Lilliputians approaching from all directions.</span></span>
   * <span data-ttu-id="3106d-396">在這種情況下，應用程式必須判斷目前的房間中有多少表面已經過掃描，並引導使用者的注視填滿明顯的間隙。</span><span class="sxs-lookup"><span data-stu-id="3106d-396">In such cases, the application will need to determine how many of the surfaces in the current room have already been scanned, and direct the user's gaze to fill in significant gaps.</span></span>
   * <span data-ttu-id="3106d-397">此程式的關鍵在於提供視覺化意見反應，讓使用者清楚指出尚未掃描的表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-397">The key to this process is providing visual feedback that makes it clear to the user which surfaces have not yet been scanned.</span></span> <span data-ttu-id="3106d-398">例如，應用程式可以使用以[距離為基礎的霧化](https://msdn.microsoft.com/library/windows/desktop/bb173401%28v=vs.85%29.aspx)，以視覺方式反白顯示空間對應介面未涵蓋的區域。</span><span class="sxs-lookup"><span data-stu-id="3106d-398">The application could for example use [distance-based fog](https://msdn.microsoft.com/library/windows/desktop/bb173401%28v=vs.85%29.aspx) to visually highlight regions that are not covered by spatial mapping surfaces.</span></span>

* <span data-ttu-id="3106d-399">**製作環境的初始快照集**</span><span class="sxs-lookup"><span data-stu-id="3106d-399">**Take an initial snapshot of the environment**</span></span>
   * <span data-ttu-id="3106d-400">應用程式可能會想要在取得初始「快照集」之後忽略環境中的所有變更。</span><span class="sxs-lookup"><span data-stu-id="3106d-400">An application may wish to ignore all changes in the environment after taking an initial 'snapshot'.</span></span>
   * <span data-ttu-id="3106d-401">這可能適合用來避免使用者建立的資料中斷，並與環境的初始狀態緊密結合。</span><span class="sxs-lookup"><span data-stu-id="3106d-401">This may be appropriate to avoid disruption of user-created data that is tightly coupled to the initial state of the environment.</span></span>
   * <span data-ttu-id="3106d-402">在此情況下，當掃描完成時，應用程式應該複製其初始狀態的空間對應資料。</span><span class="sxs-lookup"><span data-stu-id="3106d-402">In this case, the application should make a copy of the spatial mapping data in its initial state once the scan is complete.</span></span>
   * <span data-ttu-id="3106d-403">如果環境仍然正確地 pixels occluded 了全息影像，應用程式應該會繼續接收空間對應資料的更新。</span><span class="sxs-lookup"><span data-stu-id="3106d-403">Applications should continue receiving updates to spatial mapping data if holograms are still to be correctly occluded by the environment.</span></span>
   * <span data-ttu-id="3106d-404">對於空間對應資料的持續更新也允許視覺化已發生的任何變更，並向使用者說明環境先前和目前狀態之間的差異。</span><span class="sxs-lookup"><span data-stu-id="3106d-404">Continued updates to spatial mapping data also allow visualizing any changes that have occurred, clarifying to the user the differences between prior and present states of the environment.</span></span>

* <span data-ttu-id="3106d-405">**採取使用者起始的環境快照**</span><span class="sxs-lookup"><span data-stu-id="3106d-405">**Take user-initiated snapshots of the environment**</span></span>
   * <span data-ttu-id="3106d-406">應用程式可能只想要在使用者指示時回應環境變更。</span><span class="sxs-lookup"><span data-stu-id="3106d-406">An application may only wish to respond to environmental changes when instructed by the user.</span></span>
   * <span data-ttu-id="3106d-407">例如，使用者可以在不同的時間捕捉其姿勢，藉以建立多個 friend 的 3D ' statues '。</span><span class="sxs-lookup"><span data-stu-id="3106d-407">For example, the user could create multiple 3D 'statues' of a friend by capturing their poses at different moments.</span></span>

* <span data-ttu-id="3106d-408">**允許使用者變更環境**</span><span class="sxs-lookup"><span data-stu-id="3106d-408">**Allow the user to change the environment**</span></span>
   * <span data-ttu-id="3106d-409">應用程式可以設計成即時回應使用者環境中所做的任何變更。</span><span class="sxs-lookup"><span data-stu-id="3106d-409">An application may be designed to respond in real-time to any changes made in the user's environment.</span></span>
   * <span data-ttu-id="3106d-410">例如，使用者繪製揭開可能會觸發「場景變更」，以在另一端進行全像播放。</span><span class="sxs-lookup"><span data-stu-id="3106d-410">For example, the user drawing a curtain could trigger 'scene change' for a holographic play taking place on the other side.</span></span>

* <span data-ttu-id="3106d-411">**引導使用者避免空間對應資料中的錯誤**</span><span class="sxs-lookup"><span data-stu-id="3106d-411">**Guide the user to avoid errors in the spatial mapping data**</span></span>
   * <span data-ttu-id="3106d-412">應用程式在掃描其環境時，可能會想要為使用者提供指引。</span><span class="sxs-lookup"><span data-stu-id="3106d-412">An application may wish to provide guidance to the user while they are scanning their environment.</span></span>
   * <span data-ttu-id="3106d-413">這可協助使用者避免[空間對應資料中](spatial-mapping.md#what-influences-spatial-mapping-quality)特定類型的錯誤，例如，離開 sunlit 視窗或鏡像。</span><span class="sxs-lookup"><span data-stu-id="3106d-413">This can help the user to avoid certain kinds of [errors in the spatial mapping data](spatial-mapping.md#what-influences-spatial-mapping-quality), for example by staying away from sunlit windows or mirrors.</span></span>

<span data-ttu-id="3106d-414">另一個要注意的詳細資料是空間對應資料的「範圍」不是無限的。</span><span class="sxs-lookup"><span data-stu-id="3106d-414">One additional detail to be aware of is that the 'range' of spatial mapping data is not unlimited.</span></span> <span data-ttu-id="3106d-415">雖然空間對應確實會建立大量的永久資料庫，但它只會將資料提供給使用者周圍具有有限大小的「反升」應用程式。</span><span class="sxs-lookup"><span data-stu-id="3106d-415">Whilst spatial mapping does build a permanent database of large spaces, it only makes that data available to applications in a 'bubble' of limited size around the user.</span></span> <span data-ttu-id="3106d-416">因此，如果您從長 corridor 的開端開始，並從一開始就夠遠，那麼最後的空間表面就會消失。</span><span class="sxs-lookup"><span data-stu-id="3106d-416">Thus if you start at the beginning of a long corridor and walk far enough away from the start, then eventually the spatial surfaces back at the beginning will disappear.</span></span> <span data-ttu-id="3106d-417">您可以藉由在應用程式中的介面從可用空間對應資料消失之後，將這些表面快取，藉此減輕此問題。</span><span class="sxs-lookup"><span data-stu-id="3106d-417">You can of course mitigate this by caching those surfaces in your application after they have disappeared from the available spatial mapping data.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="3106d-418">網格處理</span><span class="sxs-lookup"><span data-stu-id="3106d-418">Mesh processing</span></span>

<span data-ttu-id="3106d-419">這可能有助於偵測介面中常見的錯誤類型，並視需要篩選、移除或修改空間對應資料。</span><span class="sxs-lookup"><span data-stu-id="3106d-419">It may help to detect common types of errors in surfaces and to filter, remove or modify the spatial mapping data as appropriate.</span></span>

<span data-ttu-id="3106d-420">請記住，空間對應資料的目的是要盡可能忠實呈現到真實世界的表面，因此您套用的任何處理風險會從「真」進一步改變您的表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-420">Bear in mind that spatial mapping data is intended to be as faithful as possible to real-world surfaces, so any processing you apply risks shifting your surfaces further from the 'truth'.</span></span>

<span data-ttu-id="3106d-421">以下是一些您可能會覺得有用的不同網格處理類型範例：</span><span class="sxs-lookup"><span data-stu-id="3106d-421">Here are some examples of different types of mesh processing that you may find useful:</span></span>

* <span data-ttu-id="3106d-422">**孔填滿**</span><span class="sxs-lookup"><span data-stu-id="3106d-422">**Hole filling**</span></span>
   * <span data-ttu-id="3106d-423">如果無法掃描呈現深色資料的小型物件，則會在周圍表面留下一個洞。</span><span class="sxs-lookup"><span data-stu-id="3106d-423">If a small object made of a dark material fails to scan, it will leave a hole in the surrounding surface.</span></span>
   * <span data-ttu-id="3106d-424">孔會影響遮蔽：您可以在被視為不透明的真實世界表面中，看到「到」一個洞處的全息影像。</span><span class="sxs-lookup"><span data-stu-id="3106d-424">Holes affect occlusion: holograms can be seen 'through' a hole in a supposedly opaque real-world surface.</span></span>
   * <span data-ttu-id="3106d-425">孔會影響 raycasts：如果您使用 raycasts 來協助使用者與介面互動，則這些光線可能不會想要通過洞。</span><span class="sxs-lookup"><span data-stu-id="3106d-425">Holes affect raycasts: if you are using raycasts to help users interact with surfaces, it may be undesirable for these rays to pass through holes.</span></span> <span data-ttu-id="3106d-426">其中一個緩和措施是使用多個 raycasts 的組合，涵蓋適當大小的區域。</span><span class="sxs-lookup"><span data-stu-id="3106d-426">One mitigation is to use a bundle of multiple raycasts covering an appropriately sized region.</span></span> <span data-ttu-id="3106d-427">這可讓您篩選 ' 極端 ' 的結果，如此一來，即使某個 raycast 通過小洞，匯總結果仍會是有效的。</span><span class="sxs-lookup"><span data-stu-id="3106d-427">This will allow you to filter 'outlier' results, so that even if one raycast passes through a small hole, the aggregate result will still be valid.</span></span> <span data-ttu-id="3106d-428">不過，請注意，這種方法是以計算成本來表示。</span><span class="sxs-lookup"><span data-stu-id="3106d-428">However, be aware that this approach comes at a computational cost.</span></span>
   * <span data-ttu-id="3106d-429">孔會影響物理衝突：物理模擬所控制的物件可能會透過樓層中的洞下降，並會遺失。</span><span class="sxs-lookup"><span data-stu-id="3106d-429">Holes affect physics collisions: an object controlled by physics simulation may drop through a hole in the floor and become lost.</span></span>
   * <span data-ttu-id="3106d-430">您可以在 surface 網格中以演算法方式填滿這類洞。</span><span class="sxs-lookup"><span data-stu-id="3106d-430">It is possible to algorithmically fill such holes in the surface mesh.</span></span> <span data-ttu-id="3106d-431">不過，您必須調整您的演算法，讓「真實漏洞」（例如 windows 和門口）不會填滿。</span><span class="sxs-lookup"><span data-stu-id="3106d-431">However, you will need to tune your algorithm so that 'real holes' such as windows and doorways do not get filled in.</span></span> <span data-ttu-id="3106d-432">很難以可靠地區分「真實漏洞」與「虛數孔」，因此您必須試驗不同的啟發學習法，例如「大小」和「界限圖形」。</span><span class="sxs-lookup"><span data-stu-id="3106d-432">It can be difficult to reliably differentiate 'real holes' from 'imaginary holes', so you will need to experiment with different heuristics such as 'size' and 'boundary shape'.</span></span>

* <span data-ttu-id="3106d-433">**Hallucination 移除**</span><span class="sxs-lookup"><span data-stu-id="3106d-433">**Hallucination removal**</span></span>
   * <span data-ttu-id="3106d-434">反射、明亮的燈和移動物件可能會使小型延遲的「hallucinations」浮動在空中。</span><span class="sxs-lookup"><span data-stu-id="3106d-434">Reflections, bright lights and moving objects can leave small lingering 'hallucinations' floating in mid-air.</span></span>
   * <span data-ttu-id="3106d-435">Hallucinations 會影響遮蔽： Hallucinations 可能會顯示為在和 occluding 其他全息影像之前移動的深色形狀。</span><span class="sxs-lookup"><span data-stu-id="3106d-435">Hallucinations affect occlusion: hallucinations may become visible as dark shapes moving in front of and occluding other holograms.</span></span>
   * <span data-ttu-id="3106d-436">Hallucinations 會影響 raycasts：如果您使用 raycasts 協助使用者與表面互動，這些光線可能會叫用 hallucination 而不是其背後的表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-436">Hallucinations affect raycasts: if you are using raycasts to help users interact with surfaces, these rays could hit a hallucination instead of the surface behind it.</span></span> <span data-ttu-id="3106d-437">如同使用漏洞，其中一個緩和措施是使用許多 raycasts，而不是單一 raycast，但同樣地，這會產生計算成本。</span><span class="sxs-lookup"><span data-stu-id="3106d-437">As with holes, one mitigation is to use many raycasts instead of a single raycast, but again this will come at a computational cost.</span></span>
   * <span data-ttu-id="3106d-438">Hallucinations 會影響物理衝突：由物理模擬控制的物件可能會卡在 hallucination 中，而且無法在看似清楚的空間區域間移動。</span><span class="sxs-lookup"><span data-stu-id="3106d-438">Hallucinations affect physics collisions: an object controlled by physics simulation may become stuck against a hallucination and be unable to move through a seemingly clear area of space.</span></span>
   * <span data-ttu-id="3106d-439">您可以從 surface 網格篩選這類 hallucinations。</span><span class="sxs-lookup"><span data-stu-id="3106d-439">It is possible to filter such hallucinations from the surface mesh.</span></span> <span data-ttu-id="3106d-440">不過，就像使用洞一樣，您必須調整您的演算法，如此一來，就不會移除像是燈泡和門控點的實際小型物件。</span><span class="sxs-lookup"><span data-stu-id="3106d-440">However, as with holes, you will need to tune your algorithm so that real small objects such as lamp-stands and door handles do not get removed.</span></span>

* <span data-ttu-id="3106d-441">**平穩**</span><span class="sxs-lookup"><span data-stu-id="3106d-441">**Smoothing**</span></span>
   * <span data-ttu-id="3106d-442">空間對應可能會傳回看似粗略或「雜訊」的表面，相較于其真實世界的對應專案。</span><span class="sxs-lookup"><span data-stu-id="3106d-442">Spatial mapping may return surfaces that appear to be rough or 'noisy' in comparison to their real-world counterparts.</span></span>
   * <span data-ttu-id="3106d-443">平滑度會影響物理衝突：如果地面是粗略的，實際模擬的高爾夫球球可能不會以直線平滑地在其上向前復原。</span><span class="sxs-lookup"><span data-stu-id="3106d-443">Smoothness affects physics collisions: if the floor is rough, a physically simulated golf ball may not roll smoothly across it in a straight line.</span></span>
   * <span data-ttu-id="3106d-444">平滑度會影響轉譯：如果介面是直接視覺化的，則粗略的表面法線會影響其外觀，並干擾「整潔」外觀。</span><span class="sxs-lookup"><span data-stu-id="3106d-444">Smoothness affects rendering: if a surface is visualized directly, rough surface normals can affect its appearance and disrupt a 'clean' look.</span></span> <span data-ttu-id="3106d-445">使用著色器中用來呈現介面的適當光源和材質，可以減輕這種情況。</span><span class="sxs-lookup"><span data-stu-id="3106d-445">It is possible to mitigate this by using appropriate lighting and textures in the shader that is used to render the surface.</span></span>
   * <span data-ttu-id="3106d-446">可以在表面網格中平滑粗糙度。</span><span class="sxs-lookup"><span data-stu-id="3106d-446">It is possible to smooth out roughness in a surface mesh.</span></span> <span data-ttu-id="3106d-447">不過，這可能會使表面遠離對應的真實世界表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-447">However, this may push the surface further away from the corresponding real-world surface.</span></span> <span data-ttu-id="3106d-448">維護鄰近的對應對於產生正確的全像投影遮蔽，以及讓使用者能夠與全像攝影表面達成精確且可預測的互動，是很重要的。</span><span class="sxs-lookup"><span data-stu-id="3106d-448">Maintaining a close correspondence is important to produce accurate hologram occlusion, and to enable users to achieve precise and predictable interactions with holographic surfaces.</span></span>
   * <span data-ttu-id="3106d-449">如果只需要修飾的變更，可能就足以平滑頂點法線，而不會變更頂點位置。</span><span class="sxs-lookup"><span data-stu-id="3106d-449">If only a cosmetic change is required, it may be sufficient to smooth vertex normals without changing vertex positions.</span></span>

* <span data-ttu-id="3106d-450">**平面尋找**</span><span class="sxs-lookup"><span data-stu-id="3106d-450">**Plane finding**</span></span>
   * <span data-ttu-id="3106d-451">應用程式可能會想要在空間對應所提供的表面上執行許多形式的分析。</span><span class="sxs-lookup"><span data-stu-id="3106d-451">There are many forms of analysis that an application may wish to perform on the surfaces provided by spatial mapping.</span></span>
   * <span data-ttu-id="3106d-452">一個簡單的範例是「平面尋找」;識別表面的界限、主要區域。</span><span class="sxs-lookup"><span data-stu-id="3106d-452">One simple example is 'plane finding'; identifying bounded, mostly-planar regions of surfaces.</span></span>
   * <span data-ttu-id="3106d-453">平面區域可用來做為全像攝影的工作介面，也就是可由應用程式自動放置全像攝影內容的區域。</span><span class="sxs-lookup"><span data-stu-id="3106d-453">Planar regions can be used as holographic work-surfaces, regions where holographic content can be automatically placed by the application.</span></span>
   * <span data-ttu-id="3106d-454">平面區域可以限制使用者介面，以引導使用者與最符合其需求的表面進行互動。</span><span class="sxs-lookup"><span data-stu-id="3106d-454">Planar regions can constrain the user interface, to guide users to interact with the surfaces that best suit their needs.</span></span>
   * <span data-ttu-id="3106d-455">平面區域可在真實世界中用來做為全像，對功能物件（例如 LCD 畫面、表格或白板）進行全像投影。</span><span class="sxs-lookup"><span data-stu-id="3106d-455">Planar regions can be used as in the real world, for holographic counterparts to functional objects such as LCD screens, tables or whiteboards.</span></span>
   * <span data-ttu-id="3106d-456">平面區域可以定義播放區域，形成 videogame 層級的基礎。</span><span class="sxs-lookup"><span data-stu-id="3106d-456">Planar regions can define play areas, forming the basis of videogame levels.</span></span>
   * <span data-ttu-id="3106d-457">平面區域可以協助虛擬代理程式流覽真實世界，方法是識別真實人員可能會進行的樓層。</span><span class="sxs-lookup"><span data-stu-id="3106d-457">Planar regions can aid virtual agents to navigate the real world, by identifying the areas of floor that real people are likely to walk on.</span></span>

## <a name="prototyping-and-debugging"></a><span data-ttu-id="3106d-458">原型設計和調試</span><span class="sxs-lookup"><span data-stu-id="3106d-458">Prototyping and debugging</span></span>

### <a name="useful-tools"></a><span data-ttu-id="3106d-459">有用的工具</span><span class="sxs-lookup"><span data-stu-id="3106d-459">Useful tools</span></span>
* <span data-ttu-id="3106d-460">[HoloLens 模擬器](using-the-hololens-emulator.md)可用來使用空間對應來開發應用程式，而不需要存取實體 HoloLens。</span><span class="sxs-lookup"><span data-stu-id="3106d-460">The [HoloLens emulator](using-the-hololens-emulator.md) can be used to develop applications using spatial mapping without access to a physical HoloLens.</span></span> <span data-ttu-id="3106d-461">它可讓您在實際環境中模擬 HoloLens 上的即時會話，其中包含您的應用程式通常會使用的所有資料，包括 HoloLens 動作、空間座標系統和空間對應網格。</span><span class="sxs-lookup"><span data-stu-id="3106d-461">It allows you to simulate a live session on a HoloLens in a realistic environment, with all of the data your application would normally consume, including HoloLens motion, spatial coordinate systems and spatial mapping meshes.</span></span> <span data-ttu-id="3106d-462">這可用來提供可靠且可重複的輸入，這在偵測問題及評估程式碼變更時很有用。</span><span class="sxs-lookup"><span data-stu-id="3106d-462">This can be used to provide reliable, repeatable input, which can be useful for debugging problems and evaluating changes to your code.</span></span>
* <span data-ttu-id="3106d-463">若要重現案例，請從即時 HoloLens 透過網路捕獲空間對應資料，然後將它儲存到磁片，然後在後續的調試階段中重複使用它。</span><span class="sxs-lookup"><span data-stu-id="3106d-463">To reproduce a scenarios, capture spatial mapping data over the network from a live HoloLens, then save it to disk and reuse it in subsequent debugging sessions.</span></span>
* <span data-ttu-id="3106d-464">[Windows 裝置入口網站 3d view](using-the-windows-device-portal.md#3d-view)提供了一種方式，可讓您查看目前可透過空間對應系統取得的所有空間表面。</span><span class="sxs-lookup"><span data-stu-id="3106d-464">The [Windows device portal 3D view](using-the-windows-device-portal.md#3d-view) provides a way to see all of the spatial surfaces currently available via the spatial mapping system.</span></span> <span data-ttu-id="3106d-465">這可為應用程式內的空間表面進行比較，例如，您可以輕鬆地分辨是否有任何空間表面遺失或顯示在錯誤的位置。</span><span class="sxs-lookup"><span data-stu-id="3106d-465">This provides a basis of comparison for the spatial surfaces inside your application; for example you can easily tell if any spatial surfaces are missing or are being displayed in the wrong place.</span></span>

### <a name="general-prototyping-guidance"></a><span data-ttu-id="3106d-466">一般原型指引</span><span class="sxs-lookup"><span data-stu-id="3106d-466">General prototyping guidance</span></span>
* <span data-ttu-id="3106d-467">由於空間對應資料中的[錯誤](spatial-mapping.md#what-influences-spatial-mapping-quality)可能會對使用者的體驗造成強烈影響，因此建議您在各種不同的環境中測試您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="3106d-467">Because [errors](spatial-mapping.md#what-influences-spatial-mapping-quality) in the spatial mapping data may strongly affect your user's experience, we recommend that you test your application in a wide variety of environments.</span></span>
* <span data-ttu-id="3106d-468">千萬不要在相同位置（例如您的辦公桌）中永遠進行測試。</span><span class="sxs-lookup"><span data-stu-id="3106d-468">Don't get trapped in the habit of always testing in the same location, for example at your desk.</span></span> <span data-ttu-id="3106d-469">請務必在不同位置、圖形、大小和材質的各種表面上進行測試。</span><span class="sxs-lookup"><span data-stu-id="3106d-469">Make sure to test on various surfaces of different positions, shapes, sizes and materials.</span></span>
* <span data-ttu-id="3106d-470">同樣地，雖然綜合或記錄的資料可用於進行調試，但不太依賴相同的幾個測試案例。</span><span class="sxs-lookup"><span data-stu-id="3106d-470">Similarly, while synthetic or recorded data can be useful for debugging, don't become too reliant upon the same few test cases.</span></span> <span data-ttu-id="3106d-471">這可能會延遲找出更多測試會稍早發現的重要問題。</span><span class="sxs-lookup"><span data-stu-id="3106d-471">This may delay finding important issues that more varied testing would have caught earlier.</span></span>
* <span data-ttu-id="3106d-472">最好是使用實際（而且在理想的指導）使用者來執行測試，因為他們可能無法使用 HoloLens 或您的應用程式，其方式與您的做法完全相同。</span><span class="sxs-lookup"><span data-stu-id="3106d-472">It is a good idea to perform testing with real (and ideally un-coached) users, because they may not use the HoloLens or your application in exactly the same way that you do.</span></span> <span data-ttu-id="3106d-473">事實上，這可能會讓您感到驚訝，人們的行為、知識和假設有多容易！</span><span class="sxs-lookup"><span data-stu-id="3106d-473">In fact, it may surprise you how divergent people's behavior, knowledge and assumptions can be!</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="3106d-474">[疑難排解]</span><span class="sxs-lookup"><span data-stu-id="3106d-474">Troubleshooting</span></span>
* <span data-ttu-id="3106d-475">為了讓 surface 網格能夠正確導向，每個 GameObject 都必須是作用中，然後才會將它傳送至 SurfaceObserver，以將其網格結構化。</span><span class="sxs-lookup"><span data-stu-id="3106d-475">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it is sent to the SurfaceObserver to have its mesh constructed.</span></span> <span data-ttu-id="3106d-476">否則，網格會顯示在您的空間中，但會以怪度旋轉。</span><span class="sxs-lookup"><span data-stu-id="3106d-476">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="3106d-477">執行與 SurfaceObserver 通訊之腳本的 GameObject 必須設定為來源。</span><span class="sxs-lookup"><span data-stu-id="3106d-477">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="3106d-478">否則，您所建立並傳送至 SurfaceObserver 的所有 Gameobject，其網格都會與父遊戲物件的位移相等。</span><span class="sxs-lookup"><span data-stu-id="3106d-478">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="3106d-479">如此一來，您的網格就會顯示數個計量，讓您很難進行檢查的狀況。</span><span class="sxs-lookup"><span data-stu-id="3106d-479">This can make your meshes show up several meters away which makes it very hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="3106d-480">請參閱</span><span class="sxs-lookup"><span data-stu-id="3106d-480">See also</span></span>
* [<span data-ttu-id="3106d-481">座標系統</span><span class="sxs-lookup"><span data-stu-id="3106d-481">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="3106d-482">DirectX 中的空間對應</span><span class="sxs-lookup"><span data-stu-id="3106d-482">Spatial mapping in DirectX</span></span>](spatial-mapping-in-directx.md)
* [<span data-ttu-id="3106d-483">Unity 中的空間對應</span><span class="sxs-lookup"><span data-stu-id="3106d-483">Spatial mapping in Unity</span></span>](spatial-mapping-in-unity.md)
* [<span data-ttu-id="3106d-484">場景理解</span><span class="sxs-lookup"><span data-stu-id="3106d-484">Scene Understanding</span></span>](scene-understanding.md)
* [<span data-ttu-id="3106d-485">空間位置掃描視覺效果</span><span class="sxs-lookup"><span data-stu-id="3106d-485">Room scan visualization</span></span>](room-scan-visualization.md)
* [<span data-ttu-id="3106d-486">空間音效設計</span><span class="sxs-lookup"><span data-stu-id="3106d-486">Spatial sound design</span></span>](spatial-sound-design.md)
* [<span data-ttu-id="3106d-487">案例研究 - 在實境中的的透視技術</span><span class="sxs-lookup"><span data-stu-id="3106d-487">Case study - Looking through holes in your reality</span></span>](case-study-looking-through-holes-in-your-reality.md)
