---
title: 空間對應
description: 空間對應提供 HoloLens 周圍環境中實際表面的詳細標記法。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間對應, HoloLens, 混合現實, 表面重建, 網格, sr
ms.openlocfilehash: 4914cf5b7864ecb2430a39af73729eb6dfc0e2bd
ms.sourcegitcommit: c4c293971bb3205a82121bbfb40d1ac52b5cb38e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/10/2019
ms.locfileid: "68937063"
---
# <a name="spatial-mapping"></a><span data-ttu-id="9202f-104">空間對應</span><span class="sxs-lookup"><span data-stu-id="9202f-104">Spatial mapping</span></span>

<span data-ttu-id="9202f-105">空間對應提供 HoloLens 環境中實際表面的詳細標記法, 讓開發人員能夠建立一項「說服混合」現實體驗。</span><span class="sxs-lookup"><span data-stu-id="9202f-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="9202f-106">藉由將真實世界與虛擬世界合併, 應用程式就可以讓全息影像看起來很真實。</span><span class="sxs-lookup"><span data-stu-id="9202f-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="9202f-107">應用程式也可以藉由提供熟悉的真實世界行為和互動, 更自然地配合使用者的期望。</span><span class="sxs-lookup"><span data-stu-id="9202f-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a><span data-ttu-id="9202f-108">裝置支援</span><span class="sxs-lookup"><span data-stu-id="9202f-108">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="9202f-109">功能</span><span class="sxs-lookup"><span data-stu-id="9202f-109">Feature</span></span></th><th style="width:150px"> <span data-ttu-id="9202f-110"><a href="hololens-hardware-details.md">HoloLens (第 1 代)</a></span><span class="sxs-lookup"><span data-stu-id="9202f-110"><a href="hololens-hardware-details.md">HoloLens (1st gen)</a></span></span></th><th style="width:150px"><span data-ttu-id="9202f-111">HoloLens 2</span><span class="sxs-lookup"><span data-stu-id="9202f-111">HoloLens 2</span></span></th><th style="width:150px"> <span data-ttu-id="9202f-112"><a href="immersive-headset-hardware-details.md">沉浸式頭戴裝置</a></span><span class="sxs-lookup"><span data-stu-id="9202f-112"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td> <span data-ttu-id="9202f-113">空間對應</span><span class="sxs-lookup"><span data-stu-id="9202f-113">Spatial mapping</span></span></td><td style="text-align: center;"> <span data-ttu-id="9202f-114">✔️</span><span class="sxs-lookup"><span data-stu-id="9202f-114">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="9202f-115">✔️</span><span class="sxs-lookup"><span data-stu-id="9202f-115">✔️</span></span></td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a><span data-ttu-id="9202f-116">概念總覽</span><span class="sxs-lookup"><span data-stu-id="9202f-116">Conceptual overview</span></span>

<span data-ttu-id="9202f-117">![涵蓋房間的網格表面](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="9202f-117">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="9202f-118">*涵蓋房間的空間對應網格範例*</span><span class="sxs-lookup"><span data-stu-id="9202f-118">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="9202f-119">用於空間對應的兩個主要物件類型是「空間介面觀察者」和「空間介面」。</span><span class="sxs-lookup"><span data-stu-id="9202f-119">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="9202f-120">應用程式會提供具有一或多個周框磁片區的空間介面觀察者, 以定義應用程式希望接收空間對應資料的空間區域。</span><span class="sxs-lookup"><span data-stu-id="9202f-120">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="9202f-121">空間對應會針對每個磁片區, 提供應用程式一組空間表面。</span><span class="sxs-lookup"><span data-stu-id="9202f-121">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="9202f-122">這些磁片區可能是固定的 (位於與真實世界相關的固定位置), 也可以附加至 HoloLens (它們會移動, 但不會旋轉, 因為 HoloLens 會在環境中移動)。</span><span class="sxs-lookup"><span data-stu-id="9202f-122">These volumes may be stationary (in a fixed location with respect to the real world) or they may be attached to the HoloLens (they move, but do not rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="9202f-123">每個空間表面都會以少量的空間來描述真實世界的表面, 以連接到世界鎖定[空間座標系統](coordinate-systems.md)的三角形網格來表示。</span><span class="sxs-lookup"><span data-stu-id="9202f-123">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="9202f-124">當 HoloLens 收集有關環境的新資料, 而且在環境發生變更時, 空間表面會出現、消失和變更。</span><span class="sxs-lookup"><span data-stu-id="9202f-124">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear and change.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="9202f-125">常見使用案例</span><span class="sxs-lookup"><span data-stu-id="9202f-125">Common usage scenarios</span></span>

![一般空間對應使用案例的圖例:位置、遮蔽、物理和流覽](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="9202f-127">放置</span><span class="sxs-lookup"><span data-stu-id="9202f-127">Placement</span></span>

<span data-ttu-id="9202f-128">空間對應讓應用程式有機會對使用者呈現自然且熟悉的互動形式;將您的電話放在桌上有何自然？</span><span class="sxs-lookup"><span data-stu-id="9202f-128">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing your phone down on the desk?</span></span>

<span data-ttu-id="9202f-129">將全息影像的位置 (或更廣泛地說, 空間位置的任何選擇) 限制為位於表面上, 可提供從 3D (點在空間) 到 2D (點在表面上) 的自然對應。</span><span class="sxs-lookup"><span data-stu-id="9202f-129">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="9202f-130">這會減少使用者必須提供給應用程式的資訊量, 因而讓使用者的互動速度更快、更簡單、更精確。</span><span class="sxs-lookup"><span data-stu-id="9202f-130">This reduces the amount of information the user needs to provide to the application and thus makes the user's interactions faster, easier and more precise.</span></span> <span data-ttu-id="9202f-131">這一點特別重要, 因為「距離遠離」並不是我們用來實際與其他人或電腦進行通訊的東西。</span><span class="sxs-lookup"><span data-stu-id="9202f-131">This is particularly true because 'distance away' is not something that we are used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="9202f-132">當我們指向手指時, 就是指定方向, 而不是距離。</span><span class="sxs-lookup"><span data-stu-id="9202f-132">When we point with our finger, we are specifying a direction but not a distance.</span></span>

<span data-ttu-id="9202f-133">這裡要注意的一點是, 當應用程式從方向推斷距離時 (例如, 沿著使用者的注視方向執行 raycast 以尋找最近的空間表面), 這必須產生使用者能夠可靠地進行預測的結果。</span><span class="sxs-lookup"><span data-stu-id="9202f-133">An important caveat here is that when an application infers distance from direction (for example by performing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user is able to reliably predict.</span></span> <span data-ttu-id="9202f-134">否則, 使用者將喪失控制項的意義, 而這可能很快就會變得令人沮喪。</span><span class="sxs-lookup"><span data-stu-id="9202f-134">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="9202f-135">有一種方法可協助您執行多個 raycasts, 而不只是一個。</span><span class="sxs-lookup"><span data-stu-id="9202f-135">One method that helps with this is to perform multiple raycasts instead of just one.</span></span> <span data-ttu-id="9202f-136">匯總結果應該更平滑且更可預測, 較不容易受到暫時性「極端」結果的影響 (可能是因為光線通過小型洞, 或遇到使用者不知道的小型幾何)。</span><span class="sxs-lookup"><span data-stu-id="9202f-136">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user is not aware of).</span></span> <span data-ttu-id="9202f-137">您也可以在一段時間內執行匯總或平滑處理;例如, 您可以限制全息的最大速度, 與使用者之間的距離可能有所不同。</span><span class="sxs-lookup"><span data-stu-id="9202f-137">Aggregation or smoothing can also be performed over time; for example you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="9202f-138">只是限制 [最小值] 和 [最大距離] 值也可以提供協助, 因此移動的全息影像不會突然進入距離或損毀到使用者的臉部。</span><span class="sxs-lookup"><span data-stu-id="9202f-138">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved does not suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="9202f-139">應用程式也可以使用表面的形狀和方向來引導全息影像位置。</span><span class="sxs-lookup"><span data-stu-id="9202f-139">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="9202f-140">全像攝影的椅子不應穿透牆, 而且應該與樓層齊平, 即使它有點不平均。</span><span class="sxs-lookup"><span data-stu-id="9202f-140">A holographic chair should not penetrate through walls and should sit flush with the floor even if it is slightly uneven.</span></span> <span data-ttu-id="9202f-141">這類功能可能會依賴物理衝突, 而不只是 raycasts, 但也會套用類似的問題。</span><span class="sxs-lookup"><span data-stu-id="9202f-141">This kind of functionality would likely rely upon the use of physics collisions rather than just raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="9202f-142">如果要放置的全像投影片上有許多很小的多邊形, 像是椅子上的腿, 則將這些多邊形的物理表示擴充為更寬且更平滑的東西, 讓它們能夠更輕鬆地滑出空間表面, 而不需要畫面.</span><span class="sxs-lookup"><span data-stu-id="9202f-142">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they are more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="9202f-143">在極端的情況下, 使用者輸入可以完全簡化, 而空間表面則可以用來執行完全自動的全像投影位置。</span><span class="sxs-lookup"><span data-stu-id="9202f-143">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to perform entirely automatic hologram placement.</span></span> <span data-ttu-id="9202f-144">例如, 應用程式可能會在牆上的某處放置全像攝影燈, 讓使用者按下。</span><span class="sxs-lookup"><span data-stu-id="9202f-144">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="9202f-145">關於可預測性的相同注意事項適用于這裡:如果使用者希望能夠控制全像投影位置, 但應用程式不一定會在其預期的地方放入全息影像 (如果燈出現在使用者無法觸達的地方), 這會是令人沮喪的體驗。</span><span class="sxs-lookup"><span data-stu-id="9202f-145">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application does not always place holograms where they expect (if the light-switch appears somewhere that the user cannot reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="9202f-146">實際上, 執行需要使用者更正的自動放置可能會更糟, 而不只是要求使用者一律自行執行放置;因為*預期*會自動放置成功, 所以手動更正會感覺像是一種負擔!</span><span class="sxs-lookup"><span data-stu-id="9202f-146">It can actually be worse to perform automatic placement that requires user correction some of the time, than to just require the user to always perform placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="9202f-147">另請注意, 應用程式使用空間介面進行放置的能力, 主要取決於應用程式的[掃描經驗](spatial-mapping-design.md#the-environment-scanning-experience)。</span><span class="sxs-lookup"><span data-stu-id="9202f-147">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="9202f-148">如果表面尚未掃描, 則無法用於放置。</span><span class="sxs-lookup"><span data-stu-id="9202f-148">If a surface has not been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="9202f-149">應用程式會自行決定是否要讓使用者清楚清除, 讓他們可以協助掃描新的表面或選取新的位置。</span><span class="sxs-lookup"><span data-stu-id="9202f-149">It is up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="9202f-150">在放置過程中, 對使用者的視覺效果回饋十分重要。</span><span class="sxs-lookup"><span data-stu-id="9202f-150">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="9202f-151">使用者必須知道全息與[接地效果](spatial-mapping.md#visualization)最接近的表面。</span><span class="sxs-lookup"><span data-stu-id="9202f-151">The user needs to know where the hologram is in relation to the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="9202f-152">他們應該瞭解為什麼會限制其全息影像的移動 (例如, 因為與另一個附近的表面發生衝突)。</span><span class="sxs-lookup"><span data-stu-id="9202f-152">They should understand why the movement of their hologram is being constrained (for example, due to collision with another nearby surface).</span></span> <span data-ttu-id="9202f-153">如果他們無法將全息圖形放在目前的位置, 則視覺效果的意見反應應該清楚說明為什麼不這麼做。</span><span class="sxs-lookup"><span data-stu-id="9202f-153">If they cannot place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="9202f-154">例如, 如果使用者嘗試將全像攝影的沙發放在牆中, 那麼牆後方的沙發部分應該會以生氣的色彩 pulsate。</span><span class="sxs-lookup"><span data-stu-id="9202f-154">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="9202f-155">相反地, 如果應用程式在使用者可以看到實際表面的位置找不到空間介面, 則應用程式應該讓這一點清楚。</span><span class="sxs-lookup"><span data-stu-id="9202f-155">Or conversely, if the application cannot find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="9202f-156">在此區域中, 明顯不會產生接地效果, 可能會達成此目的。</span><span class="sxs-lookup"><span data-stu-id="9202f-156">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="9202f-157">遮蔽</span><span class="sxs-lookup"><span data-stu-id="9202f-157">Occlusion</span></span>

<span data-ttu-id="9202f-158">空間對應介面的主要用途之一, 就是遮蔽的全息影像。</span><span class="sxs-lookup"><span data-stu-id="9202f-158">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="9202f-159">這種簡單的行為會對觀察到的全息影像真實性產生巨大的影響, 協助建立真正占與使用者相同之實體空間的 visceral 意義。</span><span class="sxs-lookup"><span data-stu-id="9202f-159">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabit the same physical space as the user.</span></span>

<span data-ttu-id="9202f-160">遮蔽也會提供資訊給使用者;當全像投影表面 pixels occluded 時, 這會提供其他視覺效果意見反應給世界上該全息圖形的空間位置。</span><span class="sxs-lookup"><span data-stu-id="9202f-160">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides additional visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="9202f-161">相反地, 遮蔽也可以常見*隱藏*使用者的資訊;occluding 牆後方的全息影像可以直覺地減少視覺雜亂的情形。</span><span class="sxs-lookup"><span data-stu-id="9202f-161">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="9202f-162">若要隱藏或顯示全息影像, 使用者只需要移動其標題。</span><span class="sxs-lookup"><span data-stu-id="9202f-162">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="9202f-163">遮蔽也可用來根據熟悉的實體互動, 將自然使用者介面的期望如果某個表面 pixels occluded 了全息影像, 這是因為該表面是實心的, 因此使用者應該預期全息影像會與該介面發生*衝突*, 而不只是通過它。</span><span class="sxs-lookup"><span data-stu-id="9202f-163">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not simply pass through it.</span></span>

<span data-ttu-id="9202f-164">有時候不需要遮蔽的全息影像。</span><span class="sxs-lookup"><span data-stu-id="9202f-164">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="9202f-165">如果使用者需要能夠與全像投影互動, 則他們必須能夠看到它, 即使是在實際表面後面也一樣。</span><span class="sxs-lookup"><span data-stu-id="9202f-165">If a user needs to be able to interact with a hologram, then they need to be able to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="9202f-166">在這種情況下, 在 pixels occluded (例如, 藉由減少其亮度) 時, 呈現這類全息影像通常是合理的。</span><span class="sxs-lookup"><span data-stu-id="9202f-166">In such cases, it usually makes sense to render such a hologram differently when it is occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="9202f-167">如此一來, 使用者將能夠以視覺化方式找出全像投影, 但是仍會察覺到它的背後。</span><span class="sxs-lookup"><span data-stu-id="9202f-167">This way, the user will be able to visually locate the hologram, but they will still be aware that it is behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="9202f-168">物理</span><span class="sxs-lookup"><span data-stu-id="9202f-168">Physics</span></span>

<span data-ttu-id="9202f-169">使用物理模擬的另一種方式, 是使用空間對應來強化使用者實體空間中的全息*顯示*。</span><span class="sxs-lookup"><span data-stu-id="9202f-169">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="9202f-170">當我的全像說, 我的全像是從桌上折得, 然後在沙發下彈跳並消失時, 我可能很難相信這不是真正的。</span><span class="sxs-lookup"><span data-stu-id="9202f-170">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not really there.</span></span>

<span data-ttu-id="9202f-171">物理模擬也讓應用程式有機會使用自然且熟悉的物理互動。</span><span class="sxs-lookup"><span data-stu-id="9202f-171">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="9202f-172">如果傢俱以適當的慣性和摩擦在地面之間滑動, 則移動地面上的全像攝影傢俱可能會更容易。</span><span class="sxs-lookup"><span data-stu-id="9202f-172">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="9202f-173">為了產生實際的實體行為, 您可能需要執行一些[網格處理](spatial-mapping.md#mesh-processing), 例如填滿孔、移除浮動 hallucinations 和平滑表面。</span><span class="sxs-lookup"><span data-stu-id="9202f-173">In order to generate realistic physical behaviors, you will likely need to perform some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="9202f-174">您也必須考慮應用程式的[掃描體驗](spatial-mapping-design.md#the-environment-scanning-experience)會如何影響其物理模擬。</span><span class="sxs-lookup"><span data-stu-id="9202f-174">You will also need to consider how your application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="9202f-175">首先, 遺漏的表面不會與任何專案衝突;當橡膠球在 corridor 和已知世界結束時, 會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="9202f-175">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="9202f-176">其次, 您必須決定是否要在一段時間後繼續回應環境中的變更。</span><span class="sxs-lookup"><span data-stu-id="9202f-176">Secondly, you need to decide whether you will continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="9202f-177">在某些情況下, 您會想要儘快回應;比方說, 如果使用者使用門和傢俱作為 tempest 的內送羅馬箭號的 barricades。</span><span class="sxs-lookup"><span data-stu-id="9202f-177">In some cases, you will want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="9202f-178">但在其他情況下, 您可能會想要忽略新的更新;如果您的狗決定坐在一軌的中間, 讓您的全像 racetrack 在地面上推動全像運動車, 可能會突然不那麼有趣。</span><span class="sxs-lookup"><span data-stu-id="9202f-178">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="9202f-179">巡覽</span><span class="sxs-lookup"><span data-stu-id="9202f-179">Navigation</span></span>

<span data-ttu-id="9202f-180">應用程式可以使用空間對應資料來授與全像攝影的字元 (或代理程式) 能夠以真實人員的相同方式來流覽真實世界。</span><span class="sxs-lookup"><span data-stu-id="9202f-180">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="9202f-181">這有助於加強全像攝影字元的存在, 方法是將它們限制為與使用者及其朋友的同一組自然、熟悉的行為。</span><span class="sxs-lookup"><span data-stu-id="9202f-181">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="9202f-182">流覽功能對使用者也很有用。</span><span class="sxs-lookup"><span data-stu-id="9202f-182">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="9202f-183">在特定區域內建導覽地圖之後, 您就可以共用它, 為不熟悉該位置的新使用者提供全像攝影方向。</span><span class="sxs-lookup"><span data-stu-id="9202f-183">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="9202f-184">這個對應可以設計來協助讓地下的「流量」順暢地流動, 或避免在危險位置 (例如結構網站) 中發生意外的情況。</span><span class="sxs-lookup"><span data-stu-id="9202f-184">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="9202f-185">執行導覽功能時所牽涉到的重要技術挑戰, 將會可靠地偵測 walkable 介面 (人類不會引導資料表!), 並對環境中的變更進行適當的調整 (人類不會逐步解說)。</span><span class="sxs-lookup"><span data-stu-id="9202f-185">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="9202f-186">網格可能需要先進行一些[處理](spatial-mapping.md#mesh-processing), 才能用於路徑規劃和導覽 (透過虛擬字元)。</span><span class="sxs-lookup"><span data-stu-id="9202f-186">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it is usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="9202f-187">將網格平滑化和移除 hallucinations, 可協助避免字元變得停滯。</span><span class="sxs-lookup"><span data-stu-id="9202f-187">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="9202f-188">您也可能想要大幅簡化網格, 以便加速字元的路徑規劃和導覽計算。</span><span class="sxs-lookup"><span data-stu-id="9202f-188">You may also wish to drastically simplify the mesh in order to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="9202f-189">這些挑戰在開發 videogame 技術方面已經有很大的注意, 而且這些主題提供了豐富的研究文獻。</span><span class="sxs-lookup"><span data-stu-id="9202f-189">These challenges have received a great deal of attention in the development of videogame technology, and there is a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="9202f-190">請注意, Unity 中的內建 NavMesh 功能無法與空間對應介面搭配使用。</span><span class="sxs-lookup"><span data-stu-id="9202f-190">Note that the built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="9202f-191">這是因為在應用程式啟動之前, 空間對應介面不是已知的, 而 NavMesh 資料檔案必須事先從來源資產產生。</span><span class="sxs-lookup"><span data-stu-id="9202f-191">This is because spatial mapping surfaces are not known until the application starts, whereas NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="9202f-192">另請注意, 空間對應系統不會提供與使用者目前位置[非常遠之表面的相關資訊](spatial-mapping-design.md#the-environment-scanning-experience)。</span><span class="sxs-lookup"><span data-stu-id="9202f-192">Also note that, the spatial mapping system will not provide [information about surfaces very far away](spatial-mapping-design.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="9202f-193">因此, 如果應用程式要建立非常大區域的對應, 就必須「記住」自己的表面。</span><span class="sxs-lookup"><span data-stu-id="9202f-193">So the application must 'remember' surfaces itself if it is to build a map of a very large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="9202f-194">化</span><span class="sxs-lookup"><span data-stu-id="9202f-194">Visualization</span></span>

<span data-ttu-id="9202f-195">大部分時間都適用于空間表面不可見;以最小化視覺效果, 並讓真實世界自行溝通。</span><span class="sxs-lookup"><span data-stu-id="9202f-195">Most of the time it is appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="9202f-196">不過, 有時候直接將空間對應介面視覺化會很有用, 儘管實際的對應專案已經看得見。</span><span class="sxs-lookup"><span data-stu-id="9202f-196">However, sometimes it is useful to visualize spatial mapping surfaces directly, despite the fact that their real-world counterparts are already visible.</span></span>

<span data-ttu-id="9202f-197">例如, 當使用者嘗試將全息影像放在表面上 (比方說, 在牆上放置全像攝影的機櫃) 時, 將陰影轉型為介面, 就可以「地面」。</span><span class="sxs-lookup"><span data-stu-id="9202f-197">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="9202f-198">如此一來, 使用者就能更清楚地瞭解全息影像與表面之間的確切實體鄰近性。</span><span class="sxs-lookup"><span data-stu-id="9202f-198">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="9202f-199">這也是在使用者認可之前, 以視覺化方式「預覽」變更的一般作法範例。</span><span class="sxs-lookup"><span data-stu-id="9202f-199">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="9202f-200">藉由視覺化表面, 應用程式可以與使用者對環境的瞭解進行共用。</span><span class="sxs-lookup"><span data-stu-id="9202f-200">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="9202f-201">例如, 「全像攝影面板」遊戲可以將其識別為「資料表」的水準表面視覺化, 讓使用者知道他們應該前往何處互動。</span><span class="sxs-lookup"><span data-stu-id="9202f-201">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="9202f-202">視覺化表面是一個很實用的方式, 可顯示隱藏于 view 之外的使用者附近空白。</span><span class="sxs-lookup"><span data-stu-id="9202f-202">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="9202f-203">這可能會提供簡單的方法, 讓使用者從他們的聊天室存取廚房 (以及所有內含的全息影像)。</span><span class="sxs-lookup"><span data-stu-id="9202f-203">This could provide a simple way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="9202f-204">空間對應所提供的表面網格可能不會特別「清除」。</span><span class="sxs-lookup"><span data-stu-id="9202f-204">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="9202f-205">因此, 請務必適當地將它們視覺化。</span><span class="sxs-lookup"><span data-stu-id="9202f-205">Thus it is important to visualize them appropriately.</span></span> <span data-ttu-id="9202f-206">傳統光源計算可能會以視覺上分散的方式反白顯示介面法線中的錯誤, 而投影到表面的「清除」紋理可能有助於提供整齊的外觀。</span><span class="sxs-lookup"><span data-stu-id="9202f-206">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, whilst 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="9202f-207">在呈現表面之前, 也可以執行[網格處理](spatial-mapping.md#mesh-processing)來改善網格屬性。</span><span class="sxs-lookup"><span data-stu-id="9202f-207">It is also possible to perform [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="9202f-208">使用 Surface 觀察者</span><span class="sxs-lookup"><span data-stu-id="9202f-208">Using The Surface Observer</span></span>

<span data-ttu-id="9202f-209">空間對應的起點是「表面觀察者」。</span><span class="sxs-lookup"><span data-stu-id="9202f-209">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="9202f-210">程式流程如下所示:</span><span class="sxs-lookup"><span data-stu-id="9202f-210">Program flow is as follows:</span></span>
* <span data-ttu-id="9202f-211">建立 surface observer 物件</span><span class="sxs-lookup"><span data-stu-id="9202f-211">Create a surface observer object</span></span>
   * <span data-ttu-id="9202f-212">提供一或多個空間磁片區, 以定義應用程式希望接收空間對應資料的相關區域。</span><span class="sxs-lookup"><span data-stu-id="9202f-212">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="9202f-213">空間磁片區只是定義空間區域 (例如球體或方塊) 的圖形。</span><span class="sxs-lookup"><span data-stu-id="9202f-213">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="9202f-214">使用具有全球鎖定空間座標系統的空間磁片區, 以識別實體世界的固定區域。</span><span class="sxs-lookup"><span data-stu-id="9202f-214">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="9202f-215">使用空間磁片區, 以主體鎖定的空間座標系統更新每個框架, 以識別與使用者移動 (但不會旋轉) 的空間區域。</span><span class="sxs-lookup"><span data-stu-id="9202f-215">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but does not rotate) with the user.</span></span>
   * <span data-ttu-id="9202f-216">當應用程式或使用者的狀態變更時, 這些空間磁片區可能會在稍後變更。</span><span class="sxs-lookup"><span data-stu-id="9202f-216">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="9202f-217">使用輪詢或通知來抓取空間表面的相關資訊</span><span class="sxs-lookup"><span data-stu-id="9202f-217">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="9202f-218">您可以隨時「輪詢」「介面觀察器」的空間表面狀態。</span><span class="sxs-lookup"><span data-stu-id="9202f-218">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="9202f-219">或者, 您可以註冊 surface 觀察者的「表面已變更」事件, 這會在空間表面變更時通知應用程式。</span><span class="sxs-lookup"><span data-stu-id="9202f-219">Alternatively, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="9202f-220">對於動態空間磁片區 (例如, 視圖截維或主體鎖定的卷), 應用程式必須藉由設定感關注的區域, 然後取得目前的空間表面集合, 來輪詢每個畫面格的變更。</span><span class="sxs-lookup"><span data-stu-id="9202f-220">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="9202f-221">對於靜態磁片區 (例如涵蓋單一房間的全球鎖定 cube), 應用程式可能會註冊「介面已變更」事件, 以在該磁片區中的空間表面可能已變更時收到通知。</span><span class="sxs-lookup"><span data-stu-id="9202f-221">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="9202f-222">進程表面變更</span><span class="sxs-lookup"><span data-stu-id="9202f-222">Process surfaces changes</span></span>
   * <span data-ttu-id="9202f-223">逐一查看提供的空間表面集合。</span><span class="sxs-lookup"><span data-stu-id="9202f-223">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="9202f-224">將空間表面分類為已加入、已變更或已移除。</span><span class="sxs-lookup"><span data-stu-id="9202f-224">Classify spatial surfaces as added, changed or removed.</span></span>
   * <span data-ttu-id="9202f-225">針對每個新增或變更的空間介面, 如果適當地提交非同步要求以接收更新的網格, 表示介面在所需的詳細資料層級上的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="9202f-225">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="9202f-226">處理非同步網狀要求 (下列各節中有更多詳細資料)。</span><span class="sxs-lookup"><span data-stu-id="9202f-226">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="9202f-227">網格快取</span><span class="sxs-lookup"><span data-stu-id="9202f-227">Mesh Caching</span></span>

<span data-ttu-id="9202f-228">空間表面是以密集三角形網格來表示。</span><span class="sxs-lookup"><span data-stu-id="9202f-228">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="9202f-229">儲存、轉譯和處理這些網格可能會耗用大量的計算和儲存資源。</span><span class="sxs-lookup"><span data-stu-id="9202f-229">Storing, rendering and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="9202f-230">因此, 每個應用程式都應該採用適合其需求的網格快取配置, 以便將用於網格處理和儲存的資源降至最低。</span><span class="sxs-lookup"><span data-stu-id="9202f-230">As such, each application should adopt a mesh caching scheme appropriate to its needs, in order to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="9202f-231">此配置應該會決定要保留哪些網格以及要捨棄哪些, 以及何時要更新每個空間介面的網格。</span><span class="sxs-lookup"><span data-stu-id="9202f-231">This scheme should determine which meshes to retain and which to discard, as well as when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="9202f-232">這裡討論的許多考慮都會直接通知應用程式應該如何處理網格快取。</span><span class="sxs-lookup"><span data-stu-id="9202f-232">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="9202f-233">您應該考慮到使用者如何在環境中移動、觀察到不同的表面, 以及何時應該捕捉環境中的變更。</span><span class="sxs-lookup"><span data-stu-id="9202f-233">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="9202f-234">當您解讀 surface 觀察者所提供的「表面已變更」事件時, 基本網格快取邏輯如下所示:</span><span class="sxs-lookup"><span data-stu-id="9202f-234">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="9202f-235">如果應用程式看到先前尚未看到的空間表面識別碼, 則應該將它視為新的空間介面。</span><span class="sxs-lookup"><span data-stu-id="9202f-235">If the application sees a spatial surface ID that it has not seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="9202f-236">如果應用程式看到具有已知識別碼的空間介面, 但具有新的更新時間, 則應該將此視為已更新的空間介面。</span><span class="sxs-lookup"><span data-stu-id="9202f-236">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="9202f-237">如果應用程式不再看到具有已知識別碼的空間介面, 則應該將它視為已移除的空間介面。</span><span class="sxs-lookup"><span data-stu-id="9202f-237">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="9202f-238">而是由每個應用程式決定, 然後進行下列選擇:</span><span class="sxs-lookup"><span data-stu-id="9202f-238">It is up to each application to then make the following choices:</span></span>
* <span data-ttu-id="9202f-239">針對新的空間表面, 應該會要求網格嗎？</span><span class="sxs-lookup"><span data-stu-id="9202f-239">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="9202f-240">通常應該立即針對新的空間表面要求網格, 這可能會對使用者提供有用的新資訊。</span><span class="sxs-lookup"><span data-stu-id="9202f-240">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="9202f-241">不過, 在使用者附近和前方的新空間表面應具有優先順序, 而且應該先要求其網格。</span><span class="sxs-lookup"><span data-stu-id="9202f-241">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="9202f-242">如果不需要新的網格, 例如應用程式已永久或暫時「凍結」其環境模型, 則不應要求。</span><span class="sxs-lookup"><span data-stu-id="9202f-242">If the new mesh is not needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it should not be requested.</span></span>
* <span data-ttu-id="9202f-243">針對已更新的空間表面, 應要求網格嗎？</span><span class="sxs-lookup"><span data-stu-id="9202f-243">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="9202f-244">已更新使用者附近和前方的空間表面, 應優先取得, 而且應該先要求其網格。</span><span class="sxs-lookup"><span data-stu-id="9202f-244">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="9202f-245">您也可以在新表面上給予較高的優先順序, 而不是更新的表面, 特別是在掃描體驗期間。</span><span class="sxs-lookup"><span data-stu-id="9202f-245">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="9202f-246">為了限制處理成本, 應用程式可能想要節流處理更新至空間表面的速率。</span><span class="sxs-lookup"><span data-stu-id="9202f-246">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="9202f-247">您可以推斷空間介面的變更是次要的, 例如, 如果表面的界限很小, 在此情況下, 更新可能不夠重要而無法處理。</span><span class="sxs-lookup"><span data-stu-id="9202f-247">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="9202f-248">在使用者感興趣的目前區域外的空間表面更新可能會完全忽略, 不過在此情況下, 修改 surface 觀察者使用的空間界限磁片區可能會更有效率。</span><span class="sxs-lookup"><span data-stu-id="9202f-248">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="9202f-249">針對已移除的空間表面, 是否應該捨棄網格？</span><span class="sxs-lookup"><span data-stu-id="9202f-249">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="9202f-250">通常應該針對已移除的空間表面立即捨棄網格, 讓全息影像遮蔽保持正確。</span><span class="sxs-lookup"><span data-stu-id="9202f-250">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="9202f-251">不過, 如果應用程式有理由相信空間介面很快就會重新出現 (也許是根據使用者經驗的設計), 那麼保留它比捨棄網格並稍後重新建立, 可能會更有效率。</span><span class="sxs-lookup"><span data-stu-id="9202f-251">However, if the application has reason to believe that a spatial surface will reappear shortly (perhaps based upon the design of the user experience), then it may be more efficient to retain it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="9202f-252">如果應用程式正在建立使用者環境的大規模模型, 則可能不想要捨棄任何網格。</span><span class="sxs-lookup"><span data-stu-id="9202f-252">If the application is building a large-scale model of the user's environment then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="9202f-253">不過, 它仍然需要限制資源使用量, 可能是因為空間表面消失, 而將網格緩衝處理到磁片上。</span><span class="sxs-lookup"><span data-stu-id="9202f-253">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="9202f-254">請注意, 在空間介面產生期間, 某些較罕見的事件可能會導致空間表面被類似位置中的新空間表面取代, 但使用不同的識別碼。</span><span class="sxs-lookup"><span data-stu-id="9202f-254">Note that some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="9202f-255">因此, 選擇不捨棄已移除表面的應用程式, 應該不會注意到涵蓋相同位置的多個高度重迭空間介面網格。</span><span class="sxs-lookup"><span data-stu-id="9202f-255">Consequently, applications that choose not to discard a removed surface should take care not to end up with multiple highly-overlapped spatial surface meshes covering the same location.</span></span>
* <span data-ttu-id="9202f-256">是否應該針對其他任何空間表面捨棄網格？</span><span class="sxs-lookup"><span data-stu-id="9202f-256">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="9202f-257">即使空間表面存在, 如果它不再適用于使用者的經驗, 則應該將其捨棄。</span><span class="sxs-lookup"><span data-stu-id="9202f-257">Even while a spatial surface exists, if it is no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="9202f-258">例如, 如果應用程式「取代」門口另一端的房間, 還有替代虛擬空間, 那麼該房間內的空間表面就不再重要。</span><span class="sxs-lookup"><span data-stu-id="9202f-258">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="9202f-259">以下是使用空間和時態性遲滯的範例網格快取策略:</span><span class="sxs-lookup"><span data-stu-id="9202f-259">Here is an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="9202f-260">假設有一個應用程式想要在使用者看起來前後, 使用類似的錐狀空間量,</span><span class="sxs-lookup"><span data-stu-id="9202f-260">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="9202f-261">空間表面可能會暫時消失于此磁片區, 這是因為使用者看起來遠離表面或從其外部的步驟 ... 請稍後再回頭查看或移動更接近的時間。</span><span class="sxs-lookup"><span data-stu-id="9202f-261">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="9202f-262">在此情況下, 捨棄並重新建立此介面的網格代表許多多餘的處理。</span><span class="sxs-lookup"><span data-stu-id="9202f-262">In this case, discarding and re-creating the mesh for this surface represents a lot of redundant processing.</span></span>
* <span data-ttu-id="9202f-263">為了減少已處理的變更數目, 應用程式會使用兩個空間表面觀察器, 其中一個會包含在另一個範圍內。</span><span class="sxs-lookup"><span data-stu-id="9202f-263">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="9202f-264">較大的磁片區是球形, 並遵循使用者的「延遲」;只有在必要時才會移動, 以確保其中心位於使用者的 2.0 metres 內。</span><span class="sxs-lookup"><span data-stu-id="9202f-264">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its centre is within 2.0 metres of the user.</span></span>
* <span data-ttu-id="9202f-265">新的和更新的空間表面網格一律會從較小的內部介面觀察器進行處理, 但是網格會快取, 直到它們從較大的外部表面觀察器消失為止。</span><span class="sxs-lookup"><span data-stu-id="9202f-265">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="9202f-266">這可讓應用程式避免因本機使用者移動而處理許多多餘的變更。</span><span class="sxs-lookup"><span data-stu-id="9202f-266">This allows the application to avoid processing many redundant changes due to local user movement.</span></span>
* <span data-ttu-id="9202f-267">由於空間表面可能也會因為追蹤遺失而暫時消失, 因此應用程式也會在追蹤遺失期間, 延遲捨棄已移除的空間表面。</span><span class="sxs-lookup"><span data-stu-id="9202f-267">Since a spatial surface may also disappear temporarily due to tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="9202f-268">一般而言, 應用程式應該評估減少更新處理和增加記憶體使用量之間的取捨, 以判斷其理想的快取策略。</span><span class="sxs-lookup"><span data-stu-id="9202f-268">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="9202f-269">轉譯</span><span class="sxs-lookup"><span data-stu-id="9202f-269">Rendering</span></span>

<span data-ttu-id="9202f-270">空間對應網格通常用於轉譯的主要方式有三種:</span><span class="sxs-lookup"><span data-stu-id="9202f-270">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="9202f-271">針對表面視覺效果</span><span class="sxs-lookup"><span data-stu-id="9202f-271">For surface visualization</span></span>
   * <span data-ttu-id="9202f-272">直接將空間表面視覺化通常會很有用。</span><span class="sxs-lookup"><span data-stu-id="9202f-272">It is often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="9202f-273">例如, 將「陰影」從物件轉換成空間表面, 可以在使用者將全息影像放在表面上時, 為他們提供有用的視覺回饋。</span><span class="sxs-lookup"><span data-stu-id="9202f-273">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they are placing holograms on surfaces.</span></span>
   * <span data-ttu-id="9202f-274">有一點要注意的是, 空間網格與3D 演出者可能建立的網格類型不同。</span><span class="sxs-lookup"><span data-stu-id="9202f-274">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="9202f-275">三角形拓撲不會像人類建立的拓撲一樣「清除」, 而且網格會受到[各種錯誤](spatial-mapping-design.md#what-influences-spatial-mapping-quality)的影響。</span><span class="sxs-lookup"><span data-stu-id="9202f-275">The triangle topology will not be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping-design.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="9202f-276">為了建立令人滿意的視覺效果美觀, 您可能會想要執行一些[網格處理](spatial-mapping.md#mesh-processing), 例如填滿洞或平滑表面法線。</span><span class="sxs-lookup"><span data-stu-id="9202f-276">In order to create a pleasing visual aesthetic, you may thus want to perform some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="9202f-277">您也可能想要使用著色器, 將演出者設計的材質投影到網格上, 而不是直接視覺化網格拓朴和法線。</span><span class="sxs-lookup"><span data-stu-id="9202f-277">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="9202f-278">適用于真實世界表面的 occluding 全息影像</span><span class="sxs-lookup"><span data-stu-id="9202f-278">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="9202f-279">空間表面可以在僅影響[深度緩衝區](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)且不會影響色彩呈現目標的深度傳遞中轉譯。</span><span class="sxs-lookup"><span data-stu-id="9202f-279">Spatial surfaces can be rendered in a depth-only pass which only affects the [depth buffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) and does not affect color render targets.</span></span>
   * <span data-ttu-id="9202f-280">這會質數深度緩衝區, 以遮蔽後續呈現的空間表面後置影像。</span><span class="sxs-lookup"><span data-stu-id="9202f-280">This primes the depth buffer to occlude subsequently-rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="9202f-281">準確遮蔽的全息影像可增強全息影像真正存在於使用者的實體空間中的意義。</span><span class="sxs-lookup"><span data-stu-id="9202f-281">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="9202f-282">若要啟用僅深度轉譯, 請更新 blend 狀態, 將所有色彩呈現目標的[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)設定為零。</span><span class="sxs-lookup"><span data-stu-id="9202f-282">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) to zero for all color render targets.</span></span>
* <span data-ttu-id="9202f-283">修改真實世界表面所 pixels occluded 的全息影像外觀</span><span class="sxs-lookup"><span data-stu-id="9202f-283">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="9202f-284">在 pixels occluded 時, 通常會隱藏呈現的幾何。</span><span class="sxs-lookup"><span data-stu-id="9202f-284">Normally rendered geometry is hidden when it is occluded.</span></span> <span data-ttu-id="9202f-285">這是藉由將[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中的深度函式設定為「小於或等於」來達成, 這會使幾何只有在**靠近**相機的位置才可見, 而不是所有先前呈現的幾何。</span><span class="sxs-lookup"><span data-stu-id="9202f-285">This is achieved by setting the depth function in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) to "less than or equal", which causes geometry to be visible only where it is **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="9202f-286">不過, 即使在 pixels occluded 時仍然可以看到某些幾何, 並在 pixels occluded 為對使用者提供視覺化回應的方式時修改其外觀, 可能會有説明。</span><span class="sxs-lookup"><span data-stu-id="9202f-286">However, it may be useful to keep certain geometry visible even when it is occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="9202f-287">例如, 這可讓應用程式向使用者顯示物件的位置, 同時讓它清楚呈現在真實世界的表面上。</span><span class="sxs-lookup"><span data-stu-id="9202f-287">For example, this allows the application to show the user the location of an object whilst making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="9202f-288">若要達到此目的, 請使用不同的著色器第二次轉譯幾何, 以建立所需的 ' pixels occluded ' 外觀。</span><span class="sxs-lookup"><span data-stu-id="9202f-288">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="9202f-289">第二次呈現幾何之前, 請對[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)進行兩個變更。</span><span class="sxs-lookup"><span data-stu-id="9202f-289">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="9202f-290">首先, 將深度函式設定為「大於或等於」, 如此一來, 只有在與所有先前呈現的幾何相比, 才會看到幾何的位置。</span><span class="sxs-lookup"><span data-stu-id="9202f-290">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it is **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="9202f-291">第二, 將 DepthWriteMask 設定為零, 如此就不會修改深度緩衝區 (深度緩衝區應該會繼續代表**最接近**相機的幾何深度)。</span><span class="sxs-lookup"><span data-stu-id="9202f-291">Second, set the DepthWriteMask to zero, so that the depth buffer will not be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="9202f-292">在轉譯空間對應網格時,[效能](understanding-performance-for-mixed-reality.md)是很重要的考慮。</span><span class="sxs-lookup"><span data-stu-id="9202f-292">[Performance](understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="9202f-293">以下是呈現空間對應網格特有的一些轉譯效能技術:</span><span class="sxs-lookup"><span data-stu-id="9202f-293">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="9202f-294">調整三角形密度</span><span class="sxs-lookup"><span data-stu-id="9202f-294">Adjust triangle density</span></span>
   * <span data-ttu-id="9202f-295">當您從 surface 觀察者要求空間表面網格時, 請要求可滿足您需求的最小三角形網格密度。</span><span class="sxs-lookup"><span data-stu-id="9202f-295">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="9202f-296">根據表面與使用者的距離, 以及其與使用者體驗的相關性, 可能會有意義地改變表面上的三角形密度。</span><span class="sxs-lookup"><span data-stu-id="9202f-296">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="9202f-297">減少三角形計數可減少 GPU 上的記憶體使用量和頂點處理成本, 但不會影響圖元處理成本。</span><span class="sxs-lookup"><span data-stu-id="9202f-297">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it will not affect pixel processing costs.</span></span>
* <span data-ttu-id="9202f-298">執行截錐剔除</span><span class="sxs-lookup"><span data-stu-id="9202f-298">Perform frustum culling</span></span>
   * <span data-ttu-id="9202f-299">「截錐」剔除會略過無法看到的繪圖物件, 因為它們不在目前的顯示為「截錐」。</span><span class="sxs-lookup"><span data-stu-id="9202f-299">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="9202f-300">這可降低 CPU 和 GPU 處理成本。</span><span class="sxs-lookup"><span data-stu-id="9202f-300">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="9202f-301">由於會針對每個網格來執行剔除, 而空間表面可能會很大, 因此, 將每個空間表面網格細分成較小的區塊, 可能會導致更有效率的剔除 (會轉譯較少的螢幕三角形)。</span><span class="sxs-lookup"><span data-stu-id="9202f-301">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="9202f-302">不過, 有一種取捨,您擁有的網格越多, 您必須進行的繪製呼叫越多, 這可能會增加 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="9202f-302">There is a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="9202f-303">在極端的情況下, 截量的剔除計算本身甚至可以有可測量的 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="9202f-303">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="9202f-304">調整轉譯順序</span><span class="sxs-lookup"><span data-stu-id="9202f-304">Adjust rendering order</span></span>
   * <span data-ttu-id="9202f-305">空間表面通常會很大, 因為它們代表使用者周圍的整個環境。</span><span class="sxs-lookup"><span data-stu-id="9202f-305">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="9202f-306">GPU 上的圖元處理成本可能會很高, 特別是在有多個可見幾何層級的情況下 (包括空間表面和其他全息影像)。</span><span class="sxs-lookup"><span data-stu-id="9202f-306">Pixel processing costs on the GPU can thus be high, especially in cases where there is more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="9202f-307">在此情況下, 最接近使用者的圖層將會進一步 occluding 任何圖層, 因此, 所花費的任何 GPU 時間都會浪費較遠的層級。</span><span class="sxs-lookup"><span data-stu-id="9202f-307">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="9202f-308">為了減少 GPU 上的這項多餘的工作, 它有助於以前後順序呈現不透明的表面 (較接近的介面, 最後一項則更遠)。</span><span class="sxs-lookup"><span data-stu-id="9202f-308">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="9202f-309">藉由「不透明」, 我們表示在您的[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中, DepthWriteMask 設定為一個的表面。</span><span class="sxs-lookup"><span data-stu-id="9202f-309">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="9202f-310">呈現最接近的表面時, 會將深度緩衝區質數, 使 GPU 上的圖元處理器可以有效率地略過較遠的表面。</span><span class="sxs-lookup"><span data-stu-id="9202f-310">When the nearest surfaces are rendered, they will prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="9202f-311">網格處理</span><span class="sxs-lookup"><span data-stu-id="9202f-311">Mesh Processing</span></span>

<span data-ttu-id="9202f-312">應用程式可能會想要在空間 surface 網格上執行[各種作業](spatial-mapping.md#mesh-processing), 以符合其需求。</span><span class="sxs-lookup"><span data-stu-id="9202f-312">An application may want to perform [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="9202f-313">每個空間 surface 網格提供的索引和頂點資料, 會使用與用來在所有新式轉譯 Api 中呈現三角形網格的[頂點和索引緩衝區](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)相同的熟悉配置。</span><span class="sxs-lookup"><span data-stu-id="9202f-313">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="9202f-314">不過, 要注意的一個重要事實是, 空間對應三角形具有**front 順時針的纏繞順序**。</span><span class="sxs-lookup"><span data-stu-id="9202f-314">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="9202f-315">每個三角形都會以網格的索引緩衝區中的三個頂點索引來表示, 而這些索引會在從**前端**觀看三角形時, 以**順時針**順序識別三角形的頂點。</span><span class="sxs-lookup"><span data-stu-id="9202f-315">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="9202f-316">空間 surface 網格的前端 (或外部) 與實際表面的正面 (可見) 邊緣相對應。</span><span class="sxs-lookup"><span data-stu-id="9202f-316">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="9202f-317">應用程式應該只在表面觀察器所提供的最粗略三角形密度仍能力不佳粗糙時, 才執行網格簡化-這項工作的計算成本很高, 且執行時間已執行, 以產生各種不同的提供的詳細資料層級。</span><span class="sxs-lookup"><span data-stu-id="9202f-317">Applications should only perform mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="9202f-318">由於每個介面觀察者都可以提供多個未連接的空間介面, 因此某些應用程式可能會想要彼此裁剪這些空間表面網格, 然後將它們 zipper 在一起。</span><span class="sxs-lookup"><span data-stu-id="9202f-318">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="9202f-319">一般而言, 裁剪步驟是必要的, 因為附近的空間介面網格通常會稍微重迭。</span><span class="sxs-lookup"><span data-stu-id="9202f-319">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="9202f-320">Raycasting 和碰撞</span><span class="sxs-lookup"><span data-stu-id="9202f-320">Raycasting and Collision</span></span>

<span data-ttu-id="9202f-321">為了讓物理 API (例如[Havok](http://www.havok.com/)) 為應用程式提供空間表面的 raycasting 和碰撞功能, 應用程式必須提供空間介面網格給物理 api。</span><span class="sxs-lookup"><span data-stu-id="9202f-321">In order for a physics API (such as [Havok](http://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="9202f-322">用於物理的網格通常具有下列屬性:</span><span class="sxs-lookup"><span data-stu-id="9202f-322">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="9202f-323">它們只包含少量的三角形。</span><span class="sxs-lookup"><span data-stu-id="9202f-323">They contain only small numbers of triangles.</span></span> <span data-ttu-id="9202f-324">物理運算比轉譯作業更密集。</span><span class="sxs-lookup"><span data-stu-id="9202f-324">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="9202f-325">它們是「水緊密」。</span><span class="sxs-lookup"><span data-stu-id="9202f-325">They are 'water-tight'.</span></span> <span data-ttu-id="9202f-326">預期為實心的表面不應該有小孔;即使是太小而無法顯示的漏洞, 也可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="9202f-326">Surfaces intended to be solid should not have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="9202f-327">它們會轉換成凸 hulls。</span><span class="sxs-lookup"><span data-stu-id="9202f-327">They are converted into convex hulls.</span></span> <span data-ttu-id="9202f-328">凸 hulls 有幾個多邊形, 而且沒有洞, 而且比原始三角形網格更有效率地處理。</span><span class="sxs-lookup"><span data-stu-id="9202f-328">Convex hulls have few polygons and are free of holes, and they are much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="9202f-329">針對空間表面執行 raycasts 時, 請記住, 這些表面通常是很複雜、雜亂的圖案, 而且有雜亂的細節, 就像您的辦公桌一樣!</span><span class="sxs-lookup"><span data-stu-id="9202f-329">When performing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="9202f-330">這表示單一 raycast 通常不足以提供介面圖形的足夠資訊, 以及接近其附近的空白空間的形狀。</span><span class="sxs-lookup"><span data-stu-id="9202f-330">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="9202f-331">因此, 在小型區域中執行許多 raycasts, 以及使用匯總結果來衍生更可靠的介面瞭解, 通常是個不錯的主意。</span><span class="sxs-lookup"><span data-stu-id="9202f-331">It is thus usually a good idea to perform many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="9202f-332">例如, 使用單一 raycast 的平均 10 raycasts 來引導全息影像放置在表面上, 會產生更流暢且較少的「抖動」結果。</span><span class="sxs-lookup"><span data-stu-id="9202f-332">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="9202f-333">不過, 請記住, 每個 raycast 都有高計算成本。</span><span class="sxs-lookup"><span data-stu-id="9202f-333">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="9202f-334">因此, 視您的使用案例而定, 您應該將其他 raycasts (每個框架執行) 的計算成本與[網格處理](spatial-mapping.md#mesh-processing)的計算成本進行取捨, 以平滑和移除空間介面中的漏洞 (在空間時執行)網格已更新)。</span><span class="sxs-lookup"><span data-stu-id="9202f-334">Thus depending on your usage scenario you should trade off the computational cost of additional raycasts (performed every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (performed when spatial meshes are updated).</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="9202f-335">疑難排解</span><span class="sxs-lookup"><span data-stu-id="9202f-335">Troubleshooting</span></span>
* <span data-ttu-id="9202f-336">為了讓 surface 網格能夠正確導向, 每個 GameObject 都必須是作用中, 然後才會將它傳送至 SurfaceObeserver, 以將其網格結構化。</span><span class="sxs-lookup"><span data-stu-id="9202f-336">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it is sent to the SurfaceObeserver to have its mesh constructed.</span></span> <span data-ttu-id="9202f-337">否則, 網格會顯示在您的空間中, 但會以怪度旋轉。</span><span class="sxs-lookup"><span data-stu-id="9202f-337">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="9202f-338">執行與 SurfaceObserver 通訊之腳本的 GameObject 必須設定為來源。</span><span class="sxs-lookup"><span data-stu-id="9202f-338">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="9202f-339">否則, 您所建立並傳送至 SurfaceObserver 的所有 Gameobject, 其網格都會與父遊戲物件的位移相等。</span><span class="sxs-lookup"><span data-stu-id="9202f-339">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="9202f-340">如此一來, 您的網格就會顯示數個計量, 讓您很難進行檢查的狀況。</span><span class="sxs-lookup"><span data-stu-id="9202f-340">This can make your meshes show up several meters away which makes it very hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="9202f-341">另請參閱</span><span class="sxs-lookup"><span data-stu-id="9202f-341">See also</span></span>
* [<span data-ttu-id="9202f-342">座標系統</span><span class="sxs-lookup"><span data-stu-id="9202f-342">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="9202f-343">DirectX 中的空間對應</span><span class="sxs-lookup"><span data-stu-id="9202f-343">Spatial mapping in DirectX</span></span>](spatial-mapping-in-directx.md)
* [<span data-ttu-id="9202f-344">Unity 中的空間對應</span><span class="sxs-lookup"><span data-stu-id="9202f-344">Spatial mapping in Unity</span></span>](spatial-mapping-in-unity.md)
* [<span data-ttu-id="9202f-345">空間對應設計</span><span class="sxs-lookup"><span data-stu-id="9202f-345">Spatial mapping design</span></span>](spatial-mapping-design.md)
* [<span data-ttu-id="9202f-346">場景理解</span><span class="sxs-lookup"><span data-stu-id="9202f-346">Scene Understanding</span></span>](scene-understanding.md)
* [<span data-ttu-id="9202f-347">案例研究 - 在實境中的的透視技術</span><span class="sxs-lookup"><span data-stu-id="9202f-347">Case study - Looking through holes in your reality</span></span>](case-study-looking-through-holes-in-your-reality.md)
