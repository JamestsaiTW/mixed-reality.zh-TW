---
title: 空間對應
description: 空間對應提供 HoloLens 周圍環境中實際表面的詳細標記法。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間對應, HoloLens, 混合現實, 表面重建, 網格, sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/24/2019
ms.locfileid: "63550495"
---
# <a name="spatial-mapping"></a>空間對應

空間對應提供 HoloLens 環境中實際表面的詳細標記法, 讓開發人員能夠建立一項「說服混合」現實體驗。 藉由將真實世界與虛擬世界合併, 應用程式就可以讓全息影像看起來很真實。 應用程式也可以藉由提供熟悉的真實世界行為和互動, 更自然地配合使用者的期望。

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a>裝置支援

<table>
<tr>
<th>功能</th><th style="width:150px"> <a href="hololens-hardware-details.md">HoloLens (第 1 代)</a></th><th style="width:150px">HoloLens 2</th><th style="width:150px"> <a href="immersive-headset-hardware-details.md">沉浸式頭戴裝置</a></th>
</tr><tr>
<td> 空間對應</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a>概念總覽

![涵蓋房間的網格表面](images/SurfaceReconstruction.jpg)<br>
*涵蓋房間的空間對應網格範例*

用於空間對應的兩個主要物件類型是「空間介面觀察者」和「空間介面」。

應用程式會提供具有一或多個周框磁片區的空間介面觀察者, 以定義應用程式希望接收空間對應資料的空間區域。 空間對應會針對每個磁片區, 提供應用程式一組空間表面。

這些磁片區可能是固定的 (位於與真實世界相關的固定位置), 也可以附加至 HoloLens (它們會移動, 但不會旋轉, 因為 HoloLens 會在環境中移動)。 每個空間表面都會以少量的空間來描述真實世界的表面, 以連接到世界鎖定[空間座標系統](coordinate-systems.md)的三角形網格來表示。

當 HoloLens 收集有關環境的新資料, 而且在環境發生變更時, 空間表面會出現、消失和變更。

## <a name="common-usage-scenarios"></a>常見使用案例

![一般空間對應使用案例的圖例:位置、遮蔽、物理和流覽](images/sm-concepts-1000px.png)

### <a name="placement"></a>放置

空間對應讓應用程式有機會對使用者呈現自然且熟悉的互動形式;將您的電話放在桌上有何自然？

將全息影像的位置 (或更廣泛地說, 空間位置的任何選擇) 限制為位於表面上, 可提供從 3D (點在空間) 到 2D (點在表面上) 的自然對應。 這會減少使用者必須提供給應用程式的資訊量, 因而讓使用者的互動速度更快、更簡單、更精確。 這一點特別重要, 因為「距離遠離」並不是我們用來實際與其他人或電腦進行通訊的東西。 當我們指向手指時, 就是指定方向, 而不是距離。

這裡要注意的一點是, 當應用程式從方向推斷距離時 (例如, 沿著使用者的注視方向執行 raycast 以尋找最近的空間表面), 這必須產生使用者能夠可靠地進行預測的結果。 否則, 使用者將喪失控制項的意義, 而這可能很快就會變得令人沮喪。 有一種方法可協助您執行多個 raycasts, 而不只是一個。 匯總結果應該更平滑且更可預測, 較不容易受到暫時性「極端」結果的影響 (可能是因為光線通過小型洞, 或遇到使用者不知道的小型幾何)。 您也可以在一段時間內執行匯總或平滑處理;例如, 您可以限制全息的最大速度, 與使用者之間的距離可能有所不同。 只是限制 [最小值] 和 [最大距離] 值也可以提供協助, 因此移動的全息影像不會突然進入距離或損毀到使用者的臉部。

應用程式也可以使用表面的形狀和方向來引導全息影像位置。 全像攝影的椅子不應穿透牆, 而且應該與樓層齊平, 即使它有點不平均。 這類功能可能會依賴物理衝突, 而不只是 raycasts, 但也會套用類似的問題。 如果要放置的全像投影片上有許多很小的多邊形, 像是椅子上的腿, 則將這些多邊形的物理表示擴充為更寬且更平滑的東西, 讓它們能夠更輕鬆地滑出空間表面, 而不需要畫面.

在極端的情況下, 使用者輸入可以完全簡化, 而空間表面則可以用來執行完全自動的全像投影位置。 例如, 應用程式可能會在牆上的某處放置全像攝影燈, 讓使用者按下。 關於可預測性的相同注意事項適用于這裡:如果使用者希望能夠控制全像投影位置, 但應用程式不一定會在其預期的地方放入全息影像 (如果燈出現在使用者無法觸達的地方), 這會是令人沮喪的體驗。 實際上, 執行需要使用者更正的自動放置可能會更糟, 而不只是要求使用者一律自行執行放置;因為*預期*會自動放置成功, 所以手動更正會感覺像是一種負擔!

另請注意, 應用程式使用空間介面進行放置的能力, 主要取決於應用程式的[掃描經驗](spatial-mapping-design.md#the-environment-scanning-experience)。 如果表面尚未掃描, 則無法用於放置。 應用程式會自行決定是否要讓使用者清楚清除, 讓他們可以協助掃描新的表面或選取新的位置。

在放置過程中, 對使用者的視覺效果回饋十分重要。 使用者必須知道全息與[接地效果](spatial-mapping.md#visualization)最接近的表面。 他們應該瞭解為什麼會限制其全息影像的移動 (例如, 因為與另一個附近的表面發生衝突)。 如果他們無法將全息圖形放在目前的位置, 則視覺效果的意見反應應該清楚說明為什麼不這麼做。 例如, 如果使用者嘗試將全像攝影的沙發放在牆中, 那麼牆後方的沙發部分應該會以生氣的色彩 pulsate。 相反地, 如果應用程式在使用者可以看到實際表面的位置找不到空間介面, 則應用程式應該讓這一點清楚。 在此區域中, 明顯不會產生接地效果, 可能會達成此目的。

### <a name="occlusion"></a>遮蔽

空間對應介面的主要用途之一, 就是遮蔽的全息影像。 這種簡單的行為會對觀察到的全息影像真實性產生巨大的影響, 協助建立真正占與使用者相同之實體空間的 visceral 意義。

遮蔽也會提供資訊給使用者;當全像投影表面 pixels occluded 時, 這會提供其他視覺效果意見反應給世界上該全息圖形的空間位置。 相反地, 遮蔽也可以常見*隱藏*使用者的資訊;occluding 牆後方的全息影像可以直覺地減少視覺雜亂的情形。 若要隱藏或顯示全息影像, 使用者只需要移動其標題。

遮蔽也可用來根據熟悉的實體互動, 將自然使用者介面的期望如果某個表面 pixels occluded 了全息影像, 這是因為該表面是實心的, 因此使用者應該預期全息影像會與該介面發生*衝突*, 而不只是通過它。

有時候不需要遮蔽的全息影像。 如果使用者需要能夠與全像投影互動, 則他們必須能夠看到它, 即使是在實際表面後面也一樣。 在這種情況下, 在 pixels occluded (例如, 藉由減少其亮度) 時, 呈現這類全息影像通常是合理的。 如此一來, 使用者將能夠以視覺化方式找出全像投影, 但是仍會察覺到它的背後。

### <a name="physics"></a>物理

使用物理模擬的另一種方式, 是使用空間對應來強化使用者實體空間中的全息*顯示*。 當我的全像說, 我的全像是從桌上折得, 然後在沙發下彈跳並消失時, 我可能很難相信這不是真正的。

物理模擬也讓應用程式有機會使用自然且熟悉的物理互動。 如果傢俱以適當的慣性和摩擦在地面之間滑動, 則移動地面上的全像攝影傢俱可能會更容易。

為了產生實際的實體行為, 您可能需要執行一些[網格處理](spatial-mapping.md#mesh-processing), 例如填滿孔、移除浮動 hallucinations 和平滑表面。

您也必須考慮應用程式的[掃描體驗](spatial-mapping-design.md#the-environment-scanning-experience)會如何影響其物理模擬。 首先, 遺漏的表面不會與任何專案衝突;當橡膠球在 corridor 和已知世界結束時, 會發生什麼事？ 其次, 您必須決定是否要在一段時間後繼續回應環境中的變更。 在某些情況下, 您會想要儘快回應;比方說, 如果使用者使用門和傢俱作為 tempest 的內送羅馬箭號的 barricades。 但在其他情況下, 您可能會想要忽略新的更新;如果您的狗決定坐在一軌的中間, 讓您的全像 racetrack 在地面上推動全像運動車, 可能會突然不那麼有趣。

### <a name="navigation"></a>巡覽

應用程式可以使用空間對應資料來授與全像攝影的字元 (或代理程式) 能夠以真實人員的相同方式來流覽真實世界。 這有助於加強全像攝影字元的存在, 方法是將它們限制為與使用者及其朋友的同一組自然、熟悉的行為。

流覽功能對使用者也很有用。 在特定區域內建導覽地圖之後, 您就可以共用它, 為不熟悉該位置的新使用者提供全像攝影方向。 這個對應可以設計來協助讓地下的「流量」順暢地流動, 或避免在危險位置 (例如結構網站) 中發生意外的情況。

執行導覽功能時所牽涉到的重要技術挑戰, 將會可靠地偵測 walkable 介面 (人類不會引導資料表!), 並對環境中的變更進行適當的調整 (人類不會逐步解說)。 網格可能需要先進行一些[處理](spatial-mapping.md#mesh-processing), 才能用於路徑規劃和導覽 (透過虛擬字元)。 將網格平滑化和移除 hallucinations, 可協助避免字元變得停滯。 您也可能想要大幅簡化網格, 以便加速字元的路徑規劃和導覽計算。 這些挑戰在開發 videogame 技術方面已經有很大的注意, 而且這些主題提供了豐富的研究文獻。

請注意, Unity 中的內建 NavMesh 功能無法與空間對應介面搭配使用。 這是因為在應用程式啟動之前, 空間對應介面不是已知的, 而 NavMesh 資料檔案必須事先從來源資產產生。 另請注意, 空間對應系統不會提供與使用者目前位置[非常遠之表面的相關資訊](spatial-mapping-design.md#the-environment-scanning-experience)。 因此, 如果應用程式要建立非常大區域的對應, 就必須「記住」自己的表面。

### <a name="visualization"></a>化

大部分時間都適用于空間表面不可見;以最小化視覺效果, 並讓真實世界自行溝通。 不過, 有時候直接將空間對應介面視覺化會很有用, 儘管實際的對應專案已經看得見。

例如, 當使用者嘗試將全息影像放在表面上 (比方說, 在牆上放置全像攝影的機櫃) 時, 將陰影轉型為介面, 就可以「地面」。 如此一來, 使用者就能更清楚地瞭解全息影像與表面之間的確切實體鄰近性。 這也是在使用者認可之前, 以視覺化方式「預覽」變更的一般作法範例。

藉由視覺化表面, 應用程式可以與使用者對環境的瞭解進行共用。 例如, 「全像攝影面板」遊戲可以將其識別為「資料表」的水準表面視覺化, 讓使用者知道他們應該前往何處互動。

視覺化表面是一個很實用的方式, 可顯示隱藏于 view 之外的使用者附近空白。 這可能會提供簡單的方法, 讓使用者從他們的聊天室存取廚房 (以及所有內含的全息影像)。

空間對應所提供的表面網格可能不會特別「清除」。 因此, 請務必適當地將它們視覺化。 傳統光源計算可能會以視覺上分散的方式反白顯示介面法線中的錯誤, 而投影到表面的「清除」紋理可能有助於提供整齊的外觀。 在呈現表面之前, 也可以執行[網格處理](spatial-mapping.md#mesh-processing)來改善網格屬性。

## <a name="using-the-surface-observer"></a>使用 Surface 觀察者

空間對應的起點是「表面觀察者」。 程式流程如下所示:
* 建立 surface observer 物件
   * 提供一或多個空間磁片區, 以定義應用程式希望接收空間對應資料的相關區域。 空間磁片區只是定義空間區域 (例如球體或方塊) 的圖形。
   * 使用具有全球鎖定空間座標系統的空間磁片區, 以識別實體世界的固定區域。
   * 使用空間磁片區, 以主體鎖定的空間座標系統更新每個框架, 以識別與使用者移動 (但不會旋轉) 的空間區域。
   * 當應用程式或使用者的狀態變更時, 這些空間磁片區可能會在稍後變更。
* 使用輪詢或通知來抓取空間表面的相關資訊
   * 您可以隨時「輪詢」「介面觀察器」的空間表面狀態。 或者, 您可以註冊 surface 觀察者的「表面已變更」事件, 這會在空間表面變更時通知應用程式。
   * 對於動態空間磁片區 (例如, 視圖截維或主體鎖定的卷), 應用程式必須藉由設定感關注的區域, 然後取得目前的空間表面集合, 來輪詢每個畫面格的變更。
   * 對於靜態磁片區 (例如涵蓋單一房間的全球鎖定 cube), 應用程式可能會註冊「介面已變更」事件, 以在該磁片區中的空間表面可能已變更時收到通知。
* 進程表面變更
   * 逐一查看提供的空間表面集合。
   * 將空間表面分類為已加入、已變更或已移除。
   * 針對每個新增或變更的空間介面, 如果適當地提交非同步要求以接收更新的網格, 表示介面在所需的詳細資料層級上的目前狀態。
* 處理非同步網狀要求 (下列各節中有更多詳細資料)。

## <a name="mesh-caching"></a>網格快取

空間表面是以密集三角形網格來表示。 儲存、轉譯和處理這些網格可能會耗用大量的計算和儲存資源。 因此, 每個應用程式都應該採用適合其需求的網格快取配置, 以便將用於網格處理和儲存的資源降至最低。 此配置應該會決定要保留哪些網格以及要捨棄哪些, 以及何時要更新每個空間介面的網格。

這裡討論的許多考慮都會直接通知應用程式應該如何處理網格快取。 您應該考慮到使用者如何在環境中移動、觀察到不同的表面, 以及何時應該捕捉環境中的變更。

當您解讀 surface 觀察者所提供的「表面已變更」事件時, 基本網格快取邏輯如下所示:
* 如果應用程式看到先前尚未看到的空間表面識別碼, 則應該將它視為新的空間介面。
* 如果應用程式看到具有已知識別碼的空間介面, 但具有新的更新時間, 則應該將此視為已更新的空間介面。
* 如果應用程式不再看到具有已知識別碼的空間介面, 則應該將它視為已移除的空間介面。

而是由每個應用程式決定, 然後進行下列選擇:
* 針對新的空間表面, 應該會要求網格嗎？
   * 通常應該立即針對新的空間表面要求網格, 這可能會對使用者提供有用的新資訊。
   * 不過, 在使用者附近和前方的新空間表面應具有優先順序, 而且應該先要求其網格。
   * 如果不需要新的網格, 例如應用程式已永久或暫時「凍結」其環境模型, 則不應要求。
* 針對已更新的空間表面, 應要求網格嗎？
   * 已更新使用者附近和前方的空間表面, 應優先取得, 而且應該先要求其網格。
   * 您也可以在新表面上給予較高的優先順序, 而不是更新的表面, 特別是在掃描體驗期間。
   * 為了限制處理成本, 應用程式可能想要節流處理更新至空間表面的速率。
   * 您可以推斷空間介面的變更是次要的, 例如, 如果表面的界限很小, 在此情況下, 更新可能不夠重要而無法處理。
   * 在使用者感興趣的目前區域外的空間表面更新可能會完全忽略, 不過在此情況下, 修改 surface 觀察者使用的空間界限磁片區可能會更有效率。
* 針對已移除的空間表面, 是否應該捨棄網格？
   * 通常應該針對已移除的空間表面立即捨棄網格, 讓全息影像遮蔽保持正確。
   * 不過, 如果應用程式有理由相信空間介面很快就會重新出現 (也許是根據使用者經驗的設計), 那麼保留它比捨棄網格並稍後重新建立, 可能會更有效率。
   * 如果應用程式正在建立使用者環境的大規模模型, 則可能不想要捨棄任何網格。 不過, 它仍然需要限制資源使用量, 可能是因為空間表面消失, 而將網格緩衝處理到磁片上。
   * 請注意, 在空間介面產生期間, 某些較罕見的事件可能會導致空間表面被類似位置中的新空間表面取代, 但使用不同的識別碼。 因此, 選擇不捨棄已移除表面的應用程式, 應該不會注意到涵蓋相同位置的多個高度重迭空間介面網格。
* 是否應該針對其他任何空間表面捨棄網格？
   * 即使空間表面存在, 如果它不再適用于使用者的經驗, 則應該將其捨棄。 例如, 如果應用程式「取代」門口另一端的房間, 還有替代虛擬空間, 那麼該房間內的空間表面就不再重要。

以下是使用空間和時態性遲滯的範例網格快取策略:
* 假設有一個應用程式想要在使用者看起來前後, 使用類似的錐狀空間量,
* 空間表面可能會暫時消失于此磁片區, 這是因為使用者看起來遠離表面或從其外部的步驟 ... 請稍後再回頭查看或移動更接近的時間。 在此情況下, 捨棄並重新建立此介面的網格代表許多多餘的處理。
* 為了減少已處理的變更數目, 應用程式會使用兩個空間表面觀察器, 其中一個會包含在另一個範圍內。 較大的磁片區是球形, 並遵循使用者的「延遲」;只有在必要時才會移動, 以確保其中心位於使用者的 2.0 metres 內。
* 新的和更新的空間表面網格一律會從較小的內部介面觀察器進行處理, 但是網格會快取, 直到它們從較大的外部表面觀察器消失為止。 這可讓應用程式避免因本機使用者移動而處理許多多餘的變更。
* 由於空間表面可能也會因為追蹤遺失而暫時消失, 因此應用程式也會在追蹤遺失期間, 延遲捨棄已移除的空間表面。
* 一般而言, 應用程式應該評估減少更新處理和增加記憶體使用量之間的取捨, 以判斷其理想的快取策略。

## <a name="rendering"></a>轉譯

空間對應網格通常用於轉譯的主要方式有三種:
* 針對表面視覺效果
   * 直接將空間表面視覺化通常會很有用。 例如, 將「陰影」從物件轉換成空間表面, 可以在使用者將全息影像放在表面上時, 為他們提供有用的視覺回饋。
   * 有一點要注意的是, 空間網格與3D 演出者可能建立的網格類型不同。 三角形拓撲不會像人類建立的拓撲一樣「清除」, 而且網格會受到[各種錯誤](spatial-mapping-design.md#what-influences-spatial-mapping-quality)的影響。
   * 為了建立令人滿意的視覺效果美觀, 您可能會想要執行一些[網格處理](spatial-mapping.md#mesh-processing), 例如填滿洞或平滑表面法線。 您也可能想要使用著色器, 將演出者設計的材質投影到網格上, 而不是直接視覺化網格拓朴和法線。
* 適用于真實世界表面的 occluding 全息影像
   * 空間表面可以在僅影響[深度緩衝區](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)且不會影響色彩呈現目標的深度傳遞中轉譯。
   * 這會質數深度緩衝區, 以遮蔽後續呈現的空間表面後置影像。 準確遮蔽的全息影像可增強全息影像真正存在於使用者的實體空間中的意義。
   * 若要啟用僅深度轉譯, 請更新 blend 狀態, 將所有色彩呈現目標的[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)設定為零。
* 修改真實世界表面所 pixels occluded 的全息影像外觀
   * 在 pixels occluded 時, 通常會隱藏呈現的幾何。 這是藉由將[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中的深度函式設定為「小於或等於」來達成, 這會使幾何只有在**靠近**相機的位置才可見, 而不是所有先前呈現的幾何。
   * 不過, 即使在 pixels occluded 時仍然可以看到某些幾何, 並在 pixels occluded 為對使用者提供視覺化回應的方式時修改其外觀, 可能會有説明。 例如, 這可讓應用程式向使用者顯示物件的位置, 同時讓它清楚呈現在真實世界的表面上。
   * 若要達到此目的, 請使用不同的著色器第二次轉譯幾何, 以建立所需的 ' pixels occluded ' 外觀。 第二次呈現幾何之前, 請對[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)進行兩個變更。 首先, 將深度函式設定為「大於或等於」, 如此一來, 只有在與所有先前呈現的幾何相比, 才會看到幾何的位置。 第二, 將 DepthWriteMask 設定為零, 如此就不會修改深度緩衝區 (深度緩衝區應該會繼續代表**最接近**相機的幾何深度)。

在轉譯空間對應網格時,[效能](understanding-performance-for-mixed-reality.md)是很重要的考慮。 以下是呈現空間對應網格特有的一些轉譯效能技術:
* 調整三角形密度
   * 當您從 surface 觀察者要求空間表面網格時, 請要求可滿足您需求的最小三角形網格密度。
   * 根據表面與使用者的距離, 以及其與使用者體驗的相關性, 可能會有意義地改變表面上的三角形密度。
   * 減少三角形計數可減少 GPU 上的記憶體使用量和頂點處理成本, 但不會影響圖元處理成本。
* 執行截錐剔除
   * 「截錐」剔除會略過無法看到的繪圖物件, 因為它們不在目前的顯示為「截錐」。 這可降低 CPU 和 GPU 處理成本。
   * 由於會針對每個網格來執行剔除, 而空間表面可能會很大, 因此, 將每個空間表面網格細分成較小的區塊, 可能會導致更有效率的剔除 (會轉譯較少的螢幕三角形)。 不過, 有一種取捨,您擁有的網格越多, 您必須進行的繪製呼叫越多, 這可能會增加 CPU 成本。 在極端的情況下, 截量的剔除計算本身甚至可以有可測量的 CPU 成本。
* 調整轉譯順序
   * 空間表面通常會很大, 因為它們代表使用者周圍的整個環境。 GPU 上的圖元處理成本可能會很高, 特別是在有多個可見幾何層級的情況下 (包括空間表面和其他全息影像)。 在此情況下, 最接近使用者的圖層將會進一步 occluding 任何圖層, 因此, 所花費的任何 GPU 時間都會浪費較遠的層級。
   * 為了減少 GPU 上的這項多餘的工作, 它有助於以前後順序呈現不透明的表面 (較接近的介面, 最後一項則更遠)。 藉由「不透明」, 我們表示在您的[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中, DepthWriteMask 設定為一個的表面。 呈現最接近的表面時, 會將深度緩衝區質數, 使 GPU 上的圖元處理器可以有效率地略過較遠的表面。

## <a name="mesh-processing"></a>網格處理

應用程式可能會想要在空間 surface 網格上執行[各種作業](spatial-mapping.md#mesh-processing), 以符合其需求。 每個空間 surface 網格提供的索引和頂點資料, 會使用與用來在所有新式轉譯 Api 中呈現三角形網格的[頂點和索引緩衝區](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)相同的熟悉配置。 不過, 要注意的一個重要事實是, 空間對應三角形具有**front 順時針的纏繞順序**。 每個三角形都會以網格的索引緩衝區中的三個頂點索引來表示, 而這些索引會在從**前端**觀看三角形時, 以**順時針**順序識別三角形的頂點。 空間 surface 網格的前端 (或外部) 與實際表面的正面 (可見) 邊緣相對應。

應用程式應該只在表面觀察器所提供的最粗略三角形密度仍能力不佳粗糙時, 才執行網格簡化-這項工作的計算成本很高, 且執行時間已執行, 以產生各種不同的提供的詳細資料層級。

由於每個介面觀察者都可以提供多個未連接的空間介面, 因此某些應用程式可能會想要彼此裁剪這些空間表面網格, 然後將它們 zipper 在一起。 一般而言, 裁剪步驟是必要的, 因為附近的空間介面網格通常會稍微重迭。

## <a name="raycasting-and-collision"></a>Raycasting 和碰撞

為了讓物理 API (例如[Havok](http://www.havok.com/)) 為應用程式提供空間表面的 raycasting 和碰撞功能, 應用程式必須提供空間介面網格給物理 api。 用於物理的網格通常具有下列屬性:
* 它們只包含少量的三角形。 物理運算比轉譯作業更密集。
* 它們是「水緊密」。 預期為實心的表面不應該有小孔;即使是太小而無法顯示的漏洞, 也可能會造成問題。
* 它們會轉換成凸 hulls。 凸 hulls 有幾個多邊形, 而且沒有洞, 而且比原始三角形網格更有效率地處理。

針對空間表面執行 raycasts 時, 請記住, 這些表面通常是很複雜、雜亂的圖案, 而且有雜亂的細節, 就像您的辦公桌一樣! 這表示單一 raycast 通常不足以提供介面圖形的足夠資訊, 以及接近其附近的空白空間的形狀。 因此, 在小型區域中執行許多 raycasts, 以及使用匯總結果來衍生更可靠的介面瞭解, 通常是個不錯的主意。 例如, 使用單一 raycast 的平均 10 raycasts 來引導全息影像放置在表面上, 會產生更流暢且較少的「抖動」結果。

不過, 請記住, 每個 raycast 都有高計算成本。 因此, 視您的使用案例而定, 您應該將其他 raycasts (每個框架執行) 的計算成本與[網格處理](spatial-mapping.md#mesh-processing)的計算成本進行取捨, 以平滑和移除空間介面中的漏洞 (在空間時執行)網格已更新)。

## <a name="troubleshooting"></a>疑難排解
* 為了讓 surface 網格能夠正確導向, 每個 GameObject 都必須是作用中, 然後才會將它傳送至 SurfaceObeserver, 以將其網格結構化。 否則, 網格會顯示在您的空間中, 但會以怪度旋轉。
* 執行與 SurfaceObserver 通訊之腳本的 GameObject 必須設定為來源。 否則, 您所建立並傳送至 SurfaceObserver 的所有 Gameobject, 其網格都會與父遊戲物件的位移相等。 如此一來, 您的網格就會顯示數個計量, 讓您很難進行檢查的狀況。

## <a name="see-also"></a>另請參閱
* [座標系統](coordinate-systems.md)
* [DirectX 中的空間對應](spatial-mapping-in-directx.md)
* [Unity 中的空間對應](spatial-mapping-in-unity.md)
* [空間對應設計](spatial-mapping-design.md)
* [案例研究 - 在實境中的的透視技術](case-study-looking-through-holes-in-your-reality.md)
