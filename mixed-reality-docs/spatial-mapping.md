---
title: 空間對應
description: 空間對應詳細呈現 HoloLens 四周圍環境中的實際介面。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空間對應、 HoloLens、 混合的實境，介面的重構、 網狀結構、 sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/12/2019
ms.locfileid: "59597102"
---
# <a name="spatial-mapping"></a><span data-ttu-id="3703d-104">空間對應</span><span class="sxs-lookup"><span data-stu-id="3703d-104">Spatial mapping</span></span>

<span data-ttu-id="3703d-105">空間對應提供詳細的呈現 HoloLens、 周圍環境中的實際介面，可讓開發人員建立逼真的混合的實境體驗。</span><span class="sxs-lookup"><span data-stu-id="3703d-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="3703d-106">藉由合併具有虛擬世界的真實世界應用程式可以讓全像投影看起來很實際。</span><span class="sxs-lookup"><span data-stu-id="3703d-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="3703d-107">應用程式可以也較自然地配合使用者的期望藉由提供熟悉的真實世界行為和互動方式。</span><span class="sxs-lookup"><span data-stu-id="3703d-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a><span data-ttu-id="3703d-108">裝置支援</span><span class="sxs-lookup"><span data-stu-id="3703d-108">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="3703d-109">功能</span><span class="sxs-lookup"><span data-stu-id="3703d-109">Feature</span></span></th><th style="width:150px"> <span data-ttu-id="3703d-110"><a href="hololens-hardware-details.md">HoloLens （第 1 代）</a></span><span class="sxs-lookup"><span data-stu-id="3703d-110"><a href="hololens-hardware-details.md">HoloLens (1st gen)</a></span></span></th><th style="width:150px"><span data-ttu-id="3703d-111">HoloLens 2</span><span class="sxs-lookup"><span data-stu-id="3703d-111">HoloLens 2</span></span></th><th style="width:150px"> <span data-ttu-id="3703d-112"><a href="immersive-headset-hardware-details.md">沈浸式耳機</a></span><span class="sxs-lookup"><span data-stu-id="3703d-112"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td> <span data-ttu-id="3703d-113">空間對應</span><span class="sxs-lookup"><span data-stu-id="3703d-113">Spatial mapping</span></span></td><td style="text-align: center;"> <span data-ttu-id="3703d-114">✔️</span><span class="sxs-lookup"><span data-stu-id="3703d-114">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="3703d-115">✔️</span><span class="sxs-lookup"><span data-stu-id="3703d-115">✔️</span></span></td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a><span data-ttu-id="3703d-116">概念式概觀</span><span class="sxs-lookup"><span data-stu-id="3703d-116">Conceptual overview</span></span>

<span data-ttu-id="3703d-117">![涵蓋聊天室的網狀結構介面](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="3703d-117">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="3703d-118">*空間對應網狀結構涵蓋聊天室的範例*</span><span class="sxs-lookup"><span data-stu-id="3703d-118">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="3703d-119">用於空間對應的兩個主要的物件類型為 '空間介面 Observer' 和' 空間介面 '。</span><span class="sxs-lookup"><span data-stu-id="3703d-119">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="3703d-120">應用程式會提供空間介面觀察者與一或多個週框的磁碟區，來定義的空間中的應用程式希望接收空間的對應資料區域。</span><span class="sxs-lookup"><span data-stu-id="3703d-120">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="3703d-121">針對每個這些磁碟區，空間的對應會提供一組的空間表面的應用程式。</span><span class="sxs-lookup"><span data-stu-id="3703d-121">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="3703d-122">（在相對於真實世界的固定位置），這些磁碟區可能是靜態，或它們可能會附加至 HoloLens （它們移動，但不是會旋轉，HoloLens 與在環境移動）。</span><span class="sxs-lookup"><span data-stu-id="3703d-122">These volumes may be stationary (in a fixed location with respect to the real world) or they may be attached to the HoloLens (they move, but do not rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="3703d-123">每個空間的介面描述小的磁碟區的空間，以附加至世界鎖定三角網格中的真實世界表面[空間座標系統](coordinate-systems.md)。</span><span class="sxs-lookup"><span data-stu-id="3703d-123">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="3703d-124">HoloLens 收集有關環境的新資料和空間表面的環境變更發生時，會出現、 消失，而變更。</span><span class="sxs-lookup"><span data-stu-id="3703d-124">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear and change.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="3703d-125">常見使用案例</span><span class="sxs-lookup"><span data-stu-id="3703d-125">Common usage scenarios</span></span>

![常見設定對應的空間使用方式案例的說明：放置、 阻擋、 物理學與導覽](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="3703d-127">放置</span><span class="sxs-lookup"><span data-stu-id="3703d-127">Placement</span></span>

<span data-ttu-id="3703d-128">空間對應提供給應用程式呈現給使用者; 的自然且熟悉的形式的互動的機會會比將您的手機下放在桌更自然？</span><span class="sxs-lookup"><span data-stu-id="3703d-128">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing your phone down on the desk?</span></span>

<span data-ttu-id="3703d-129">限制全像投影的位置 (或更廣泛地空間位置的任何選取範圍) 欺騙介面上提供自然對應 3D （空間中的點） 2D （介面上的點）。</span><span class="sxs-lookup"><span data-stu-id="3703d-129">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="3703d-130">這會減少使用者必須提供給應用程式，而讓使用者互動的更快、 更容易且更精確的資訊數量。</span><span class="sxs-lookup"><span data-stu-id="3703d-130">This reduces the amount of information the user needs to provide to the application and thus makes the user's interactions faster, easier and more precise.</span></span> <span data-ttu-id="3703d-131">這是特別是，則為 true，因為 '距離外傳' 不是我們用來實際傳達給其他人或電腦的項目。</span><span class="sxs-lookup"><span data-stu-id="3703d-131">This is particularly true because 'distance away' is not something that we are used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="3703d-132">當我們點與我們的手指時，我們會指定方向，但不是會在距離。</span><span class="sxs-lookup"><span data-stu-id="3703d-132">When we point with our finger, we are specifying a direction but not a distance.</span></span>

<span data-ttu-id="3703d-133">一個重要的警告是，當應用程式會推斷方向的距離 (例如藉由執行沿著以尋找最接近使用者的視線方向 raycast 空間介面)，這必須產生的使用者是否能夠可靠地預測的結果。</span><span class="sxs-lookup"><span data-stu-id="3703d-133">An important caveat here is that when an application infers distance from direction (for example by performing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user is able to reliably predict.</span></span> <span data-ttu-id="3703d-134">否則，使用者會失去其意義的控制項，而且這可能很快就會令人沮喪。</span><span class="sxs-lookup"><span data-stu-id="3703d-134">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="3703d-135">這可協助的其中一個方法是執行多個 raycasts，而不是其中一個。</span><span class="sxs-lookup"><span data-stu-id="3703d-135">One method that helps with this is to perform multiple raycasts instead of just one.</span></span> <span data-ttu-id="3703d-136">彙總的結果應該更順暢和更容易預測、 較不容易發生 （如有可能因光線通過微小的漏洞，或按下的使用者並不知道的幾何） 會影響從暫時性 '極端值' 結果。</span><span class="sxs-lookup"><span data-stu-id="3703d-136">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user is not aware of).</span></span> <span data-ttu-id="3703d-137">彙總或平滑處理，也可以執行一段時間;例如，您可以限制最快速度的雷射可以改變使用者的距離。</span><span class="sxs-lookup"><span data-stu-id="3703d-137">Aggregation or smoothing can also be performed over time; for example you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="3703d-138">最小和最大距離的值，只限制也可協助，讓正在移動全像圖不會突然離開飛到距離或有損毀回使用者的臉部。</span><span class="sxs-lookup"><span data-stu-id="3703d-138">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved does not suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="3703d-139">應用程式也可以使用的形狀和方向的表面指南全像位置。</span><span class="sxs-lookup"><span data-stu-id="3703d-139">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="3703d-140">全像攝影版的椅子不應該透過牆滲透，並且應該是清除使用最低限度值即使稍微分配不平均。</span><span class="sxs-lookup"><span data-stu-id="3703d-140">A holographic chair should not penetrate through walls and should sit flush with the floor even if it is slightly uneven.</span></span> <span data-ttu-id="3703d-141">這種功能可能會依賴使用物理衝突，而不是只 raycasts，不過類似的考量會套用。</span><span class="sxs-lookup"><span data-stu-id="3703d-141">This kind of functionality would likely rely upon the use of physics collisions rather than just raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="3703d-142">如果置入全像有許多小型的多邊形突出，例如腿的椅子上的合理的那些多邊形的物理條件表示展開至順暢地進行更多的項目，使其更能為移轉而不需要的空間表面投影片擷取。</span><span class="sxs-lookup"><span data-stu-id="3703d-142">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they are more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="3703d-143">在極端，使用者輸入，可以簡化立即完全和空間的介面可以用來執行完全自動的全像放置。</span><span class="sxs-lookup"><span data-stu-id="3703d-143">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to perform entirely automatic hologram placement.</span></span> <span data-ttu-id="3703d-144">例如，應用程式無法置於全像攝影版的 light switch 某處使用者按下的背景牆。</span><span class="sxs-lookup"><span data-stu-id="3703d-144">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="3703d-145">可預測性相同警告適用於雙向這裡;如果使用者需要掌控全像放置的功能，但應用程式並不一定會全像投影它們所預期的位置 （如果 light switch 出現使用者無法連線的地方），這會是令人沮喪的體驗。</span><span class="sxs-lookup"><span data-stu-id="3703d-145">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application does not always place holograms where they expect (if the light-switch appears somewhere that the user cannot reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="3703d-146">它實際上是較差，若要執行自動放置的功能需要使用者更正部分的情況下，比只是需要使用者一律會執行放置本身;因為成功的自動放置*預期*，手動更正覺得負擔 ！</span><span class="sxs-lookup"><span data-stu-id="3703d-146">It can actually be worse to perform automatic placement that requires user correction some of the time, than to just require the user to always perform placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="3703d-147">也請注意，應用程式的位置，取決於應用程式的使用空間的介面的能力[掃描體驗](spatial-mapping-design.md#the-environment-scanning-experience)。</span><span class="sxs-lookup"><span data-stu-id="3703d-147">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="3703d-148">如果尚未經過掃描介面，則它不能用於放置。</span><span class="sxs-lookup"><span data-stu-id="3703d-148">If a surface has not been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="3703d-149">這是由應用程式做出這個使用者，清楚了解，以便它們可以協助掃描新的介面，或選取新的位置。</span><span class="sxs-lookup"><span data-stu-id="3703d-149">It is up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="3703d-150">視覺化回饋給使用者最重要的是在放置期間。</span><span class="sxs-lookup"><span data-stu-id="3703d-150">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="3703d-151">使用者必須知道全像相對於與最接近的表面[紮效果](spatial-mapping.md#visualization)。</span><span class="sxs-lookup"><span data-stu-id="3703d-151">The user needs to know where the hologram is in relation to the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="3703d-152">它們應該先了解為什麼它們全像移動受到 （例如，由於衝突與另一個鄰近的介面）。</span><span class="sxs-lookup"><span data-stu-id="3703d-152">They should understand why the movement of their hologram is being constrained (for example, due to collision with another nearby surface).</span></span> <span data-ttu-id="3703d-153">如果它們不能將雷射放在目前的位置，然後視覺化回饋應該要為何不清楚。</span><span class="sxs-lookup"><span data-stu-id="3703d-153">If they cannot place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="3703d-154">例如，如果使用者嘗試進行全像攝影版的沙發上卡一半到牆上、 則位於牆沙發部分應該 pulsate 生氣的色彩。</span><span class="sxs-lookup"><span data-stu-id="3703d-154">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="3703d-155">或者，相反地，如果應用程式中，使用者可以看到真實世界介面的位置找不到工作空間的介面，然後應用程式應該清楚這。</span><span class="sxs-lookup"><span data-stu-id="3703d-155">Or conversely, if the application cannot find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="3703d-156">明顯缺少這方面的接地效果可能會達到這個目的。</span><span class="sxs-lookup"><span data-stu-id="3703d-156">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="3703d-157">遮蔽</span><span class="sxs-lookup"><span data-stu-id="3703d-157">Occlusion</span></span>

<span data-ttu-id="3703d-158">空間對應介面的主要用途之一是只要 occlude 全像投影。</span><span class="sxs-lookup"><span data-stu-id="3703d-158">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="3703d-159">這個簡單的行為會產生重大影響對全像投影，有助於建立真正視為與使用者相同的實體空間親和力有意義的認知的真實性。</span><span class="sxs-lookup"><span data-stu-id="3703d-159">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabit the same physical space as the user.</span></span>

<span data-ttu-id="3703d-160">阻擋也提供資訊給使用者;當全像圖看起來阻擋的真實世界的介面，這會提供其他視覺化該闀世界空間位置回應。</span><span class="sxs-lookup"><span data-stu-id="3703d-160">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides additional visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="3703d-161">相反地，會受阻擋可以也常見*隱藏*從使用者的資訊; occluding 全像投影背後牆可以減少視覺雜亂直覺的方式。</span><span class="sxs-lookup"><span data-stu-id="3703d-161">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="3703d-162">若要隱藏或顯示雷射，使用者只必須移動其標頭。</span><span class="sxs-lookup"><span data-stu-id="3703d-162">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="3703d-163">阻擋也可用來活絡期望根據熟悉的實體互動; 人性化使用者介面如果雷射會阻擋的介面，這是因為該介面是純色，因此使用者應該會希望全像圖會*衝突*與介面，並不只是通過它。</span><span class="sxs-lookup"><span data-stu-id="3703d-163">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not simply pass through it.</span></span>

<span data-ttu-id="3703d-164">有時候，阻擋全像投影的是不想要的。</span><span class="sxs-lookup"><span data-stu-id="3703d-164">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="3703d-165">如果使用者需要能夠互動雷射，他們必須能夠看到，即使它位於實際介面。</span><span class="sxs-lookup"><span data-stu-id="3703d-165">If a user needs to be able to interact with a hologram, then they need to be able to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="3703d-166">在此情況下，它通常可以合理地以不同的方式呈現這類雷射時 （例如，藉由減少其亮度），它會阻擋。</span><span class="sxs-lookup"><span data-stu-id="3703d-166">In such cases, it usually makes sense to render such a hologram differently when it is occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="3703d-167">如此一來，使用者將能夠以視覺化方式找出全像圖，但它們仍會知道它後面的項目。</span><span class="sxs-lookup"><span data-stu-id="3703d-167">This way, the user will be able to visually locate the hologram, but they will still be aware that it is behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="3703d-168">物理</span><span class="sxs-lookup"><span data-stu-id="3703d-168">Physics</span></span>

<span data-ttu-id="3703d-169">使用物理模擬是另一種空間對應可以用來強化*存在*的全像投影在使用者的實體空間中。</span><span class="sxs-lookup"><span data-stu-id="3703d-169">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="3703d-170">當我全像攝影版的拖放球彙實際上我桌關閉、 不斷在最低限度值和在沙發上就會消失時，可能會對我相信這一切都不沒什麼困難。</span><span class="sxs-lookup"><span data-stu-id="3703d-170">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not really there.</span></span>

<span data-ttu-id="3703d-171">物理模擬也提供應用程式使用自然且熟悉的物理式互動的機會。</span><span class="sxs-lookup"><span data-stu-id="3703d-171">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="3703d-172">移動周圍的全像攝影版傢俱地板上可能會讓使用者更容易如果家具回應，彷彿它已在適當的慣性和磨擦與 floor 滑動。</span><span class="sxs-lookup"><span data-stu-id="3703d-172">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="3703d-173">若要產生實際的實體行為，您可能需要執行一些[網格處理](spatial-mapping.md#mesh-processing)填滿漏洞，例如移除浮動 hallucinations 和平滑處理粗糙表面。</span><span class="sxs-lookup"><span data-stu-id="3703d-173">In order to generate realistic physical behaviors, you will likely need to perform some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="3703d-174">您也需要考慮如何您的應用程式[掃描體驗](spatial-mapping-design.md#the-environment-scanning-experience)會影響其物理模擬。</span><span class="sxs-lookup"><span data-stu-id="3703d-174">You will also need to consider how your application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="3703d-175">首先，遺漏介面不會與任何項目; 衝突關閉辦公室角落和已知的世界尾端拖放球轉動關閉時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="3703d-175">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="3703d-176">其次，您必須決定是否會繼續回應一段時間的環境中的變更。</span><span class="sxs-lookup"><span data-stu-id="3703d-176">Secondly, you need to decide whether you will continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="3703d-177">在某些情況下，您會想要盡快; 回應假設是否使用者使用門和 furniture 作為可移動 barricades 中的內送的 Roman 箭號 tempest 的防禦。</span><span class="sxs-lookup"><span data-stu-id="3703d-177">In some cases, you will want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="3703d-178">在其他情況下，您可能想要忽略新的更新;您地板上推動您全像攝影版跑車弧形周圍突然可能不那麼有趣，如果您的 dog 決定位於中間的追蹤。</span><span class="sxs-lookup"><span data-stu-id="3703d-178">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="3703d-179">巡覽</span><span class="sxs-lookup"><span data-stu-id="3703d-179">Navigation</span></span>

<span data-ttu-id="3703d-180">應用程式可用來授與全像攝影版的字元 （或代理程式） 能夠瀏覽中的相同方式來實際人員的真實世界空間的對應資料。</span><span class="sxs-lookup"><span data-stu-id="3703d-180">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="3703d-181">這可以幫助您藉由限制它們的自然、 熟悉的行為，為使用者及他們朋友的同一組強化出現全像攝影版的字元。</span><span class="sxs-lookup"><span data-stu-id="3703d-181">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="3703d-182">瀏覽功能可能有使用者，以及幫助的。</span><span class="sxs-lookup"><span data-stu-id="3703d-182">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="3703d-183">瀏覽對應建置在一個區域後, 就無法共用為全像攝影版的指示，針對不熟悉的新使用者提供該位置中。</span><span class="sxs-lookup"><span data-stu-id="3703d-183">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="3703d-184">無法設計此對應，來協助保持呆板 '' 傳送流量順利完成，或避免在危險的位置，例如建築工地的意外。</span><span class="sxs-lookup"><span data-stu-id="3703d-184">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="3703d-185">參與實作導覽功能的重要技術挑戰會可靠偵測查核 （讓人不在資料表逐步 ！） 的介面和非失誤性接納 （讓人不逐步解說已關閉的機門 ！） 的環境中的變更。</span><span class="sxs-lookup"><span data-stu-id="3703d-185">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="3703d-186">網狀結構可能需要一些[處理](spatial-mapping.md#mesh-processing)它就不能用於路徑規劃和瀏覽虛擬字元之前。</span><span class="sxs-lookup"><span data-stu-id="3703d-186">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it is usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="3703d-187">平滑化網格和移除 hallucinations 有助於避免成為停滯的字元。</span><span class="sxs-lookup"><span data-stu-id="3703d-187">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="3703d-188">您也可以大幅簡化網狀結構，以加快字元的路徑規劃和瀏覽計算。</span><span class="sxs-lookup"><span data-stu-id="3703d-188">You may also wish to drastically simplify the mesh in order to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="3703d-189">這些挑戰已收到大量的注意 videogame 技術，開發並取得的研究文獻中有關這些主題的豐富。</span><span class="sxs-lookup"><span data-stu-id="3703d-189">These challenges have received a great deal of attention in the development of videogame technology, and there is a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="3703d-190">請注意在 Unity 的內建 NavMesh 功能無法搭配空間對應介面。</span><span class="sxs-lookup"><span data-stu-id="3703d-190">Note that the built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="3703d-191">這是因為應用程式之前無法得知空間對應介面啟動，而需要從來源資產事先產生 NavMesh 資料檔案。</span><span class="sxs-lookup"><span data-stu-id="3703d-191">This is because spatial mapping surfaces are not known until the application starts, whereas NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="3703d-192">也請注意，空間的對應系統將不會提供[太遠介面的相關資訊](spatial-mapping-design.md#the-environment-scanning-experience)從使用者的目前位置。</span><span class="sxs-lookup"><span data-stu-id="3703d-192">Also note that, the spatial mapping system will not provide [information about surfaces very far away](spatial-mapping-design.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="3703d-193">讓應用程式必須 '記得' 介面本身是否建置非常大的區域的對應。</span><span class="sxs-lookup"><span data-stu-id="3703d-193">So the application must 'remember' surfaces itself if it is to build a map of a very large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="3703d-194">視覺效果</span><span class="sxs-lookup"><span data-stu-id="3703d-194">Visualization</span></span>

<span data-ttu-id="3703d-195">大部分的情況很適合空間表面不可見的;最小化視覺雜亂，並讓真實世界自己會說話。</span><span class="sxs-lookup"><span data-stu-id="3703d-195">Most of the time it is appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="3703d-196">不過，有時候適合以視覺化方式檢視空間的對應介面直接，儘管其實際對應項目已顯示。</span><span class="sxs-lookup"><span data-stu-id="3703d-196">However, sometimes it is useful to visualize spatial mapping surfaces directly, despite the fact that their real-world counterparts are already visible.</span></span>

<span data-ttu-id="3703d-197">例如，當使用者嘗試放置到介面 (separated 全像攝影版的封包在牆上，例如) 上的全像很實用 '接地' 全像投射陰影到介面上的。</span><span class="sxs-lookup"><span data-stu-id="3703d-197">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="3703d-198">這可讓使用者更清楚意義的全像和介面之間的確切實體附近。</span><span class="sxs-lookup"><span data-stu-id="3703d-198">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="3703d-199">這也是以視覺化方式 '預覽' 變更之前使用者認可至該處的更多一般作法的範例。</span><span class="sxs-lookup"><span data-stu-id="3703d-199">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="3703d-200">透過視覺化介面，應用程式可以與使用者共用其了解環境。</span><span class="sxs-lookup"><span data-stu-id="3703d-200">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="3703d-201">例如，全像攝影版的棋盤遊戲無法以視覺化方式檢視水平的介面，它已識別為 「 資料表 」，讓使用者知道他們應該前往互動。</span><span class="sxs-lookup"><span data-stu-id="3703d-201">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="3703d-202">視覺化介面，可以是適合用來向使用者顯示附近會從檢視隱藏的空間。</span><span class="sxs-lookup"><span data-stu-id="3703d-202">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="3703d-203">可從其起居室的絨布提供簡單的方式來授與使用者存取其廚房 （和所有其包含全像投影）。</span><span class="sxs-lookup"><span data-stu-id="3703d-203">This could provide a simple way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="3703d-204">空間對應所提供的網狀結構介面可能不是特別 '全新的'。</span><span class="sxs-lookup"><span data-stu-id="3703d-204">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="3703d-205">因此務必適當地將其視覺化。</span><span class="sxs-lookup"><span data-stu-id="3703d-205">Thus it is important to visualize them appropriately.</span></span> <span data-ttu-id="3703d-206">傳統的光源計算可能會反白顯示曲面法線中的錯誤擾亂視覺的方式，儘管投射到介面上的 [清除] 紋理可以協助您讓它的一個更有條理的外觀。</span><span class="sxs-lookup"><span data-stu-id="3703d-206">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, whilst 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="3703d-207">您也可執行[網格處理](spatial-mapping.md#mesh-processing)改善網格屬性，此介面上會呈現之前。</span><span class="sxs-lookup"><span data-stu-id="3703d-207">It is also possible to perform [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="3703d-208">使用介面的觀察者</span><span class="sxs-lookup"><span data-stu-id="3703d-208">Using The Surface Observer</span></span>

<span data-ttu-id="3703d-209">空間對應的起點是表面的觀察者。</span><span class="sxs-lookup"><span data-stu-id="3703d-209">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="3703d-210">程式流程如下所示：</span><span class="sxs-lookup"><span data-stu-id="3703d-210">Program flow is as follows:</span></span>
* <span data-ttu-id="3703d-211">建立介面的觀察者的物件</span><span class="sxs-lookup"><span data-stu-id="3703d-211">Create a surface observer object</span></span>
   * <span data-ttu-id="3703d-212">提供一或多個空間的磁碟區，來定義應用程式希望接收的資料空間對應的感興趣的區域。</span><span class="sxs-lookup"><span data-stu-id="3703d-212">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="3703d-213">空間的磁碟區是空間的只需定義區域，例如球體或方塊的圖形。</span><span class="sxs-lookup"><span data-stu-id="3703d-213">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="3703d-214">使用世界鎖定空間座標系統的空間的磁碟區，來識別實體世界的固定的區域。</span><span class="sxs-lookup"><span data-stu-id="3703d-214">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="3703d-215">使用空間的磁碟區，更新每個畫面格與主體鎖定空間座標系統中，找出的移動 （但不會旋轉） 空間的區域與使用者。</span><span class="sxs-lookup"><span data-stu-id="3703d-215">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but does not rotate) with the user.</span></span>
   * <span data-ttu-id="3703d-216">稍後在任何時間，為應用程式或使用者變更的狀態，可能會變更這些空間的磁碟區。</span><span class="sxs-lookup"><span data-stu-id="3703d-216">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="3703d-217">用於輪詢或通知擷取空間介面的相關資訊</span><span class="sxs-lookup"><span data-stu-id="3703d-217">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="3703d-218">您可能 '輪詢' 空間介面狀態介面的觀察者在任何時間。</span><span class="sxs-lookup"><span data-stu-id="3703d-218">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="3703d-219">或者，您可能會註冊介面觀察者的 '介面變更 」 事件，以空間介面已變更時，會通知應用程式。</span><span class="sxs-lookup"><span data-stu-id="3703d-219">Alternatively, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="3703d-220">針對動態空間磁碟區，例如位在檢視的範圍或主體而鎖定的磁碟區，應用程式必須輪詢變更每個畫面格藉由設定感興趣的區域，然後取得目前的空間表面。</span><span class="sxs-lookup"><span data-stu-id="3703d-220">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="3703d-221">對於靜態的磁碟區，例如全球鎖定的 cube，涵蓋單一的空間，應用程式可以登錄 '介面變更' 的事件，在該磁碟區的空間表面可能已變更時收到通知。</span><span class="sxs-lookup"><span data-stu-id="3703d-221">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="3703d-222">處理序的介面變更</span><span class="sxs-lookup"><span data-stu-id="3703d-222">Process surfaces changes</span></span>
   * <span data-ttu-id="3703d-223">逐一查看一組提供的空間表面。</span><span class="sxs-lookup"><span data-stu-id="3703d-223">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="3703d-224">分類空間表面為新增、 變更或移除。</span><span class="sxs-lookup"><span data-stu-id="3703d-224">Classify spatial surfaces as added, changed or removed.</span></span>
   * <span data-ttu-id="3703d-225">每個新增或變更空間介面，視提交非同步要求，以接收更新的網狀結構，表示介面的目前狀態的詳細資料所需的層級。</span><span class="sxs-lookup"><span data-stu-id="3703d-225">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="3703d-226">處理非同步網狀結構要求 （在下列各節中的詳細資料）。</span><span class="sxs-lookup"><span data-stu-id="3703d-226">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="3703d-227">Mesh 快取</span><span class="sxs-lookup"><span data-stu-id="3703d-227">Mesh Caching</span></span>

<span data-ttu-id="3703d-228">空間表面密集三角網格來表示。</span><span class="sxs-lookup"><span data-stu-id="3703d-228">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="3703d-229">儲存、 轉譯和處理這些網格可以耗用大量計算和儲存體資源。</span><span class="sxs-lookup"><span data-stu-id="3703d-229">Storing, rendering and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="3703d-230">因此，每個應用程式應該採用網格，快取配置符合其需求，為了盡量減少使用網格處理和儲存體的資源。</span><span class="sxs-lookup"><span data-stu-id="3703d-230">As such, each application should adopt a mesh caching scheme appropriate to its needs, in order to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="3703d-231">此配置應該判斷其網狀結構保留和要捨棄，以及何時更新每個空間的介面網狀結構。</span><span class="sxs-lookup"><span data-stu-id="3703d-231">This scheme should determine which meshes to retain and which to discard, as well as when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="3703d-232">有許多考量那里討論到直接將告知您的應用程式應該如何達到快取網狀結構。</span><span class="sxs-lookup"><span data-stu-id="3703d-232">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="3703d-233">您應該考慮使用者如何透過環境移動、 所需的介面、 不同的介面將會觀察到和何時應該擷取環境中的變更。</span><span class="sxs-lookup"><span data-stu-id="3703d-233">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="3703d-234">當解譯 '介面變更' 的事件介面的觀察者所提供，基本快取邏輯的網狀結構如下所示：</span><span class="sxs-lookup"><span data-stu-id="3703d-234">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="3703d-235">如果應用程式看到之前未看過的空間的介面識別碼，它應該將這視為新的空間介面。</span><span class="sxs-lookup"><span data-stu-id="3703d-235">If the application sees a spatial surface ID that it has not seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="3703d-236">如果應用程式會具有已知識別碼空間的介面，但使用新的更新時間，它應該將這視為更新的空間介面。</span><span class="sxs-lookup"><span data-stu-id="3703d-236">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="3703d-237">如果應用程式不會再看到具有已知識別碼空間的介面，它應該將這視為已移除的空間介面。</span><span class="sxs-lookup"><span data-stu-id="3703d-237">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="3703d-238">負責每個應用程式，然後進行下列選擇：</span><span class="sxs-lookup"><span data-stu-id="3703d-238">It is up to each application to then make the following choices:</span></span>
* <span data-ttu-id="3703d-239">針對新的空間表面，不應網狀結構要求嗎？</span><span class="sxs-lookup"><span data-stu-id="3703d-239">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="3703d-240">通常應該立即要求網格的新空間的介面，可能很有用的新資訊提供給使用者。</span><span class="sxs-lookup"><span data-stu-id="3703d-240">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="3703d-241">不過，新的空間表面接近，並在使用者之前，應該會提供優先順序，而且應該先要求其網狀結構。</span><span class="sxs-lookup"><span data-stu-id="3703d-241">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="3703d-242">如果不需要新的網狀結構，如果例如應用程式具有永久或暫時 '凍結' 其環境的模型，則它應該不會要求。</span><span class="sxs-lookup"><span data-stu-id="3703d-242">If the new mesh is not needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it should not be requested.</span></span>
* <span data-ttu-id="3703d-243">如已更新的空間表面，不應網狀結構要求嗎？</span><span class="sxs-lookup"><span data-stu-id="3703d-243">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="3703d-244">已更新的空間表面接近，並在使用者之前的優先順序應，應該先要求其網狀結構。</span><span class="sxs-lookup"><span data-stu-id="3703d-244">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="3703d-245">它也可能是適用於新的介面比為了更新介面，尤其是在掃描的體驗提供較高的優先順序。</span><span class="sxs-lookup"><span data-stu-id="3703d-245">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="3703d-246">若要限制處理成本，應用程式可能想要啟用它們處理空間介面的更新速率的節流設定。</span><span class="sxs-lookup"><span data-stu-id="3703d-246">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="3703d-247">它可能推斷空間介面的變更是次要時，例如，如果介面的界限很小，在此情況下更新可能不重要，程序。</span><span class="sxs-lookup"><span data-stu-id="3703d-247">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="3703d-248">雖然在此情況下，它可能會更有效率的方式修改空間週框的磁碟區，使用介面的觀察者，可能會請完全忽略目前的使用者感興趣的區域之外的空間表面的更新。</span><span class="sxs-lookup"><span data-stu-id="3703d-248">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="3703d-249">移除空間的介面，如應網狀結構捨棄嗎？</span><span class="sxs-lookup"><span data-stu-id="3703d-249">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="3703d-250">通常網狀結構應捨棄立即移除空間的介面，如，使得闀阻擋保持正確。</span><span class="sxs-lookup"><span data-stu-id="3703d-250">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="3703d-251">不過，如果應用程式有理由相信，空間的介面將會重新顯示短時間內 （或許是根據使用者經驗的設計），則可能是更有效率的方式保留它比以捨棄其網狀結構，並稍後再重新建立它。</span><span class="sxs-lookup"><span data-stu-id="3703d-251">However, if the application has reason to believe that a spatial surface will reappear shortly (perhaps based upon the design of the user experience), then it may be more efficient to retain it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="3703d-252">如果應用程式建立使用者環境的大規模模型然後它可能不想要完全捨棄任何網格。</span><span class="sxs-lookup"><span data-stu-id="3703d-252">If the application is building a large-scale model of the user's environment then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="3703d-253">它仍然需要限制資源使用量，可能是由多工緩衝處理到磁碟的網格如空間表面會消失。</span><span class="sxs-lookup"><span data-stu-id="3703d-253">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="3703d-254">請注意，某些較罕見的事件，空間的介面產生期間可能會導致空間的介面，以將其取代新的空間表面類似的位置，但不同的識別碼。</span><span class="sxs-lookup"><span data-stu-id="3703d-254">Note that some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="3703d-255">因此，選擇不捨棄移除的介面的應用程式應該注意不要結束註冊與多個高重疊空間介面網格涵蓋相同的位置。</span><span class="sxs-lookup"><span data-stu-id="3703d-255">Consequently, applications that choose not to discard a removed surface should take care not to end up with multiple highly-overlapped spatial surface meshes covering the same location.</span></span>
* <span data-ttu-id="3703d-256">應該針對任何其他的空間表面捨棄網格嗎？</span><span class="sxs-lookup"><span data-stu-id="3703d-256">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="3703d-257">即使在工作空間的介面存在，如果它不再有用的使用者經驗則應予捨棄。</span><span class="sxs-lookup"><span data-stu-id="3703d-257">Even while a spatial surface exists, if it is no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="3703d-258">例如，如果應用程式 '取代' 門廊的另一端聊天室替代的虛擬空間然後該聊天室中的空間介面不會再造成影響。</span><span class="sxs-lookup"><span data-stu-id="3703d-258">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="3703d-259">以下是範例網狀結構的快取策略，使用空間和時態磁滯現象：</span><span class="sxs-lookup"><span data-stu-id="3703d-259">Here is an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="3703d-260">請考慮使用範圍形狀空間的磁碟區依照使用者的視線，看一下並四處巡察的感興趣的應用程式。</span><span class="sxs-lookup"><span data-stu-id="3703d-260">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="3703d-261">空間的介面可能會消失暫時從這個磁碟區只是因為使用者看起來與介面，或者步驟遠離...只有要回頭查看以前或更接近再次一點時間更新版本。</span><span class="sxs-lookup"><span data-stu-id="3703d-261">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="3703d-262">在此情況下，捨棄並重新建立此介面網狀結構代表許多備援的處理。</span><span class="sxs-lookup"><span data-stu-id="3703d-262">In this case, discarding and re-creating the mesh for this surface represents a lot of redundant processing.</span></span>
* <span data-ttu-id="3703d-263">若要減少處理的變更數目，應用程式會使用兩個空間介面觀察者，其中包含在另一個。</span><span class="sxs-lookup"><span data-stu-id="3703d-263">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="3703d-264">較大的磁碟區會更低的球面接著使用者 '延遲';以確保其中心內之使用者的 2.0 metres 必要時，它只會移動。</span><span class="sxs-lookup"><span data-stu-id="3703d-264">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its centre is within 2.0 metres of the user.</span></span>
* <span data-ttu-id="3703d-265">新增和更新的空間表面網格處理永遠都會從較小內部介面觀察者，但網格會快取，直到它們從較大的外部介面觀察者便會消失。</span><span class="sxs-lookup"><span data-stu-id="3703d-265">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="3703d-266">這可讓應用程式，以避免處理許多重複的變更，因為本機使用者移動。</span><span class="sxs-lookup"><span data-stu-id="3703d-266">This allows the application to avoid processing many redundant changes due to local user movement.</span></span>
* <span data-ttu-id="3703d-267">由於空間的介面也可能因為追蹤遺失暫時消失，應用程式也會捨棄已移除的空間表面延遲期間追蹤遺失。</span><span class="sxs-lookup"><span data-stu-id="3703d-267">Since a spatial surface may also disappear temporarily due to tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="3703d-268">一般情況下，應用程式應該評估降低的更新處理和增加的記憶體使用量，以判斷其理想的快取策略之間的權衡取捨。</span><span class="sxs-lookup"><span data-stu-id="3703d-268">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="3703d-269">轉譯</span><span class="sxs-lookup"><span data-stu-id="3703d-269">Rendering</span></span>

<span data-ttu-id="3703d-270">有空間對應網格容易用於轉譯的三種主要方式：</span><span class="sxs-lookup"><span data-stu-id="3703d-270">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="3703d-271">介面的視覺效果</span><span class="sxs-lookup"><span data-stu-id="3703d-271">For surface visualization</span></span>
   * <span data-ttu-id="3703d-272">它通常是可直接以視覺化方式檢視空間的介面。</span><span class="sxs-lookup"><span data-stu-id="3703d-272">It is often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="3703d-273">比方說，轉型 'shadows' 從到空間介面的物件可以提供很有幫助的視覺化回饋給使用者時它們會在介面上放置全像投影。</span><span class="sxs-lookup"><span data-stu-id="3703d-273">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they are placing holograms on surfaces.</span></span>
   * <span data-ttu-id="3703d-274">要謹記在心的一點是，空間的網格是不同種類的 3D 的演出者可能會建立的網格。</span><span class="sxs-lookup"><span data-stu-id="3703d-274">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="3703d-275">三角形拓撲不會為 [清除] 以人類看得建立拓樸，網狀結構將會遭受[各種錯誤](spatial-mapping-design.md#what-influences-spatial-mapping-quality)。</span><span class="sxs-lookup"><span data-stu-id="3703d-275">The triangle topology will not be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping-design.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="3703d-276">若要建立賞心悅目的視覺化美觀，可能因此想要執行一些[網格處理](spatial-mapping.md#mesh-processing)，例如，若要填滿漏洞或平滑的曲面法線。</span><span class="sxs-lookup"><span data-stu-id="3703d-276">In order to create a pleasing visual aesthetic, you may thus want to perform some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="3703d-277">您也可能會想要使用專案演出者設計紋理著色器，而不是直接視覺化網狀拓樸和 normals 網格上。</span><span class="sxs-lookup"><span data-stu-id="3703d-277">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="3703d-278">針對 occluding 真實世界介面背後全像投影</span><span class="sxs-lookup"><span data-stu-id="3703d-278">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="3703d-279">空間的介面可以呈現在僅限深度的階段中的哪一個只會影響[深度緩衝區](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)並不會影響色彩呈現目標。</span><span class="sxs-lookup"><span data-stu-id="3703d-279">Spatial surfaces can be rendered in a depth-only pass which only affects the [depth buffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) and does not affect color render targets.</span></span>
   * <span data-ttu-id="3703d-280">這會裝填 occlude 接著呈現全像投影空間介面背後的深度緩衝區。</span><span class="sxs-lookup"><span data-stu-id="3703d-280">This primes the depth buffer to occlude subsequently-rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="3703d-281">全像投影的精確阻擋增強全像投影真正使用者的實體空間中存在的意義。</span><span class="sxs-lookup"><span data-stu-id="3703d-281">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="3703d-282">若要啟用僅限深度的轉譯，更新您要設定的 blend 狀態[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)為零的所有色彩呈現目標。</span><span class="sxs-lookup"><span data-stu-id="3703d-282">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) to zero for all color render targets.</span></span>
* <span data-ttu-id="3703d-283">修改全像投影阻擋實際呈現的外觀</span><span class="sxs-lookup"><span data-stu-id="3703d-283">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="3703d-284">它會阻擋時，會隱藏通常轉譯的幾何。</span><span class="sxs-lookup"><span data-stu-id="3703d-284">Normally rendered geometry is hidden when it is occluded.</span></span> <span data-ttu-id="3703d-285">即可達成此目的設定深度函式您[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)到 「 小於或等於 」，因而導致可只會針對幾何**接近**比所有先前呈現觀景窗幾何。</span><span class="sxs-lookup"><span data-stu-id="3703d-285">This is achieved by setting the depth function in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) to "less than or equal", which causes geometry to be visible only where it is **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="3703d-286">不過，它可能適用於保留特定 geometry 可見，即使它會阻擋，以及修改其外觀時阻擋這種方式提供視覺化回饋給使用者。</span><span class="sxs-lookup"><span data-stu-id="3703d-286">However, it may be useful to keep certain geometry visible even when it is occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="3703d-287">比方說，這可讓應用程式顯示使用者的物件進行清楚指出，同時位置位於實際介面。</span><span class="sxs-lookup"><span data-stu-id="3703d-287">For example, this allows the application to show the user the location of an object whilst making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="3703d-288">若要這麼做，呈現 geometry 與不同的著色器建立所需的 'occluded' 外觀的第二次。</span><span class="sxs-lookup"><span data-stu-id="3703d-288">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="3703d-289">第二次呈現 geometry 前, 變更兩個您[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)。</span><span class="sxs-lookup"><span data-stu-id="3703d-289">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="3703d-290">首先，設定為 「 大於或等於 」 的 深度函式，以便幾何將會顯示只會針對**進一步**所有先前呈現 geometry 比相機中。</span><span class="sxs-lookup"><span data-stu-id="3703d-290">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it is **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="3703d-291">接下來，設定為零，DepthWriteMask，以便將不會修改深度緩衝區 (深度緩衝區應該繼續代表幾何的深度**接近**到攝影機)。</span><span class="sxs-lookup"><span data-stu-id="3703d-291">Second, set the DepthWriteMask to zero, so that the depth buffer will not be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="3703d-292">[效能](understanding-performance-for-mixed-reality.md)轉譯空間對應網格時，是重要的考量。</span><span class="sxs-lookup"><span data-stu-id="3703d-292">[Performance](understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="3703d-293">以下是一些轉譯效能技術特定轉譯空間對應網格：</span><span class="sxs-lookup"><span data-stu-id="3703d-293">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="3703d-294">調整三角形密度</span><span class="sxs-lookup"><span data-stu-id="3703d-294">Adjust triangle density</span></span>
   * <span data-ttu-id="3703d-295">當提出要求的空間表面網狀結構從您的 surface 觀察者時，要求最低密度之三角網格可滿足您的需求。</span><span class="sxs-lookup"><span data-stu-id="3703d-295">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="3703d-296">合理更改三角形密度，根據介面的距離，從使用者介面的介面進行，以及其相關性的使用者經驗。</span><span class="sxs-lookup"><span data-stu-id="3703d-296">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="3703d-297">減少三角形計數會減少記憶體使用量和 GPU 上的頂點處理成本，但它不會影響像素處理成本。</span><span class="sxs-lookup"><span data-stu-id="3703d-297">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it will not affect pixel processing costs.</span></span>
* <span data-ttu-id="3703d-298">執行範圍剔除</span><span class="sxs-lookup"><span data-stu-id="3703d-298">Perform frustum culling</span></span>
   * <span data-ttu-id="3703d-299">範圍剔除，就會略過繪圖顯示位在目前範圍之外，所以看不到的物件。</span><span class="sxs-lookup"><span data-stu-id="3703d-299">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="3703d-300">這會減少 CPU 和 GPU 處理成本。</span><span class="sxs-lookup"><span data-stu-id="3703d-300">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="3703d-301">因為剔除網狀結構每列方式執行，而且空間介面可能很大，分成較小的區塊中的每個空間的介面網狀結構可能會導致更有效率的剔除 （其中呈現較少的幕後三角形）。</span><span class="sxs-lookup"><span data-stu-id="3703d-301">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="3703d-302">是有代價的不過;您有更多節點網路，多個繪製呼叫您必須進行的這可能會增加 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="3703d-302">There is a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="3703d-303">在極端的情況下，挑選自己的計算範圍可能甚至會有可測量的 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="3703d-303">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="3703d-304">調整轉譯順序</span><span class="sxs-lookup"><span data-stu-id="3703d-304">Adjust rendering order</span></span>
   * <span data-ttu-id="3703d-305">空間介面通常都很大，因為它們代表了使用者整個環境的周圍的地方。</span><span class="sxs-lookup"><span data-stu-id="3703d-305">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="3703d-306">像素處理 GPU 的成本可能因此非常高，尤其是在沒有可見的幾何 （包括空間的介面和其他全像投影） 的多個圖層。</span><span class="sxs-lookup"><span data-stu-id="3703d-306">Pixel processing costs on the GPU can thus be high, especially in cases where there is more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="3703d-307">在此情況下，距離使用者最近的圖層會 occluding 進一步在任何層級，因此在浪費任何 GPU 時間轉譯這些更遠距的圖層。</span><span class="sxs-lookup"><span data-stu-id="3703d-307">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="3703d-308">若要減少此備援的工作，在 GPU 上，最好先呈現不透明的介面，以由前至後的順序 (進一步的第一個、 更遠距的最後一個)。</span><span class="sxs-lookup"><span data-stu-id="3703d-308">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="3703d-309">'Opaque' 是指的介面設定中的 DepthWriteMask 您[深度樣板狀態](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)。</span><span class="sxs-lookup"><span data-stu-id="3703d-309">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="3703d-310">最接近的表面會進行轉譯時，它們將質數深度緩衝區，以更遠距介面像素處理器在 GPU 上有效率地略過。</span><span class="sxs-lookup"><span data-stu-id="3703d-310">When the nearest surfaces are rendered, they will prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="3703d-311">網格處理</span><span class="sxs-lookup"><span data-stu-id="3703d-311">Mesh Processing</span></span>

<span data-ttu-id="3703d-312">應用程式可能會想要執行[各種作業](spatial-mapping.md#mesh-processing)上空間曲面的網狀結構，以符合其需求。</span><span class="sxs-lookup"><span data-stu-id="3703d-312">An application may want to perform [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="3703d-313">與每個空間的介面網格所提供的索引和頂點資料會使用與相同的熟悉配置[端點和索引緩衝區](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)，用於呈現三角網格中所有現代轉譯 Api。</span><span class="sxs-lookup"><span data-stu-id="3703d-313">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="3703d-314">不過，要注意的一個重點是空間對應三角形有**front-順時針彎曲順序**。</span><span class="sxs-lookup"><span data-stu-id="3703d-314">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="3703d-315">每一個三角形表示網格索引緩衝區中的三個頂點索引和這些索引會識別中的三角形頂點**順時針**三角形從檢視時的順序**front**側邊。</span><span class="sxs-lookup"><span data-stu-id="3703d-315">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="3703d-316">前面部分 （或外部） 的空間表面的網格對應跟您想要 （可見） 的真實世界表面的正面。</span><span class="sxs-lookup"><span data-stu-id="3703d-316">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="3703d-317">如果介面的觀察者所提供的粗略三角形密度是仍然不足粗略-這項工作相當耗費運算資源的網狀結構簡化並已執行的執行階段產生的各種應用程式應該只執行提供層級的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="3703d-317">Applications should only perform mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="3703d-318">由於每個介面的觀察者可提供多個未連接的空間表面，有些應用程式可能會想要裁剪這些空間介面網狀結構針對每個其他，然後壓縮程式它們在一起。</span><span class="sxs-lookup"><span data-stu-id="3703d-318">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="3703d-319">一般情況下，[裁剪] 步驟是必要的因為空間介面網格附近通常會稍微重疊。</span><span class="sxs-lookup"><span data-stu-id="3703d-319">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="3703d-320">Raycasting 和衝突</span><span class="sxs-lookup"><span data-stu-id="3703d-320">Raycasting and Collision</span></span>

<span data-ttu-id="3703d-321">為了讓物理 API (例如[Havok](http://www.havok.com/)) raycasting 和衝突的功能為應用程式提供的空間面，應用程式必須提供空間介面網狀結構來物理 API。</span><span class="sxs-lookup"><span data-stu-id="3703d-321">In order for a physics API (such as [Havok](http://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="3703d-322">通常用於物理的網狀結構具有下列屬性：</span><span class="sxs-lookup"><span data-stu-id="3703d-322">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="3703d-323">它們包含僅有少量的三角形。</span><span class="sxs-lookup"><span data-stu-id="3703d-323">They contain only small numbers of triangles.</span></span> <span data-ttu-id="3703d-324">物理作業都需密集運算比轉譯作業。</span><span class="sxs-lookup"><span data-stu-id="3703d-324">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="3703d-325">也就是 ' water-嚴格 '。</span><span class="sxs-lookup"><span data-stu-id="3703d-325">They are 'water-tight'.</span></span> <span data-ttu-id="3703d-326">要具備紮實的表面不應該有小型有漏洞;甚至太小，因此不可見的漏洞可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="3703d-326">Surfaces intended to be solid should not have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="3703d-327">它們會轉換成凸 hulls。</span><span class="sxs-lookup"><span data-stu-id="3703d-327">They are converted into convex hulls.</span></span> <span data-ttu-id="3703d-328">凸 hulls 有幾個多邊形，而且免費提供的漏洞，而且也有更多的運算有效率的方式處理比未經處理的三角形網狀結構。</span><span class="sxs-lookup"><span data-stu-id="3703d-328">Convex hulls have few polygons and are free of holes, and they are much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="3703d-329">當執行 raycasts 針對空間的介面，請記住這些介面通常很複雜時，雜亂的雜亂少詳細資料-只是完整的圖形就像您的支援中心 ！</span><span class="sxs-lookup"><span data-stu-id="3703d-329">When performing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="3703d-330">這表示單一 raycast 通常不足以提供您足夠圖形的相關資訊的介面和電話附近的空白空間的形狀。</span><span class="sxs-lookup"><span data-stu-id="3703d-330">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="3703d-331">它是因此通常是個好主意，來執行許多 raycasts 小區域內，以及衍生介面的更可靠的了解使用彙總的結果。</span><span class="sxs-lookup"><span data-stu-id="3703d-331">It is thus usually a good idea to perform many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="3703d-332">比方說，使用 10 raycasts 平均指南全像放置在介面上會產生更順暢且較不 '抖動的' 的結果使用只是單一 raycast。</span><span class="sxs-lookup"><span data-stu-id="3703d-332">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="3703d-333">不過，請記得，每個 raycast 可以有高的計算成本。</span><span class="sxs-lookup"><span data-stu-id="3703d-333">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="3703d-334">因此根據您的使用方式案例您應該取捨的其他 raycasts 的計算成本 （執行每個畫面格） 的計算成本對[網格處理](spatial-mapping.md#mesh-processing)來緩和及移除空間表面 （漏洞執行更新空間網狀結構時）。</span><span class="sxs-lookup"><span data-stu-id="3703d-334">Thus depending on your usage scenario you should trade off the computational cost of additional raycasts (performed every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (performed when spatial meshes are updated).</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="3703d-335">疑難排解</span><span class="sxs-lookup"><span data-stu-id="3703d-335">Troubleshooting</span></span>
* <span data-ttu-id="3703d-336">為了讓介面的網格是 orientated 正確，每個 GameObject 必須能夠建構其網狀結構將它傳送至 SurfaceObeserver 之前為作用中。</span><span class="sxs-lookup"><span data-stu-id="3703d-336">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it is sent to the SurfaceObeserver to have its mesh constructed.</span></span> <span data-ttu-id="3703d-337">否則，網格會顯示在但旋轉的空間，在奇怪的角度。</span><span class="sxs-lookup"><span data-stu-id="3703d-337">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="3703d-338">執行通訊的指令碼與 SurfaceObserver GameObject 必須設為原始伺服器。</span><span class="sxs-lookup"><span data-stu-id="3703d-338">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="3703d-339">否則，所有您建立並傳送給 SurfaceObserver 以已建構其網格 Gameobject 必須位移等於父遊戲物件的位移。</span><span class="sxs-lookup"><span data-stu-id="3703d-339">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="3703d-340">這可讓您顯示數個計量消失，因此很難進行偵錯 發生什麼情況的網格。</span><span class="sxs-lookup"><span data-stu-id="3703d-340">This can make your meshes show up several meters away which makes it very hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="3703d-341">另請參閱</span><span class="sxs-lookup"><span data-stu-id="3703d-341">See also</span></span>
* [<span data-ttu-id="3703d-342">座標系統</span><span class="sxs-lookup"><span data-stu-id="3703d-342">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="3703d-343">DirectX 中的空間對應</span><span class="sxs-lookup"><span data-stu-id="3703d-343">Spatial mapping in DirectX</span></span>](spatial-mapping-in-directx.md)
* [<span data-ttu-id="3703d-344">在 Unity 中的空間對應</span><span class="sxs-lookup"><span data-stu-id="3703d-344">Spatial mapping in Unity</span></span>](spatial-mapping-in-unity.md)
* [<span data-ttu-id="3703d-345">空間對應設計</span><span class="sxs-lookup"><span data-stu-id="3703d-345">Spatial mapping design</span></span>](spatial-mapping-design.md)
* [<span data-ttu-id="3703d-346">案例研究-仔細檢查您實際上的漏洞</span><span class="sxs-lookup"><span data-stu-id="3703d-346">Case study - Looking through holes in your reality</span></span>](case-study-looking-through-holes-in-your-reality.md)
