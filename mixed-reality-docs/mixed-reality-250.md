---
title: 共用 250-HoloLens 和沈浸式耳機 MR
description: 遵循此程式碼逐步解說如何使用 Unity、 Visual Studio、 HoloLens、 及 Windows Mixed Reality 耳機，若要了解共用全像投影混合的實境裝置之間的詳細資料。
author: keveleigh
ms.author: kurtie
ms.date: 03/21/2018
ms.topic: article
keywords: holotoolkit，mixedrealitytoolkit，mixedrealitytoolkit-unity 沉浸式動作控制站、 共用、 xbox 控制器、 網路、 跨裝置
ms.openlocfilehash: 9e1cb0d168b8bf830b4477190516cd19caef7972
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/12/2019
ms.locfileid: "59591227"
---
>[!NOTE]
><span data-ttu-id="f8fdb-104">混合實境 Academy 教學課程的設計與 HoloLens （第 1 代） 及混合實境沈浸式耳機記住。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-104">The Mixed Reality Academy tutorials were designed with HoloLens (1st gen) and Mixed Reality Immersive Headsets in mind.</span></span>  <span data-ttu-id="f8fdb-105">因此，我們覺得很重要的開發人員仍會尋找針對這些裝置進行開發的指引，讓這些教學課程中留在原處。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-105">As such, we feel it is important to leave these tutorials in place for developers who are still looking for guidance in developing for those devices.</span></span>  <span data-ttu-id="f8fdb-106">這些教學課程會**_不_** 使用最新的工具組或用於 HoloLens 2 的互動進行更新。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-106">These tutorials will **_not_** be updated with the latest toolsets or interactions being used for HoloLens 2.</span></span>  <span data-ttu-id="f8fdb-107">它們會繼續運作，支援的裝置上維護。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-107">They will be maintained to continue working on the supported devices.</span></span> <span data-ttu-id="f8fdb-108">會有新教學課程系列，將會公佈在未來，將示範如何開發 HoloLens 2。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-108">There will be a new series of tutorials that will be posted in the future that will demonstrate how to develop for HoloLens 2.</span></span>  <span data-ttu-id="f8fdb-109">當他們回傳時，本聲明將會更新這些教學課程的連結。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-109">This notice will be updated with a link to those tutorials when they are posted.</span></span>

<br>

# <a name="mr-sharing-250-hololens-and-immersive-headsets"></a><span data-ttu-id="f8fdb-110">MR 共用 250:HoloLens 和沈浸式耳機</span><span class="sxs-lookup"><span data-stu-id="f8fdb-110">MR Sharing 250: HoloLens and immersive headsets</span></span>

<span data-ttu-id="f8fdb-111">彈性的通用 Windows 平台 (UWP) 中，很容易就能建立跨越多個裝置的應用程式。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-111">With the flexibility of Universal Windows Platform (UWP), it is easy to create an application that spans multiple devices.</span></span> <span data-ttu-id="f8fdb-112">這種彈性，我們可以建立體驗，運用每個裝置的優點。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-112">With this flexibility, we can create experiences that leverage the strengths of each device.</span></span> <span data-ttu-id="f8fdb-113">本教學課程將涵蓋基本的共用的經驗 HoloLens 與 Windows Mixed Reality 沈浸式耳機上執行。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-113">This tutorial will cover a basic shared experience that runs on both HoloLens and Windows Mixed Reality immersive headsets.</span></span> <span data-ttu-id="f8fdb-114">原本在華盛頓州西雅圖市 Microsoft Build 2017 大會要傳遞此內容。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-114">This content was originally delivered at the Microsoft Build 2017 conference in Seattle, WA.</span></span>

<span data-ttu-id="f8fdb-115">**在本教學課程中，我們將：**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-115">**In this tutorial, we will:**</span></span>

* <span data-ttu-id="f8fdb-116">安裝程式使用 UNET 的網路。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-116">Setup a network using UNET.</span></span>
* <span data-ttu-id="f8fdb-117">在混合的實境裝置之間共用全像投影。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-117">Share holograms across mixed reality devices.</span></span>
* <span data-ttu-id="f8fdb-118">建立依據正在使用混合的實境裝置的應用程式的不同檢視。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-118">Establish a different view of the application depending on which mixed reality device is being used.</span></span>
* <span data-ttu-id="f8fdb-119">建立其中 HoloLens 使用者指南透過一些簡單的謎題的沈浸式耳機使用者分享的經驗。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-119">Create a shared experience where HoloLens users guide immersive headsets users through some simple puzzles.</span></span>

## <a name="device-support"></a><span data-ttu-id="f8fdb-120">裝置支援</span><span class="sxs-lookup"><span data-stu-id="f8fdb-120">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="f8fdb-121">課程</span><span class="sxs-lookup"><span data-stu-id="f8fdb-121">Course</span></span></th><th style="width:150px"> <span data-ttu-id="f8fdb-122"><a href="hololens-hardware-details.md">HoloLens</a></span><span class="sxs-lookup"><span data-stu-id="f8fdb-122"><a href="hololens-hardware-details.md">HoloLens</a></span></span></th><th style="width:150px"> <span data-ttu-id="f8fdb-123"><a href="immersive-headset-hardware-details.md">沈浸式耳機</a></span><span class="sxs-lookup"><span data-stu-id="f8fdb-123"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td><span data-ttu-id="f8fdb-124">MR 共用 250:HoloLens 和沈浸式耳機</span><span class="sxs-lookup"><span data-stu-id="f8fdb-124">MR Sharing 250: HoloLens and immersive headsets</span></span></td><td style="text-align: center;"> <span data-ttu-id="f8fdb-125">✔️</span><span class="sxs-lookup"><span data-stu-id="f8fdb-125">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="f8fdb-126">✔️</span><span class="sxs-lookup"><span data-stu-id="f8fdb-126">✔️</span></span></td>
</tr>
</table>

## <a name="before-you-start"></a><span data-ttu-id="f8fdb-127">開始之前</span><span class="sxs-lookup"><span data-stu-id="f8fdb-127">Before you start</span></span>

### <a name="prerequisites"></a><span data-ttu-id="f8fdb-128">先決條件</span><span class="sxs-lookup"><span data-stu-id="f8fdb-128">Prerequisites</span></span>

* <span data-ttu-id="f8fdb-129">使用 Windows 10 電腦[必要的開發工具](install-the-tools.md)並[設定為支援 Windows Mixed Reality 沈浸式耳機](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-129">A Windows 10 PC with the [necessary development tools](install-the-tools.md) and [configured to support a Windows Mixed Reality immersive headset](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>
* <span data-ttu-id="f8fdb-130">適用於您的 PC Xbox 控制器。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-130">An Xbox controller that works with your PC.</span></span>
* <span data-ttu-id="f8fdb-131">至少一個 HoloLens 裝置和一個沈浸式耳機。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-131">At least one HoloLens device and one immersive headset.</span></span>
* <span data-ttu-id="f8fdb-132">這樣可探索的 UDP 廣播網路。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-132">A network which allows UDP Broadcast for discovery.</span></span>

### <a name="project-files"></a><span data-ttu-id="f8fdb-133">專案檔</span><span class="sxs-lookup"><span data-stu-id="f8fdb-133">Project files</span></span>

* <span data-ttu-id="f8fdb-134">下載[檔案](https://github.com/Microsoft/MixedReality250/archive/master.zip)專案所需。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-134">Download the [files](https://github.com/Microsoft/MixedReality250/archive/master.zip) required by the project.</span></span> <span data-ttu-id="f8fdb-135">將檔案解壓縮至好記的位置。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-135">Extract the files to an easy to remember location.</span></span>
* <span data-ttu-id="f8fdb-136">此專案需要[Unity 的 Windows Mixed Reality 支援與建議的版本](install-the-tools.md)。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-136">This project requires the [a recommended version of Unity with Windows Mixed Reality support](install-the-tools.md).</span></span>

>[!NOTE]
><span data-ttu-id="f8fdb-137">如果您想要查看原始程式碼，在下載之前，它有[可在 GitHub 上](https://github.com/Microsoft/MixedReality250)。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-137">If you want to look through the source code before downloading, it's [available on GitHub](https://github.com/Microsoft/MixedReality250).</span></span>

## <a name="chapter-1---holo-world"></a><span data-ttu-id="f8fdb-138">第 1 章-Holo 世界</span><span class="sxs-lookup"><span data-stu-id="f8fdb-138">Chapter 1 - Holo World</span></span>

>[!VIDEO https://www.youtube.com/embed/IC0rp6rLiEc]

### <a name="objectives"></a><span data-ttu-id="f8fdb-139">目標</span><span class="sxs-lookup"><span data-stu-id="f8fdb-139">Objectives</span></span>

<span data-ttu-id="f8fdb-140">請確定開發環境已準備好開始使用簡單的專案。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-140">Make sure the development environment is ready to go with a simple project.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="f8fdb-141">我們將建置的項目</span><span class="sxs-lookup"><span data-stu-id="f8fdb-141">What we will build</span></span>

<span data-ttu-id="f8fdb-142">應用程式，以顯示雷射 HoloLens 或 Windows Mixed Reality 沈浸式耳機。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-142">An application that shows a hologram on either HoloLens or a Windows Mixed Reality immersive headset.</span></span>

### <a name="steps"></a><span data-ttu-id="f8fdb-143">步驟</span><span class="sxs-lookup"><span data-stu-id="f8fdb-143">Steps</span></span>
* <span data-ttu-id="f8fdb-144">開啟 Unity。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-144">Open Unity.</span></span>
    * <span data-ttu-id="f8fdb-145">選取 **開啟**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-145">Select **Open**.</span></span>
    * <span data-ttu-id="f8fdb-146">瀏覽至您解壓縮專案檔。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-146">Navigate to where you extracted the project files.</span></span>
    * <span data-ttu-id="f8fdb-147">按一下 [選擇資料夾]。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-147">Click **Select Folder**.</span></span>
    * <span data-ttu-id="f8fdb-148">*它會花上一點的第一次處理專案的 Unity 時。*</span><span class="sxs-lookup"><span data-stu-id="f8fdb-148">*It will take a little while for Unity to process the project the first time.*</span></span>
* <span data-ttu-id="f8fdb-149">在 Unity 中，會啟用混合實境的檢查。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-149">Check that Mixed Reality is enabled in Unity.</span></span>
    * <span data-ttu-id="f8fdb-150">開啟 [組建設定] 對話方塊 (**控制 + Shift + B**或**檔案 > 組建設定...**).</span><span class="sxs-lookup"><span data-stu-id="f8fdb-150">Open the build settings dialog (**Control+Shift+B** or **File > Build Settings...**).</span></span>
    * <span data-ttu-id="f8fdb-151">選取 **通用 Windows 平台**然後按一下**切換平台**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-151">Select **Universal Windows Platform** then click **Switch Platform**.</span></span>
    * <span data-ttu-id="f8fdb-152">選取 **編輯 > 播放程式設定**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-152">Select **Edit>Player Settings**.</span></span>
    * <span data-ttu-id="f8fdb-153">在 [ **Inspector**在右手邊] 面板中，展開**XR 設定**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-153">In the **Inspector** panel on the right hand side, expand **XR Settings**.</span></span>
    * <span data-ttu-id="f8fdb-154">請檢查**受支援的虛擬實境** 方塊中。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-154">Check the **Virtual Reality Supported** box.</span></span>
    * <span data-ttu-id="f8fdb-155">*Windows Mixed Reality 應該是虛擬實境 SDK。*</span><span class="sxs-lookup"><span data-stu-id="f8fdb-155">*Windows Mixed Reality should be the Virtual Reality SDK.*</span></span>
* <span data-ttu-id="f8fdb-156">建立場景。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-156">Create a scene.</span></span>
    * <span data-ttu-id="f8fdb-157">在 **階層**以滑鼠右鍵按一下**Main Camera**選取**刪除**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-157">In the **Hierarchy** right click **Main Camera** select **Delete**.</span></span>
    * <span data-ttu-id="f8fdb-158">從**HoloToolkit > 輸入 > Prefabs**拖曳**MixedRealityCameraParent**來**階層**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-158">From **HoloToolkit > Input > Prefabs** drag **MixedRealityCameraParent** to the **Hierarchy**.</span></span>
* <span data-ttu-id="f8fdb-159">新增至場景的全像投影</span><span class="sxs-lookup"><span data-stu-id="f8fdb-159">Add Holograms to the scene</span></span>
    * <span data-ttu-id="f8fdb-160">從**AppPrefabs**拖曳**天空盒**來**場景檢視**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-160">From **AppPrefabs** drag **Skybox** to the **Scene View**.</span></span>
    * <span data-ttu-id="f8fdb-161">從**AppPrefabs**拖曳**經理**來**階層**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-161">From **AppPrefabs** drag **Managers** to the **Hierarchy**.</span></span>
    * <span data-ttu-id="f8fdb-162">從**AppPrefabs**拖曳**島**來**階層**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-162">From **AppPrefabs** drag **Island** to the **Hierarchy**.</span></span>
* <span data-ttu-id="f8fdb-163">儲存並建置</span><span class="sxs-lookup"><span data-stu-id="f8fdb-163">Save And build</span></span>
    * <span data-ttu-id="f8fdb-164">儲存 (任一**Control + S**或是**檔案 > 儲存場景**)</span><span class="sxs-lookup"><span data-stu-id="f8fdb-164">Save (either **Control+S** or **File > Save Scene**)</span></span>
    * <span data-ttu-id="f8fdb-165">由於這是新場景，您必須為它命名。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-165">Since this is a new scene, you'll need to name it.</span></span> <span data-ttu-id="f8fdb-166">名稱並不重要，但我們會使用 SharedMixedReality。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-166">Name doesn't matter, but we use SharedMixedReality.</span></span>
* <span data-ttu-id="f8fdb-167">匯出至 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="f8fdb-167">Export To Visual Studio</span></span>
    * <span data-ttu-id="f8fdb-168">開啟 [建置] 功能表 (**控制 + Shift + B**或是**檔案 > 組建設定**)</span><span class="sxs-lookup"><span data-stu-id="f8fdb-168">Open the build menu (**Control+Shift+B** or **File > Build Settings**)</span></span>
    * <span data-ttu-id="f8fdb-169">按一下 **加入開啟的場景。**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-169">Click **Add Open Scenes.**</span></span>
    * <span data-ttu-id="f8fdb-170">請檢查**UnityC#專案**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-170">Check **Unity C# Projects**</span></span>
    * <span data-ttu-id="f8fdb-171">按一下 [建置] 。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-171">Click **Build**.</span></span>
    * <span data-ttu-id="f8fdb-172">在出現檔案總管 視窗，建立名為的新資料夾**應用程式**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-172">In the file explorer window that appears, create a New Folder named **App**.</span></span>
    * <span data-ttu-id="f8fdb-173">只要按一下**應用程式**資料夾。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-173">Single click the **App** folder.</span></span>
    * <span data-ttu-id="f8fdb-174">按下**選取資料夾。**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-174">Press **Select Folder.**</span></span>
    * <span data-ttu-id="f8fdb-175">**等待建置完成**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-175">**Wait for the build to complete**</span></span>
    * <span data-ttu-id="f8fdb-176">在出現的 [檔案總管] 視窗，瀏覽到**應用程式**資料夾。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-176">In the file explorer window that appears, navigate into the **App** folder.</span></span>
    * <span data-ttu-id="f8fdb-177">按兩下**SharedMixedReality.sln**即可啟動 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="f8fdb-177">Double-click **SharedMixedReality.sln** to launch Visual Studio</span></span>
* <span data-ttu-id="f8fdb-178">從 Visual Studio 建置</span><span class="sxs-lookup"><span data-stu-id="f8fdb-178">Build From Visual Studio</span></span>
    * <span data-ttu-id="f8fdb-179">使用頂端的工具列來變更目標，以便**Release**並**x86**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-179">Using the top toolbar change target to **Release** and **x86**.</span></span>
    * <span data-ttu-id="f8fdb-180">按一下箭號旁**本機電腦**，然後選取**裝置**將部署到 HoloLens</span><span class="sxs-lookup"><span data-stu-id="f8fdb-180">Click the arrow next to **Local Machine** and select **Device** to deploy to HoloLens</span></span>
    * <span data-ttu-id="f8fdb-181">按一下箭號旁**裝置**，然後選取**本機**来部署的混合的實境耳機。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-181">Click the arrow next to **Device** and select **Local Machine** to deploy for the mixed reality headset.</span></span>
    * <span data-ttu-id="f8fdb-182">按一下 **偵錯-> 啟動但不偵錯**或是**控制 + F5**啟動應用程式。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-182">Click **Debug->Start Without Debugging** or **Control+F5** to start the application.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="f8fdb-183">深入探討程式碼</span><span class="sxs-lookup"><span data-stu-id="f8fdb-183">Digging into the code</span></span>

<span data-ttu-id="f8fdb-184">在 [專案] 面板中，瀏覽至**Assets\HoloToolkit\Input\Scripts\Utilities** ，然後按兩下**MixedRealityCameraManager.cs**加以開啟。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-184">In the project panel, navigate to **Assets\HoloToolkit\Input\Scripts\Utilities** and double click **MixedRealityCameraManager.cs** to open it.</span></span>

<span data-ttu-id="f8fdb-185">**概觀：** MixedRealityCameraManager.cs 是簡單的指令碼會根據裝置的品質等級和背景設定進行調整。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-185">**Overview:** MixedRealityCameraManager.cs is a simple script that adjusts quality level and background settings based on the device.</span></span> <span data-ttu-id="f8fdb-186">這是索引鍵，以下是 HolographicSettings.IsDisplayOpaque，可讓指令碼來偵測裝置是否為 HoloLens （IsDisplayOpaque 傳回 false） 或沈浸式用耳機 （IsDisplayOpaque 傳回，則為 true）。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-186">Key here is HolographicSettings.IsDisplayOpaque, which allows a script to detect if the device is a HoloLens (IsDisplayOpaque returns false) or an immersive headset (IsDisplayOpaque returns true).</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="f8fdb-187">享受您的進度</span><span class="sxs-lookup"><span data-stu-id="f8fdb-187">Enjoy your progress</span></span>

<span data-ttu-id="f8fdb-188">此時應用程式將只會呈現全像圖。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-188">At this point the application will just render a hologram.</span></span> <span data-ttu-id="f8fdb-189">我們將在稍後將互動加入全像圖。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-189">We will add interaction to the hologram later.</span></span> <span data-ttu-id="f8fdb-190">這兩個裝置會呈現全像而相同。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-190">Both devices will render the hologram the same.</span></span> <span data-ttu-id="f8fdb-191">沈浸式耳機中還會顯示藍色的天空和雲端背景。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-191">The immersive headset will also render a blue sky and clouds background.</span></span>

## <a name="chapter-2---interaction"></a><span data-ttu-id="f8fdb-192">第 2 章-互動</span><span class="sxs-lookup"><span data-stu-id="f8fdb-192">Chapter 2 - Interaction</span></span>

>[!VIDEO https://www.youtube.com/embed/Lrb1y4sQRvI]

### <a name="objectives"></a><span data-ttu-id="f8fdb-193">目標</span><span class="sxs-lookup"><span data-stu-id="f8fdb-193">Objectives</span></span>

<span data-ttu-id="f8fdb-194">示範如何處理 Windows Mixed Reality 應用程式的輸入。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-194">Show how to handle input for a Windows Mixed Reality application.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="f8fdb-195">我們將建置的項目</span><span class="sxs-lookup"><span data-stu-id="f8fdb-195">What we will build</span></span>

<span data-ttu-id="f8fdb-196">基礎第 1 章應用程式，我們會新增功能，可讓使用者挑選全像圖，並將它放一份虛擬資料表中的沈浸式耳機或 HoloLens 的真實世界平面上。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-196">Building on the application from chapter 1, we will add functionality to allow the user to pick up the hologram and place it on a real world surface in HoloLens or on a virtual table in an immersive headset.</span></span>

<span data-ttu-id="f8fdb-197">**輸入的重新整理程式：** 選取的動作是 HoloLens 上**空中點選**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-197">**Input Refresher:** On HoloLens the select gesture is the **air tap**.</span></span> <span data-ttu-id="f8fdb-198">在沉浸式耳機，我們將使用**A** Xbox 控制器上的按鈕。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-198">On immersive headsets, we will use the **A** button on the Xbox controller.</span></span> <span data-ttu-id="f8fdb-199">如需有關輸入[從這裡開始](gestures.md)。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-199">For more information on input [start here](gestures.md).</span></span>

### <a name="steps"></a><span data-ttu-id="f8fdb-200">步驟</span><span class="sxs-lookup"><span data-stu-id="f8fdb-200">Steps</span></span>
* <span data-ttu-id="f8fdb-201">新增輸入管理員</span><span class="sxs-lookup"><span data-stu-id="f8fdb-201">Add Input manager</span></span>
    * <span data-ttu-id="f8fdb-202">從**HoloToolkit > 輸入 > Prefabs**拖曳**InputManager**來**階層**為子系**管理員**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-202">From **HoloToolkit > Input > Prefabs** drag **InputManager** to **Hierarchy** as a child of **Managers**.</span></span>
    * <span data-ttu-id="f8fdb-203">從**HoloToolkit > 輸入 > Prefabs > 資料指標**拖曳**游標**來**階層**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-203">From **HoloToolkit > Input > Prefabs > Cursor** drag **Cursor** to **Hierarchy**.</span></span>
* <span data-ttu-id="f8fdb-204">新增空間對應</span><span class="sxs-lookup"><span data-stu-id="f8fdb-204">Add Spatial Mapping</span></span>
    * <span data-ttu-id="f8fdb-205">從**HoloToolkit > SpatialMapping > Prefabs**拖曳**SpatialMapping**來**階層**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-205">From **HoloToolkit > SpatialMapping > Prefabs** drag **SpatialMapping** to **Hierarchy**.</span></span>
* <span data-ttu-id="f8fdb-206">新增虛擬 Playspace</span><span class="sxs-lookup"><span data-stu-id="f8fdb-206">Add Virtual Playspace</span></span>
    * <span data-ttu-id="f8fdb-207">在 **階層**展開**MixedRealityCameraParent**選取**界限**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-207">In **Hierarchy** expand **MixedRealityCameraParent** select **Boundary**</span></span>
    * <span data-ttu-id="f8fdb-208">在  **Inspector**面板核取此方塊可啟用**界限**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-208">In **Inspector** panel check the box to enable **Boundary**</span></span>
    * <span data-ttu-id="f8fdb-209">從**AppPrefabs**拖曳**VRRoom**來**階層**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-209">From **AppPrefabs** drag **VRRoom** to **Hierarchy**.</span></span>
* <span data-ttu-id="f8fdb-210">新增 WorldAnchorManager</span><span class="sxs-lookup"><span data-stu-id="f8fdb-210">Add WorldAnchorManager</span></span>
    * <span data-ttu-id="f8fdb-211">在 **階層**，選取**管理員**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-211">In **Hierarchy**, Select **Managers**.</span></span>
    * <span data-ttu-id="f8fdb-212">在  **Inspector**，按一下**新增元件**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-212">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="f8fdb-213">型別**世界錨點 Manager**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-213">Type **World Anchor Manager**.</span></span>
    * <span data-ttu-id="f8fdb-214">選取 **世界錨點 Manager**將它加入。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-214">Select **World Anchor Manager** to add it.</span></span>
* <span data-ttu-id="f8fdb-215">新增 TapToPlace 島</span><span class="sxs-lookup"><span data-stu-id="f8fdb-215">Add TapToPlace to the Island</span></span>
    * <span data-ttu-id="f8fdb-216">在 **階層**，展開**島**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-216">In **Hierarchy**, expand **Island**.</span></span>
    * <span data-ttu-id="f8fdb-217">選取  **MixedRealityLand**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-217">Select **MixedRealityLand**.</span></span>
    * <span data-ttu-id="f8fdb-218">在  **Inspector**，按一下**新增元件**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-218">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="f8fdb-219">型別**點選到另一個地方**並加以選取。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-219">Type **Tap To Place** and select it.</span></span>
    * <span data-ttu-id="f8fdb-220">請檢查**父置於點選**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-220">Check **Place Parent On Tap**.</span></span>
    * <span data-ttu-id="f8fdb-221">設定**放置位移**要 **（0、 0.1，0）**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-221">Set **Placement Offset** to **(0, 0.1, 0)**.</span></span>
* <span data-ttu-id="f8fdb-222">儲存並建置和以前一樣</span><span class="sxs-lookup"><span data-stu-id="f8fdb-222">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="f8fdb-223">深入探討程式碼</span><span class="sxs-lookup"><span data-stu-id="f8fdb-223">Digging into the code</span></span>

<span data-ttu-id="f8fdb-224">**Script 1 - GamepadInput.cs**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-224">**Script 1 - GamepadInput.cs**</span></span>

<span data-ttu-id="f8fdb-225">在 [專案] 面板中，巡覽至**Assets\HoloToolkit\Input\Scripts\InputSources** ，然後按兩下**GamepadInput.cs**加以開啟。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-225">In the project panel navigate to **Assets\HoloToolkit\Input\Scripts\InputSources** and double click **GamepadInput.cs** to open it.</span></span> <span data-ttu-id="f8fdb-226">從 [專案] 面板中相同的路徑，也按兩下**InteractionSourceInputSource.cs**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-226">From the same path in the project panel, also double click **InteractionSourceInputSource.cs**.</span></span>

<span data-ttu-id="f8fdb-227">請注意，這兩個指令碼常見的基底類別，稱為 BaseInputSource。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-227">Note that both scripts have a common base class, BaseInputSource.</span></span>

<span data-ttu-id="f8fdb-228">BaseInputSource 會保留 InputManager，讓觸發程序事件的指令碼的參考。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-228">BaseInputSource keeps a reference to an InputManager, which allows a script to trigger events.</span></span> <span data-ttu-id="f8fdb-229">在此情況下，InputClicked 事件無關。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-229">In this case, the InputClicked event is relevant.</span></span> <span data-ttu-id="f8fdb-230">這會是一定要記住，當我們要編寫指令碼 2 TapToPlace 時。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-230">This will be important to remember when we get to script 2, TapToPlace.</span></span> <span data-ttu-id="f8fdb-231">如果 GamePadInput，是我們輪詢被按下控制器上的按鈕，然後我們引發 InputClicked 事件。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-231">In the case of GamePadInput, we poll for the A button on the controller to be pressed, then we raise the InputClicked event.</span></span> <span data-ttu-id="f8fdb-232">在 InteractionSourceInputSource，我們會引發以回應 TappedEvent InputClicked 事件。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-232">In the case of InteractionSourceInputSource, we raise the InputClicked event in response to the TappedEvent.</span></span>

<span data-ttu-id="f8fdb-233">**指令碼 2-TapToPlace.cs**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-233">**Script 2 - TapToPlace.cs**</span></span>

<span data-ttu-id="f8fdb-234">在 [專案] 面板中，巡覽至**Assets\HoloToolkit\SpatialMapping\Scripts** ，然後按兩下**TapToPlace.cs**加以開啟。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-234">In the project panel navigate to **Assets\HoloToolkit\SpatialMapping\Scripts** and double click **TapToPlace.cs** to open it.</span></span>

<span data-ttu-id="f8fdb-235">許多開發人員想要實作建立全像攝影版的應用程式時第一件事將全像投影移筆勢輸入。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-235">The first thing many developers want to implement when creating a Holographic application is moving Holograms with gesture input.</span></span> <span data-ttu-id="f8fdb-236">因此，我們已 endeavored 徹底註解此指令碼。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-236">As such, we've endeavored to thoroughly comment this script.</span></span> <span data-ttu-id="f8fdb-237">幾件事是值得的本教學課程中反白顯示。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-237">A few things are worth highlighting for this tutorial.</span></span>

<span data-ttu-id="f8fdb-238">首先，請注意 TapToPlace 實作 IInputClickHandler。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-238">First, note that TapToPlace implements IInputClickHandler.</span></span> <span data-ttu-id="f8fdb-239">IInputClickHandler 公開處理 GamePadInput.cs 或 InteractionSourceInputSource.cs 引發 InputClicked 事件的函式。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-239">IInputClickHandler exposes the functions that handle the InputClicked event raised by GamePadInput.cs or InteractionSourceInputSource.cs.</span></span> <span data-ttu-id="f8fdb-240">OnInputClicked 時 BaseInputSource 偵測到按一下 TapToPlace 物件處於焦點時呼叫。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-240">OnInputClicked is called when a BaseInputSource detects a click while the object with TapToPlace is in focus.</span></span> <span data-ttu-id="f8fdb-241">是空中點選上 HoloLens 或 Xbox 控制器上按下的按鈕會觸發此事件。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-241">Either airtapping on HoloLens or pressing the A button on the Xbox controller will trigger the event.</span></span>

<span data-ttu-id="f8fdb-242">第二個是會執行的程式碼，請參閱是否介面正在進行調查讓我們可以將遊戲物件放在介面上，例如資料表的更新中。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-242">Second is the code be executed in update to see if a surface is being looked at so we can place the game object on a surface, like a table.</span></span> <span data-ttu-id="f8fdb-243">沈浸式耳機沒有概念，以實際的介面，因此表示資料表頂端的物件 (Vroom > TableThingy > Cube) 已標有 SpatialMapping 物理圖層，因此光線轉換更新中將使用虛擬資料表的最上層相衝突。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-243">The immersive headset doesn't have a concept of real surfaces, so the object that represents the table top (Vroom > TableThingy > Cube) has been marked with the SpatialMapping physics layer, so the ray cast in Update will collide with the virtual table top.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="f8fdb-244">享受您的進度</span><span class="sxs-lookup"><span data-stu-id="f8fdb-244">Enjoy your progress</span></span>

<span data-ttu-id="f8fdb-245">此時您可以選取，將它移島。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-245">This time you can select the island to move it.</span></span> <span data-ttu-id="f8fdb-246">HoloLens 您可以將島移到實際的介面。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-246">On HoloLens you can move the island to a real surface.</span></span> <span data-ttu-id="f8fdb-247">在沉浸式耳機中，您可以移動島我們新增的虛擬資料表。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-247">In the immersive headset you can move the island to the virtual table we added.</span></span>

## <a name="chapter-3---sharing"></a><span data-ttu-id="f8fdb-248">第 3 章-共用</span><span class="sxs-lookup"><span data-stu-id="f8fdb-248">Chapter 3 - Sharing</span></span>

>[!VIDEO https://www.youtube.com/embed/1diycJvxfDc]

### <a name="objectives"></a><span data-ttu-id="f8fdb-249">目標</span><span class="sxs-lookup"><span data-stu-id="f8fdb-249">Objectives</span></span>

<span data-ttu-id="f8fdb-250">確定已正確設定網路，並詳細說明如何空間的錨點會在裝置之間共用。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-250">Ensure that the network is correctly configured and detail how spatial anchors are shared between devices.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="f8fdb-251">我們將建置的項目</span><span class="sxs-lookup"><span data-stu-id="f8fdb-251">What we will build</span></span>

<span data-ttu-id="f8fdb-252">我們會將我們的專案轉換成多人遊戲的專案。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-252">We will convert our project to a multiplayer project.</span></span> <span data-ttu-id="f8fdb-253">我們會將 UI 和邏輯新增至主機或聯結的工作階段。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-253">We will add UI and logic to host or join sessions.</span></span> <span data-ttu-id="f8fdb-254">HoloLens 使用者會在其標頭中，透過與雲端工作階段中彼此看到和沈浸式耳機使用者有接近錨點所在的雲端。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-254">HoloLens users will see each other in the session with clouds over their heads, and immersive headset users have clouds near to where the anchor is.</span></span> <span data-ttu-id="f8fdb-255">沈浸式耳機中的使用者會看到 HoloLens 使用者相對於場景的原點。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-255">Users in the immersive headsets will see the HoloLens users relative to the origin of the scene.</span></span> <span data-ttu-id="f8fdb-256">HoloLens 使用者會看到相同的位置島的全像圖。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-256">HoloLens users will all see the hologram of the island in the same place.</span></span> <span data-ttu-id="f8fdb-257">它是關鍵請注意，沈浸式耳機中的使用者將無法島上在本章中，但將的運作方式非常類似 HoloLens，與島俯瞰檢視。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-257">It is key to note that the users in the immersive headsets will not be on the island during this chapter, but will behave very similarly to HoloLens, with a birds eye view of the island.</span></span>

### <a name="steps"></a><span data-ttu-id="f8fdb-258">步驟</span><span class="sxs-lookup"><span data-stu-id="f8fdb-258">Steps</span></span>
* <span data-ttu-id="f8fdb-259">移除島及 VRRoom</span><span class="sxs-lookup"><span data-stu-id="f8fdb-259">Remove Island and VRRoom</span></span>
    * <span data-ttu-id="f8fdb-260">在 **階層**上按一下滑鼠右鍵**島**選取**刪除**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-260">In **Hierarchy** right-click **Island** select **Delete**</span></span>
    * <span data-ttu-id="f8fdb-261">在 **階層**上按一下滑鼠右鍵**VRRoom**選取**刪除**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-261">In **Hierarchy** right-click **VRRoom** select **Delete**</span></span>
* <span data-ttu-id="f8fdb-262">新增 Usland</span><span class="sxs-lookup"><span data-stu-id="f8fdb-262">Add Usland</span></span>
    * <span data-ttu-id="f8fdb-263">從**AppPrefabs**拖曳**Usland**來**階層**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-263">From **AppPrefabs** drag **Usland** to **Hierarchy**.</span></span>
* <span data-ttu-id="f8fdb-264">從**AppPrefabs**拖曳到下列每個**階層**:</span><span class="sxs-lookup"><span data-stu-id="f8fdb-264">From **AppPrefabs** drag each of the following to **Hierarchy**:</span></span>
    * <span data-ttu-id="f8fdb-265">**UNETSharingStage**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-265">**UNETSharingStage**</span></span>
    * <span data-ttu-id="f8fdb-266">**UNetAnchorRoot**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-266">**UNetAnchorRoot**</span></span>
    * <span data-ttu-id="f8fdb-267">**UIContainer**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-267">**UIContainer**</span></span>
    * <span data-ttu-id="f8fdb-268">**DebugPanelButton**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-268">**DebugPanelButton**</span></span>
* <span data-ttu-id="f8fdb-269">儲存並建置和以前一樣</span><span class="sxs-lookup"><span data-stu-id="f8fdb-269">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="f8fdb-270">深入探討程式碼</span><span class="sxs-lookup"><span data-stu-id="f8fdb-270">Digging into the code</span></span>

<span data-ttu-id="f8fdb-271">在 [專案] 面板中，瀏覽至**Assets\AppPrefabs\Support\SharingWithUnet\Scripts** ，然後按兩下**UnetAnchorManager.cs**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-271">In the project panel, navigate to **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** and double-click on **UnetAnchorManager.cs**.</span></span> <span data-ttu-id="f8fdb-272">將追蹤資訊分享另一個 HoloLens，使得這兩個裝置都可以共用相同的空間的一個 HoloLens 讓即將神奇。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-272">The ability for one HoloLens to share tracking information with another HoloLens such that both devices can share the same space is near magical.</span></span> <span data-ttu-id="f8fdb-273">混合實境的強大功能會保持運作，當兩個或更多人可以使用相同的數位資料共同作業。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-273">The power of mixed reality comes alive when two or more people can collaborate using the same digital data.</span></span>

<span data-ttu-id="f8fdb-274">指出此指令碼中的幾件事：</span><span class="sxs-lookup"><span data-stu-id="f8fdb-274">A few things to point out in this script:</span></span>

<span data-ttu-id="f8fdb-275">在開始函式，請注意檢查**IsDisplayOpaque**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-275">In the start function, notice the check for **IsDisplayOpaque**.</span></span> <span data-ttu-id="f8fdb-276">在此情況下，我們會假裝會建立錨點。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-276">In this case, we pretend that the Anchor is established.</span></span> <span data-ttu-id="f8fdb-277">這是因為沈浸式耳機不會公開匯入或匯出的錨點的方式。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-277">This is because the immersive headsets do not expose a way to import or export anchors.</span></span> <span data-ttu-id="f8fdb-278">如果我們 HoloLens 上執行，不過，此指令碼會實作在裝置之間共用的錨點。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-278">If we are running on a HoloLens, however, this script implements sharing anchors between the devices.</span></span> <span data-ttu-id="f8fdb-279">啟動工作階段的裝置將會建立匯出的錨點。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-279">The device that starts the session will create an anchor for exporting.</span></span> <span data-ttu-id="f8fdb-280">裝置加入工作階段時，會要求從裝置啟動工作階段的錨點。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-280">The device that joins a session will request the anchor from the device that started the session.</span></span>

<span data-ttu-id="f8fdb-281">**匯出：**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-281">**Exporting:**</span></span>

<span data-ttu-id="f8fdb-282">當使用者建立工作階段時，NetworkDiscoveryWithAnchors 會呼叫 UNETAnchorManagers CreateAnchor 函式。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-282">When a user creates a session, NetworkDiscoveryWithAnchors will call UNETAnchorManagers CreateAnchor function.</span></span> <span data-ttu-id="f8fdb-283">讓我們遵循 CreateAnchor 流程。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-283">Let's follow CreateAnchor flow.</span></span>

<span data-ttu-id="f8fdb-284">我們先進行一些內部管理工作，我們可能會收集前一個錨點的任何資料清除。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-284">We start by doing some housekeeping, clearing out any data we may have collected for previous anchors.</span></span> <span data-ttu-id="f8fdb-285">然後我們會檢查是否有快取的錨點，來載入。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-285">Then we check if there is a cached anchor to load.</span></span> <span data-ttu-id="f8fdb-286">錨點的資料通常會介於 5 到 20 MB，以便重複使用快取的錨點儲存我們需要透過網路傳送的資料量。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-286">The anchor data tends to be between 5 and 20 MB, so reusing cached anchors can save on the amount of data we need to transfer over the network.</span></span> <span data-ttu-id="f8fdb-287">我們會看到其運作方式稍待片刻。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-287">We'll see how this works a bit later.</span></span> <span data-ttu-id="f8fdb-288">即使我們要重複使用錨點，我們需要取得備妥資料以防新用戶端所加入的沒有錨點錨點。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-288">Even if we are reusing the anchor, we need to get the anchor data ready in case a new client joins that doesn't have the anchor.</span></span>

<span data-ttu-id="f8fdb-289">說到備妥錨點的資料，則 WorldAnchorTransferBatch 類別會公開以準備錨點的資料傳送至另一個裝置或應用程式和功能的錨點的資料匯入的功能。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-289">Speaking of getting the anchor data ready, the WorldAnchorTransferBatch class exposes the functionality to prepare anchor data for sending to another device or application and the functionality to import the anchor data.</span></span> <span data-ttu-id="f8fdb-290">因為我們在匯出路徑上，我們會將我們的錨點加入至 WorldAnchorTransferBatch，並呼叫 ExportAsync 函式。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-290">Since we're on the export path, we will add our anchor to the WorldAnchorTransferBatch and call the ExportAsync function.</span></span> <span data-ttu-id="f8fdb-291">ExportAsync 會接著呼叫 WriteBuffer 回呼，它會產生匯出的資料。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-291">ExportAsync will then call the WriteBuffer callback as it generates data for export.</span></span> <span data-ttu-id="f8fdb-292">已匯出的所有資料時，就會呼叫 ExportComplete。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-292">When all of the data has been exported ExportComplete will be called.</span></span> <span data-ttu-id="f8fdb-293">在 WriteBuffer 我們加入資料的區塊的清單，我們會保留用於匯出。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-293">In WriteBuffer we add the chunk of data to a list we keep for exporting.</span></span> <span data-ttu-id="f8fdb-294">ExportComplete 中我們將清單轉換為陣列。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-294">In ExportComplete we convert the list to an array.</span></span> <span data-ttu-id="f8fdb-295">AnchorName 也設定變數，這將會觸發其他裝置來要求錨點，不需要它。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-295">The AnchorName variable is also set, which will trigger other devices to request the anchor if they don't have it.</span></span>

<span data-ttu-id="f8fdb-296">在某些情況下，不會匯出錨點，或將建立這麼少的資料，我們會再試一次。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-296">In some cases the anchor won't export or will create so little data that we will try again.</span></span> <span data-ttu-id="f8fdb-297">這裡我們只需要呼叫 CreateAnchor 一次。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-297">Here we just call CreateAnchor again.</span></span>

<span data-ttu-id="f8fdb-298">在匯出路徑的最後一個函式是 AnchorFoundRemotely。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-298">A final function in the export path is AnchorFoundRemotely.</span></span> <span data-ttu-id="f8fdb-299">當其他裝置找到錨點時，該裝置將會通知主機和主機將會使用它做為錨點是 「 良好錨點 」 的訊號，並可以快取。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-299">When another device finds the anchor, that device will tell the host, and the host will use that as a signal that the anchor is a "good anchor" and can be cached.</span></span>

<span data-ttu-id="f8fdb-300">**匯入：**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-300">**Importing:**</span></span>

<span data-ttu-id="f8fdb-301">當 HoloLens 加入工作階段時，它需要匯入錨點。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-301">When a HoloLens joins a session, it needs to import an anchor.</span></span> <span data-ttu-id="f8fdb-302">在 UNETAnchorManager 的更新函式，AnchorName 輪詢一次。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-302">In UNETAnchorManager's Update function, the AnchorName is polled.</span></span> <span data-ttu-id="f8fdb-303">當錨定名稱變更時，便會開始匯入程序。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-303">When the anchor name changes, the import process begins.</span></span> <span data-ttu-id="f8fdb-304">首先，我們會試著從本機的錨點存放區載入具有指定名稱的錨點。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-304">First, we try to load the anchor with the specified name from the local anchor store.</span></span> <span data-ttu-id="f8fdb-305">如果我們還沒有它，我們可以使用它，而不需要再次下載資料。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-305">If we already have it, we can use it without downloading the data again.</span></span> <span data-ttu-id="f8fdb-306">如果我們沒有它，然後我們會呼叫 WaitForAnchor 這會起始下載。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-306">If we don't have it, then we call WaitForAnchor which will initiate the download.</span></span>

<span data-ttu-id="f8fdb-307">當下載完成時，會呼叫 NetworkTransmitter_dataReadyEvent。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-307">When the download is completed, NetworkTransmitter_dataReadyEvent is called.</span></span> <span data-ttu-id="f8fdb-308">這會指示使用下載的資料呼叫 ImportAsync Update 迴圈。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-308">This will signal the Update loop to call ImportAsync with the downloaded data.</span></span> <span data-ttu-id="f8fdb-309">ImportAsync 匯入程序完成時，會呼叫 ImportComplete。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-309">ImportAsync will call ImportComplete when the import process is complete.</span></span> <span data-ttu-id="f8fdb-310">如果匯入成功時，錨點會儲存在本機的播放程式存放區中。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-310">If the import is successful, the anchor will be saved in the local player store.</span></span> <span data-ttu-id="f8fdb-311">PlayerController.cs 實際上是 AnchorFoundRemotely 的呼叫，讓主機知道確實已建立好的錨點。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-311">PlayerController.cs actually makes the call to AnchorFoundRemotely to let the host know that a good anchor has been established.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="f8fdb-312">享受您的進度</span><span class="sxs-lookup"><span data-stu-id="f8fdb-312">Enjoy your progress</span></span>

<span data-ttu-id="f8fdb-313">這次的使用者與 HoloLens 將主控工作階段，使用**啟動工作階段**在 UI 中的按鈕。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-313">This time a user with a HoloLens will host a session using the **start session** button in the UI.</span></span> <span data-ttu-id="f8fdb-314">其他使用者，同時在 HoloLens 或沈浸式耳機，將選取的工作階段，然後選取**收聽廣播**在 UI 中的按鈕。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-314">Other users, both on HoloLens or an immersive headset, will select the session and then select the **join session** button in the UI.</span></span> <span data-ttu-id="f8fdb-315">如果您有多人與 HoloLens 裝置時，他們將會對它們的頭來紅色的雲端。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-315">If you have multiple people with HoloLens devices, they will have red clouds over their heads.</span></span> <span data-ttu-id="f8fdb-316">也會針對每個沈浸式耳機，藍色定域機組，但藍色的雲端不會高於耳機，耳機未嘗試尋找為 HoloLens 裝置相同的全局座標空間。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-316">There will also be a blue cloud for each immersive headset, but the blue clouds will not be above the headsets, as the headsets are not trying to find the same world coordinate space as the HoloLens devices.</span></span>

<span data-ttu-id="f8fdb-317">此專案中的點是自主的共用應用程式中;它不會執行很多，無法做為基準。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-317">This point in the project is a contained sharing application; it doesn't do very much, and could act as a baseline.</span></span> <span data-ttu-id="f8fdb-318">在下一個章節中，我們將開始建置可享受的人的體驗。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-318">In the next chapters, we will start building an experience for people to enjoy.</span></span> <span data-ttu-id="f8fdb-319">若要取得進一步分享的經驗設計指導方針，請前往這裡。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-319">To get further guidance on shared experience design, go here.</span></span>

## <a name="chapter-4---immersion-and-teleporting"></a><span data-ttu-id="f8fdb-320">第 4 章-Immersion 和 teleporting</span><span class="sxs-lookup"><span data-stu-id="f8fdb-320">Chapter 4 - Immersion and teleporting</span></span>

>[!VIDEO https://www.youtube.com/embed/kUHZ5tCOfvY]

### <a name="objectives"></a><span data-ttu-id="f8fdb-321">目標</span><span class="sxs-lookup"><span data-stu-id="f8fdb-321">Objectives</span></span>

<span data-ttu-id="f8fdb-322">在供應給其他每一種混合的實境裝置的使用經驗。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-322">Cater the experience to each type of mixed reality device.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="f8fdb-323">我們將建置的項目</span><span class="sxs-lookup"><span data-stu-id="f8fdb-323">What we will build</span></span>

<span data-ttu-id="f8fdb-324">我們將更新的沈浸式檢視島上放置沈浸式耳機使用者應用程式。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-324">We will update the application to put immersive headset users on the island with an immersive view.</span></span> <span data-ttu-id="f8fdb-325">HoloLens 使用者仍然可以島的鳥瞰檢視。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-325">HoloLens users will still have the bird's eye view of the island.</span></span> <span data-ttu-id="f8fdb-326">濆婞剢謅世界，每種裝置類型的使用者可以看到其他使用者。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-326">Users of each device type can see other users as they appear in the world.</span></span> <span data-ttu-id="f8fdb-327">比方說，沈浸式耳機使用者可以看到其他的虛擬人偶島上的其他路徑上，也高於島的巨大雲端查看 HoloLens 使用者。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-327">For instance, immersive headset users can see the other avatars on other paths on the island, and they see the HoloLens users as giant clouds above the island.</span></span> <span data-ttu-id="f8fdb-328">如果 HoloLens 使用者查看島，沈浸式耳機使用者也會看到 資料指標的 HoloLens 使用者的視線光線。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-328">Immersive headset users will also see the cursor of the HoloLens user's gaze ray if the HoloLens user is looking at the island.</span></span> <span data-ttu-id="f8fdb-329">HoloLens 使用者會看到顯示圖片，來代表每個沈浸式耳機使用者島上。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-329">HoloLens users will see an avatar on the island to represent each immersive headset user.</span></span>

<span data-ttu-id="f8fdb-330">**沈浸式裝置的更新的輸入：**</span><span class="sxs-lookup"><span data-stu-id="f8fdb-330">**Updated Input for the Immersive device:**</span></span>
* <span data-ttu-id="f8fdb-331">Xbox 控制器上的左動和權限動按鈕旋轉播放程式</span><span class="sxs-lookup"><span data-stu-id="f8fdb-331">The left bumper and right bumper buttons on the Xbox controller rotate the player</span></span>
* <span data-ttu-id="f8fdb-332">保留在 Xbox 控制器上的 [Y] 按鈕可讓[傳送](navigating-the-windows-mixed-reality-home.md#getting-around-your-home)資料指標。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-332">Holding the Y button on the Xbox controller will enable a [teleport](navigating-the-windows-mixed-reality-home.md#getting-around-your-home) cursor.</span></span> <span data-ttu-id="f8fdb-333">如果資料指標有旋轉箭號指示器，當您放開 [Y] 按鈕時，您將會 teleported 資料指標的位置。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-333">If the cursor has a spinning arrow indicator when you release the Y button, you will be teleported to the cursor's location.</span></span>

### <a name="steps"></a><span data-ttu-id="f8fdb-334">步驟</span><span class="sxs-lookup"><span data-stu-id="f8fdb-334">Steps</span></span>
* <span data-ttu-id="f8fdb-335">加入 MixedRealityCameraParent MixedRealityTeleport</span><span class="sxs-lookup"><span data-stu-id="f8fdb-335">Add MixedRealityTeleport to MixedRealityCameraParent</span></span>
    * <span data-ttu-id="f8fdb-336">在 **階層**，選取**Usland**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-336">In **Hierarchy**, select **Usland**.</span></span>
    * <span data-ttu-id="f8fdb-337">在  **Inspector**，讓**層級控制**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-337">In **Inspector**, enable **Level Control**.</span></span>
    * <span data-ttu-id="f8fdb-338">在 **階層**，選取**MixedRealityCameraParent**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-338">In **Hierarchy**, select **MixedRealityCameraParent**.</span></span>
    * <span data-ttu-id="f8fdb-339">在  **Inspector**，按一下**新增元件**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-339">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="f8fdb-340">型別**混合實境傳送**並加以選取。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-340">Type **Mixed Reality Teleport** and select it.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="f8fdb-341">深入探討程式碼</span><span class="sxs-lookup"><span data-stu-id="f8fdb-341">Digging into the code</span></span>

<span data-ttu-id="f8fdb-342">將行動網卡沈浸式耳機使用者，其電腦透過纜線，但我們島大於纜線過長。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-342">Immersive headset users will be tethered to their PCs with a cable, but our island is larger than the cable is long.</span></span> <span data-ttu-id="f8fdb-343">為了彌補，我們需要能夠移動觀景窗獨立於使用者的動作。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-343">To compensate, we need the ability to move the camera independently of the user's motion.</span></span> <span data-ttu-id="f8fdb-344">請參閱[緩和頁面](comfort.md)如需有關設計混合的實境應用程式 （特別是本身的影片和 locomotion）。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-344">Please see the [comfort page](comfort.md) for more information about designing your mixed reality application (in particular self motion and locomotion).</span></span>

<span data-ttu-id="f8fdb-345">為了說明此程序很適合用來定義兩個詞彙。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-345">In order to describe this process it will be useful to define two terms.</span></span> <span data-ttu-id="f8fdb-346">首先， **dolly**會是從使用者的個別移動觀景窗的物件。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-346">First, **dolly** will be the object that moves the camera independently from the user.</span></span> <span data-ttu-id="f8fdb-347">子系遊戲物件**dolly**會**主攝影機**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-347">A child game object of the **dolly** will be the **main camera**.</span></span> <span data-ttu-id="f8fdb-348">主攝影機會附加至使用者的大腦。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-348">The main camera is attached to the user's head.</span></span>

<span data-ttu-id="f8fdb-349">在 [專案] 面板中，瀏覽至**Assets\AppPrefabs\Support\Scripts\GameLogic** ，然後按兩下**MixedRealityTeleport.cs**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-349">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **MixedRealityTeleport.cs**.</span></span>

<span data-ttu-id="f8fdb-350">MixedRealityTeleport 有兩項作業。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-350">MixedRealityTeleport has two jobs.</span></span> <span data-ttu-id="f8fdb-351">首先，它會處理使用轉場廣告旋轉的動畫。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-351">First, it handles rotation using the bumpers.</span></span> <span data-ttu-id="f8fdb-352">更新函式中我們輪詢 'ButtonUp' LeftBumper 和 RightBumper 上。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-352">In the update function we poll for 'ButtonUp' on LeftBumper and RightBumper.</span></span> <span data-ttu-id="f8fdb-353">GetButtonUp 只會傳回 true 按鈕已啟動，處於已關閉之後的第一個畫面上。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-353">GetButtonUp only returns true on the first frame a button is up after having been down.</span></span> <span data-ttu-id="f8fdb-354">如果任一個按鈕引發，我們便知道使用者要旋轉。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-354">If either button had been raised, then we know the user needs to rotate.</span></span>

<span data-ttu-id="f8fdb-355">我們旋轉時我們執行淡及淡入使用稱為 'fade 控制項' 的簡單指令碼。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-355">When we rotate we do a fade out and fade in using a simple script called 'fade control'.</span></span> <span data-ttu-id="f8fdb-356">我們這樣做可以防止使用者看到這可能導致 discomfort 非自然移動。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-356">We do this to prevent the user from seeing an unnatural movement which could lead to discomfort.</span></span> <span data-ttu-id="f8fdb-357">淡入和登出效果都相當簡單。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-357">The fade in and out effect is fairly simple.</span></span> <span data-ttu-id="f8fdb-358">我們有黑色四組數字前面溢出**主攝影機**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-358">We have a black quad hanging in front of the **main camera**.</span></span> <span data-ttu-id="f8fdb-359">當淡出轉換從 0 到 1 的 alpha 值。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-359">When fading out we transition the alpha value from 0 to 1.</span></span> <span data-ttu-id="f8fdb-360">逐漸，這會使用於轉譯並遮蔽其後的任何項目四黑色像素。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-360">This gradually causes the black pixels of the quad to render and obscure anything behind them.</span></span> <span data-ttu-id="f8fdb-361">當漸淡入轉換的 alpha 值設回零。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-361">When fading back in we transition the alpha value back to zero.</span></span>

<span data-ttu-id="f8fdb-362">當我們計算旋轉時，請注意，我們要輪替我們**dolly**但計算繞著旋轉**主攝影機**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-362">When we calculate the rotation, note that we are rotating our **dolly** but calculating the rotation around the **main camera**.</span></span> <span data-ttu-id="f8fdb-363">這相當重要，因為較遠**主攝影機**不 0,0,0，較不精確 dolly 旋轉會變成從使用者的觀點來看。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-363">This is important as the farther the **main camera** is away from 0,0,0, the less accurate a rotation around the dolly would become from the point of view of the user.</span></span> <span data-ttu-id="f8fdb-364">事實上，如果您不會旋轉觀景窗位置周圍，則使用者將會在弧線周圍移動**dolly**而不是旋轉。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-364">In fact, if you do not rotate around the camera position, the user will move on an arc around the **dolly** rather than rotating.</span></span>

<span data-ttu-id="f8fdb-365">MixedRealityTeleport 的第二個工作是處理移動**dolly**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-365">The second job for MixedRealityTeleport is to handle moving the **dolly**.</span></span> <span data-ttu-id="f8fdb-366">這是 SetWorldPosition。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-366">This is done in SetWorldPosition.</span></span> <span data-ttu-id="f8fdb-367">SetWorldPosition 會採用所需的世界空間位置，而使用者想要它們所佔的 percieve 的所在位置。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-367">SetWorldPosition takes the desired world position, the position where the user wants to percieve that they inhabit.</span></span> <span data-ttu-id="f8fdb-368">我們需要把我們**dolly**該位置的本機位置減去**主攝影機**、 為每個畫面格會新增該位移。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-368">We need to put our **dolly** at that position minus the local position of the **main camera**, as that offset will be added each frame.</span></span>

<span data-ttu-id="f8fdb-369">第二個指令碼會呼叫 SetWorldPosition。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-369">A second script calls SetWorldPosition.</span></span> <span data-ttu-id="f8fdb-370">讓我們看看該指令碼。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-370">Let's look at that script.</span></span> <span data-ttu-id="f8fdb-371">在 [專案] 面板中，瀏覽至**Assets\AppPrefabs\Support\Scripts\GameLogic** ，然後按兩下**TeleportScript.cs**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-371">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **TeleportScript.cs**.</span></span>

<span data-ttu-id="f8fdb-372">此指令碼會比 MixedRealityTeleport 稍微複雜的。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-372">This script is a little more involved than MixedRealityTeleport.</span></span> <span data-ttu-id="f8fdb-373">Xbox 控制器中 [Y] 按鈕，往下保留正在檢查指令碼。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-373">The script is checking for the Y Button on the Xbox controller to be held down.</span></span> <span data-ttu-id="f8fdb-374">持有按鈕的游標會變成向下傳送，指令碼會從使用者的視線位置無限遠的光線。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-374">While the button is held down a teleport cursor is rendered and the script casts a ray from the user's gaze position.</span></span> <span data-ttu-id="f8fdb-375">如果該光線衝突是增加或減少的介面與向上，介面會被視為良好的介面，以傳送到，並傳送資料指標上的動畫將會啟用。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-375">If that ray collides with a surface that is more or less pointing up, the surface will be considered a good surface to teleport to, and the animation on the teleport cursor will be enabled.</span></span> <span data-ttu-id="f8fdb-376">如果光線不衝突的介面，增加或減少指向資料指標的動畫將會停用。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-376">If the ray does not collide with a surface more or less pointing up, then the animation on the cursor will be disabled.</span></span> <span data-ttu-id="f8fdb-377">[Y] 按鈕已釋放時之射線的導出的點是有效的位置，則指令碼會呼叫 SetWorldPosition 與光線相交的位置。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-377">When the Y button is released and the calculated point of the ray is a valid position, the script calls SetWorldPosition with the position the ray intersected.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="f8fdb-378">享受您的進度</span><span class="sxs-lookup"><span data-stu-id="f8fdb-378">Enjoy your progress</span></span>

<span data-ttu-id="f8fdb-379">此時您必須尋找朋友。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-379">This time you'll need to find a friend.</span></span>

<span data-ttu-id="f8fdb-380">同樣地，使用者與 HoloLens 將主控工作階段。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-380">Once again, a user with the HoloLens will host a session.</span></span> <span data-ttu-id="f8fdb-381">其他使用者將會加入此工作階段。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-381">Other users will join the session.</span></span> <span data-ttu-id="f8fdb-382">應用程式會將前三個使用者加入從沈浸式耳機島上三個路徑的其中一個上。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-382">The application will place the first three users to join from an immersive headset on one of the three paths on the island.</span></span> <span data-ttu-id="f8fdb-383">請盡情探索這一節島。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-383">Feel free to explore the island in this section.</span></span>

<span data-ttu-id="f8fdb-384">要注意的詳細資料：</span><span class="sxs-lookup"><span data-stu-id="f8fdb-384">Details to notice:</span></span>
1. <span data-ttu-id="f8fdb-385">您可以看到在雲端中的臉部幫助 immersed 的使用者，請參閱 HoloLens 使用者正在尋找的方向。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-385">You can see faces in the clouds, which helps an immersed user see which direction a HoloLens user is looking.</span></span>
2. <span data-ttu-id="f8fdb-386">島上的虛擬人偶有 necks 旋轉。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-386">The avatars on the island have necks that rotate.</span></span> <span data-ttu-id="f8fdb-387">它們不會依照使用者正在做什麼是真正的領域 （我們不需要該資訊），但它對所做的好用的體驗。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-387">They won't follow what the user is doing is real reality (we don't have that information) but it makes for a nice experience.</span></span>
3. <span data-ttu-id="f8fdb-388">如果 HoloLens 使用者會看到島，immersed 的使用者可以看到其資料指標。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-388">If the HoloLens user is looking at the Island, the immersed users can see their cursor.</span></span>
4. <span data-ttu-id="f8fdb-389">代表 HoloLens 使用者的雲端轉換陰影。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-389">The clouds that represent the HoloLens users cast shadows.</span></span>

## <a name="chapter-5---finale"></a><span data-ttu-id="f8fdb-390">第 5 章-二</span><span class="sxs-lookup"><span data-stu-id="f8fdb-390">Chapter 5 - Finale</span></span>

>[!VIDEO https://www.youtube.com/embed/n_HDWJbfpNg]

### <a name="objectives"></a><span data-ttu-id="f8fdb-391">目標</span><span class="sxs-lookup"><span data-stu-id="f8fdb-391">Objectives</span></span>

<span data-ttu-id="f8fdb-392">建立兩個裝置類型之間的共同作業的互動式體驗。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-392">Create a collaborative interactive experience between the two device types.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="f8fdb-393">我們將建置的項目</span><span class="sxs-lookup"><span data-stu-id="f8fdb-393">What we will build</span></span>

<span data-ttu-id="f8fdb-394">基礎第 4 章沈浸式的耳機與使用者靠近謎題島上時，HoloLens 使用者會收到與拼圖線索的工具提示。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-394">Building on chapter 4, when a user with an immersive headset gets near a puzzle on the island, the HoloLens users will get a tool tip with a clue to the puzzle.</span></span> <span data-ttu-id="f8fdb-395">一旦所有的沈浸式耳機使用者取得超過其謎題，然後在 「 準備板 」 到 rocket 房間內，將會啟動 rocket。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-395">Once all of the immersive headset users get past their puzzles and onto the "ready pad" in the rocket room, the rocket will launch.</span></span>

### <a name="steps"></a><span data-ttu-id="f8fdb-396">步驟</span><span class="sxs-lookup"><span data-stu-id="f8fdb-396">Steps</span></span>
* <span data-ttu-id="f8fdb-397">在 **階層**，選取**Usland**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-397">In **Hierarchy**, select **Usland**.</span></span>
* <span data-ttu-id="f8fdb-398">在  **Inspector**，請在**層級控制**，檢查**啟用共同作業**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-398">In **Inspector**, in **Level Control**, check **Enable Collaboration**.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="f8fdb-399">深入探討程式碼</span><span class="sxs-lookup"><span data-stu-id="f8fdb-399">Digging into the code</span></span>

<span data-ttu-id="f8fdb-400">現在讓我們看看 LevelControl.cs。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-400">Now let us look at LevelControl.cs.</span></span> <span data-ttu-id="f8fdb-401">此指令碼是遊戲邏輯的核心，並維護遊戲的狀態。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-401">This script is the core of the game logic and maintains the game state.</span></span> <span data-ttu-id="f8fdb-402">由於這是多人遊戲使用 UNET 我們需要了解資料的流程，也至少夠修改本教學課程。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-402">Since this is a multiplayer game using UNET we need to understand how data flows, at least well enough to modify this tutorial.</span></span> <span data-ttu-id="f8fdb-403">UNET 的更完整概觀，請參閱 Unity 文件。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-403">For a more complete overview of UNET, please refer to Unity's documentation.</span></span>

<span data-ttu-id="f8fdb-404">在 [專案] 面板中，瀏覽至**Assets\AppPrefabs\Support\Scripts\GameLogic** ，然後按兩下**LevelControl.cs**。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-404">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **LevelControl.cs**.</span></span>

<span data-ttu-id="f8fdb-405">讓我們了解如何沈浸式耳機表示它們是火箭上市作準備。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-405">Let us understand how an immersive headset indicates that they are ready for the rocket launch.</span></span> <span data-ttu-id="f8fdb-406">Rocket 啟動整備通訊的其中三個布林設定清單中的對應至三個路徑島上的布林。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-406">Rocket Launch readiness is communicated by setting one of three bools in a list of bools that correspond to the three paths on the island.</span></span> <span data-ttu-id="f8fdb-407">將使用者指派給路徑位於 rocket 房間內的棕色板上方時，設定路徑的 bool。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-407">A path's bool will be set when the user assigned to the path is on top of the brown pad inside the rocket room.</span></span> <span data-ttu-id="f8fdb-408">好，現在來詳細資料。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-408">Okay, now to the details.</span></span>

<span data-ttu-id="f8fdb-409">我們將開始的 update （） 函式。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-409">We will start in the Update() function.</span></span> <span data-ttu-id="f8fdb-410">您會發現沒有 'cheat' 函式。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-410">You will note that there is a 'cheat' function.</span></span> <span data-ttu-id="f8fdb-411">我們使用這在開發過程中將測試 rocket 啟動和重設序列。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-411">We used this in development to test the rocket launch and reset sequence.</span></span> <span data-ttu-id="f8fdb-412">它將無法在多使用者體驗中運作。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-412">It won't work in the multi user experience.</span></span> <span data-ttu-id="f8fdb-413">希望您內化下列資訊的時間就能夠立即確認其運作。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-413">Hopefully by the time you internalize the following infromation you can make it work.</span></span> <span data-ttu-id="f8fdb-414">我們檢查一下，請參閱我們應該使用密技之後，我們會檢查以查看 是否沉浸本機的播放程式。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-414">After we check to see if we should cheat, we check to see if the local player is immersed.</span></span> <span data-ttu-id="f8fdb-415">我們想要專注於我們如何找到我們在目標。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-415">We want to focus on how we find that we're at the goal.</span></span> <span data-ttu-id="f8fdb-416">在 if （沉浸） 檢查，沒有呼叫背後隱藏的 CheckGoal **EnableCollaboration** bool。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-416">Inside of the if (Immersed) check, there is a call to CheckGoal hiding behind the **EnableCollaboration** bool.</span></span> <span data-ttu-id="f8fdb-417">這會對應至您在完成本章節的步驟時，核取此核取方塊。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-417">This corresponds to the checkbox you checked while completing the steps for this chapter.</span></span> <span data-ttu-id="f8fdb-418">EnableCollaboration 內，我們會看到 CheckGoal() 呼叫。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-418">Inside of EnableCollaboration we see a call to CheckGoal().</span></span>

<span data-ttu-id="f8fdb-419">CheckGoal 會執行一些數學運算來查看我們是否增加或減少板上的位置。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-419">CheckGoal does some math to see if we are more or less standing on the pad.</span></span> <span data-ttu-id="f8fdb-420">當我們，我們 Debug.Log"Arrived 在目標 」，接著再呼叫 'SendAtGoalMessage()'。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-420">When we are, we Debug.Log "Arrived at goal" and then we call 'SendAtGoalMessage()'.</span></span> <span data-ttu-id="f8fdb-421">在 SendAtGoalMessage，我們會呼叫 playerController.SendAtGoal。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-421">In SendAtGoalMessage we call playerController.SendAtGoal.</span></span> <span data-ttu-id="f8fdb-422">若要節省一些時間，以下的程式碼：</span><span class="sxs-lookup"><span data-stu-id="f8fdb-422">To save you some time, here's the code:</span></span>

```cs
private void CmdSendAtGoal(int GoalIndex)
       {
           levelState.SetGoalIndex(GoalIndex);
       }
```

```cs
public void SendAtGoal(int GoalIndex)
       {
           if (isLocalPlayer)
           {
               Debug.Log("sending at goal " + GoalIndex);
               CmdSendAtGoal(GoalIndex);
           }
       }
```

<span data-ttu-id="f8fdb-423">請注意 SendAtGoalMessage 呼叫 CmdSendAtGoal，哪一個呼叫 levelState.SetGoalIndex，也就是在 LevelControl.cs。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-423">Note that SendAtGoalMessage calls CmdSendAtGoal, which calls levelState.SetGoalIndex, which is back in LevelControl.cs.</span></span> <span data-ttu-id="f8fdb-424">乍看之下可能有點奇怪。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-424">At first glance this seems strange.</span></span> <span data-ttu-id="f8fdb-425">為什麼不只是呼叫 SetGoalIndex 而不是這奇怪經過 「 玩家 」 控制器？</span><span class="sxs-lookup"><span data-stu-id="f8fdb-425">Why not just call SetGoalIndex rather than this strange routing through the player controller?</span></span> <span data-ttu-id="f8fdb-426">原因是我們符合 UNET 使用，讓資料保持同步的資料模型。若要避免作弊和過度置換，UNET 會需要每個物件都具有變更的同步處理的變數的權限的使用者。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-426">The reason is that we are conforming to the data model UNET uses to keep data in sync. To prevent cheating and thrashing, UNET requires that each object has a user who has authority to change the synchronized variables.</span></span> <span data-ttu-id="f8fdb-427">此外，只有主機 （啟動工作階段的使用者） 可以直接變更資料。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-427">Further, only the host (the user that started the session) can change data directly.</span></span> <span data-ttu-id="f8fdb-428">不是主應用程式，但具有權限，使用者需要 「 command 」 將會變更變數的主機。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-428">Users who are not the host, but have authority, need to send a 'command' to the host which will change the variable.</span></span> <span data-ttu-id="f8fdb-429">根據預設主機會高於繁衍來代表使用者的物件除外的所有物件的授權單位。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-429">By default the host has authority over all objects, except for the object spawned to represent the user.</span></span> <span data-ttu-id="f8fdb-430">在本例中此物件會具有 playercontroller 指令碼。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-430">In our case this object has the playercontroller script.</span></span> <span data-ttu-id="f8fdb-431">沒有方法可要求之物件的授權單位，然後再進行變更，但我們選擇利用 「 玩家 」 控制器具有本身的授權單位和路由命令透過 「 玩家 」 控制器的事實。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-431">There is a way to request authority for an object and then make changes, but we choose to leverage the fact that the player controller has self authority and route commands through the player controller.</span></span>

<span data-ttu-id="f8fdb-432">換言之，當我們發現自己在我們的目標時，播放程式需要向主應用程式，而主應用程式會告訴其他人。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-432">Said another way, when we've found ourselves at our goal, the player needs to tell the host, and the host will tell everyone else.</span></span>

<span data-ttu-id="f8fdb-433">在 LevelControl.cs SetGoalIndex 看。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-433">Back in LevelControl.cs look at SetGoalIndex.</span></span> <span data-ttu-id="f8fdb-434">這裡我們 synclist (AtGoal) 中設定的值。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-434">Here we are setting the value of a value in a synclist (AtGoal).</span></span> <span data-ttu-id="f8fdb-435">請記住我們是主應用程式的內容中，當我們執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-435">Remember that we are in the context of the host while we do this.</span></span> <span data-ttu-id="f8fdb-436">類似的命令，RPC 是主應用程式可以發出，使所有用戶端執行一些程式碼。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-436">Similar to a command, an RPC is something the host can issue that will cause all clients to run some code.</span></span> <span data-ttu-id="f8fdb-437">這裡我們呼叫 'RpcCheckAllGoals'。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-437">Here we call 'RpcCheckAllGoals'.</span></span> <span data-ttu-id="f8fdb-438">每個用戶端會個別檢查以查看所有的三個 AtGoals 所設定，和如果是這樣，啟動 rocket。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-438">Each client will individually check to see if all three AtGoals are set, and if so, launch the rocket.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="f8fdb-439">享受您的進度</span><span class="sxs-lookup"><span data-stu-id="f8fdb-439">Enjoy your progress</span></span>

<span data-ttu-id="f8fdb-440">在上一章中建置，我們將開始為之前的工作階段。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-440">Building on the previous chapter, we will start the session as before.</span></span> <span data-ttu-id="f8fdb-441">這次在沉浸式耳機 get 扇 「 小門 」 在其路徑中，以使用者為工具提示會顯示只有 HoloLens 的使用者可以看到。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-441">This time as the users in the immersive headset get to the "door" on their path, a tooltip will appear that only the HoloLens users can see.</span></span> <span data-ttu-id="f8fdb-442">HoloLens 使用者負責傳達此線索沈浸式耳機中的使用者。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-442">The HoloLens users are responsible for communicating this clue to the users in the immersive headset.</span></span> <span data-ttu-id="f8fdb-443">Rocket 會啟動空間之後每個虛擬人偶有分層式火山內其對應的棕色板上。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-443">The rocket will launch to space once each avatar has stepped on its corresponding brown pad inside the volcano.</span></span> <span data-ttu-id="f8fdb-444">場景會重設在 60 秒之後，因此您可以再次執行。</span><span class="sxs-lookup"><span data-stu-id="f8fdb-444">The scene will reset after 60 seconds so you can do it again.</span></span>

## <a name="see-also"></a><span data-ttu-id="f8fdb-445">另請參閱</span><span class="sxs-lookup"><span data-stu-id="f8fdb-445">See also</span></span>
* [<span data-ttu-id="f8fdb-446">MR 輸入 213:動作控制站</span><span class="sxs-lookup"><span data-stu-id="f8fdb-446">MR Input 213: Motion controllers</span></span>](mixed-reality-213.md)
