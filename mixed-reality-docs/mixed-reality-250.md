---
title: MR 分享 250-HoloLens 和沉浸式耳機
description: 遵循這份使用 Unity、Visual Studio、HoloLens 和 Windows Mixed Reality 耳機的編碼逐步解說, 瞭解在混合現實裝置之間共用全息影像的詳細資料。
author: keveleigh
ms.author: kurtie
ms.date: 03/21/2018
ms.topic: article
keywords: holotoolkit, mixedrealitytoolkit, mixedrealitytoolkit-unity, 沉浸, 運動控制器, 共用, xbox 控制器, 網路, 跨裝置
ms.openlocfilehash: 9e1cb0d168b8bf830b4477190516cd19caef7972
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/24/2019
ms.locfileid: "63506109"
---
>[!NOTE]
><span data-ttu-id="7b505-104">混合現實學術教學課程的設計是使用 HoloLens (第1代) 和混合現實的沉浸式耳機。</span><span class="sxs-lookup"><span data-stu-id="7b505-104">The Mixed Reality Academy tutorials were designed with HoloLens (1st gen) and Mixed Reality Immersive Headsets in mind.</span></span>  <span data-ttu-id="7b505-105">因此, 對於仍在尋找這些裝置開發指引的開發人員而言, 我們覺得這些教學課程很重要。</span><span class="sxs-lookup"><span data-stu-id="7b505-105">As such, we feel it is important to leave these tutorials in place for developers who are still looking for guidance in developing for those devices.</span></span>  <span data-ttu-id="7b505-106">這些教學課程會 **_不_** 使用最新的工具組或用於 HoloLens 2 的互動進行更新。</span><span class="sxs-lookup"><span data-stu-id="7b505-106">These tutorials will **_not_** be updated with the latest toolsets or interactions being used for HoloLens 2.</span></span>  <span data-ttu-id="7b505-107">系統會保留這些資訊, 以繼續在支援的裝置上運作。</span><span class="sxs-lookup"><span data-stu-id="7b505-107">They will be maintained to continue working on the supported devices.</span></span> <span data-ttu-id="7b505-108">未來將會有一系列新的教學課程, 將示範如何針對 HoloLens 2 進行開發。</span><span class="sxs-lookup"><span data-stu-id="7b505-108">There will be a new series of tutorials that will be posted in the future that will demonstrate how to develop for HoloLens 2.</span></span>  <span data-ttu-id="7b505-109">此通知會在張貼時, 使用這些教學課程的連結進行更新。</span><span class="sxs-lookup"><span data-stu-id="7b505-109">This notice will be updated with a link to those tutorials when they are posted.</span></span>

<br>

# <a name="mr-sharing-250-hololens-and-immersive-headsets"></a><span data-ttu-id="7b505-110">MR 分享 250:HoloLens 和沉浸式耳機</span><span class="sxs-lookup"><span data-stu-id="7b505-110">MR Sharing 250: HoloLens and immersive headsets</span></span>

<span data-ttu-id="7b505-111">有了通用 Windows 平臺 (UWP) 的彈性, 您可以輕鬆地建立橫跨多個裝置的應用程式。</span><span class="sxs-lookup"><span data-stu-id="7b505-111">With the flexibility of Universal Windows Platform (UWP), it is easy to create an application that spans multiple devices.</span></span> <span data-ttu-id="7b505-112">有了這種彈性, 我們就可以建立運用每個裝置的優勢的體驗。</span><span class="sxs-lookup"><span data-stu-id="7b505-112">With this flexibility, we can create experiences that leverage the strengths of each device.</span></span> <span data-ttu-id="7b505-113">本教學課程將涵蓋在 HoloLens 和 Windows Mixed Reality 沉浸式耳機上執行的基本共用體驗。</span><span class="sxs-lookup"><span data-stu-id="7b505-113">This tutorial will cover a basic shared experience that runs on both HoloLens and Windows Mixed Reality immersive headsets.</span></span> <span data-ttu-id="7b505-114">此內容原本是在華盛頓州西雅圖的 Microsoft Build 2017 會議中提供。</span><span class="sxs-lookup"><span data-stu-id="7b505-114">This content was originally delivered at the Microsoft Build 2017 conference in Seattle, WA.</span></span>

<span data-ttu-id="7b505-115">**在本教學課程中, 我們將:**</span><span class="sxs-lookup"><span data-stu-id="7b505-115">**In this tutorial, we will:**</span></span>

* <span data-ttu-id="7b505-116">使用 UNET 設定網路。</span><span class="sxs-lookup"><span data-stu-id="7b505-116">Setup a network using UNET.</span></span>
* <span data-ttu-id="7b505-117">跨混合現實裝置共用全息影像。</span><span class="sxs-lookup"><span data-stu-id="7b505-117">Share holograms across mixed reality devices.</span></span>
* <span data-ttu-id="7b505-118">根據使用的混合現實裝置, 建立不同的應用程式視圖。</span><span class="sxs-lookup"><span data-stu-id="7b505-118">Establish a different view of the application depending on which mixed reality device is being used.</span></span>
* <span data-ttu-id="7b505-119">建立一個分享的體驗, 讓 HoloLens 使用者透過一些簡單的測驗, 引導沉浸式耳機使用者。</span><span class="sxs-lookup"><span data-stu-id="7b505-119">Create a shared experience where HoloLens users guide immersive headsets users through some simple puzzles.</span></span>

## <a name="device-support"></a><span data-ttu-id="7b505-120">裝置支援</span><span class="sxs-lookup"><span data-stu-id="7b505-120">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="7b505-121">粗</span><span class="sxs-lookup"><span data-stu-id="7b505-121">Course</span></span></th><th style="width:150px"> <span data-ttu-id="7b505-122"><a href="hololens-hardware-details.md">HoloLens</a></span><span class="sxs-lookup"><span data-stu-id="7b505-122"><a href="hololens-hardware-details.md">HoloLens</a></span></span></th><th style="width:150px"> <span data-ttu-id="7b505-123"><a href="immersive-headset-hardware-details.md">沉浸式頭戴裝置</a></span><span class="sxs-lookup"><span data-stu-id="7b505-123"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td><span data-ttu-id="7b505-124">MR 分享 250:HoloLens 和沉浸式耳機</span><span class="sxs-lookup"><span data-stu-id="7b505-124">MR Sharing 250: HoloLens and immersive headsets</span></span></td><td style="text-align: center;"> <span data-ttu-id="7b505-125">✔️</span><span class="sxs-lookup"><span data-stu-id="7b505-125">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="7b505-126">✔️</span><span class="sxs-lookup"><span data-stu-id="7b505-126">✔️</span></span></td>
</tr>
</table>

## <a name="before-you-start"></a><span data-ttu-id="7b505-127">開始之前</span><span class="sxs-lookup"><span data-stu-id="7b505-127">Before you start</span></span>

### <a name="prerequisites"></a><span data-ttu-id="7b505-128">必要條件</span><span class="sxs-lookup"><span data-stu-id="7b505-128">Prerequisites</span></span>

* <span data-ttu-id="7b505-129">Windows 10 電腦具有必要的[開發工具](install-the-tools.md), 並[已設定為支援 windows Mixed Reality 沉浸式頭戴式](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)裝置。</span><span class="sxs-lookup"><span data-stu-id="7b505-129">A Windows 10 PC with the [necessary development tools](install-the-tools.md) and [configured to support a Windows Mixed Reality immersive headset](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>
* <span data-ttu-id="7b505-130">可與您的電腦搭配使用的 Xbox 控制器。</span><span class="sxs-lookup"><span data-stu-id="7b505-130">An Xbox controller that works with your PC.</span></span>
* <span data-ttu-id="7b505-131">至少一部 HoloLens 裝置和一個沉浸式耳機。</span><span class="sxs-lookup"><span data-stu-id="7b505-131">At least one HoloLens device and one immersive headset.</span></span>
* <span data-ttu-id="7b505-132">允許 UDP 廣播進行探索的網路。</span><span class="sxs-lookup"><span data-stu-id="7b505-132">A network which allows UDP Broadcast for discovery.</span></span>

### <a name="project-files"></a><span data-ttu-id="7b505-133">專案檔案</span><span class="sxs-lookup"><span data-stu-id="7b505-133">Project files</span></span>

* <span data-ttu-id="7b505-134">下載專案所需的[檔案](https://github.com/Microsoft/MixedReality250/archive/master.zip)。</span><span class="sxs-lookup"><span data-stu-id="7b505-134">Download the [files](https://github.com/Microsoft/MixedReality250/archive/master.zip) required by the project.</span></span> <span data-ttu-id="7b505-135">將檔案解壓縮到容易記住的位置。</span><span class="sxs-lookup"><span data-stu-id="7b505-135">Extract the files to an easy to remember location.</span></span>
* <span data-ttu-id="7b505-136">此專案需要[具有 Windows Mixed Reality 支援的建議版本 Unity](install-the-tools.md)。</span><span class="sxs-lookup"><span data-stu-id="7b505-136">This project requires the [a recommended version of Unity with Windows Mixed Reality support](install-the-tools.md).</span></span>

>[!NOTE]
><span data-ttu-id="7b505-137">如果您想要在下載之前查看原始程式碼, 可以[在 GitHub 上](https://github.com/Microsoft/MixedReality250)取得。</span><span class="sxs-lookup"><span data-stu-id="7b505-137">If you want to look through the source code before downloading, it's [available on GitHub](https://github.com/Microsoft/MixedReality250).</span></span>

## <a name="chapter-1---holo-world"></a><span data-ttu-id="7b505-138">第1章-Hololens 世界</span><span class="sxs-lookup"><span data-stu-id="7b505-138">Chapter 1 - Holo World</span></span>

>[!VIDEO https://www.youtube.com/embed/IC0rp6rLiEc]

### <a name="objectives"></a><span data-ttu-id="7b505-139">目標</span><span class="sxs-lookup"><span data-stu-id="7b505-139">Objectives</span></span>

<span data-ttu-id="7b505-140">請確定開發環境已準備好開始使用簡單的專案。</span><span class="sxs-lookup"><span data-stu-id="7b505-140">Make sure the development environment is ready to go with a simple project.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="7b505-141">我們將建立的內容</span><span class="sxs-lookup"><span data-stu-id="7b505-141">What we will build</span></span>

<span data-ttu-id="7b505-142">一種應用程式, 可顯示 HoloLens 或 Windows Mixed Reality 沉浸式耳機的全息影像。</span><span class="sxs-lookup"><span data-stu-id="7b505-142">An application that shows a hologram on either HoloLens or a Windows Mixed Reality immersive headset.</span></span>

### <a name="steps"></a><span data-ttu-id="7b505-143">步驟</span><span class="sxs-lookup"><span data-stu-id="7b505-143">Steps</span></span>
* <span data-ttu-id="7b505-144">開啟 Unity。</span><span class="sxs-lookup"><span data-stu-id="7b505-144">Open Unity.</span></span>
    * <span data-ttu-id="7b505-145">選取 [**開啟**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-145">Select **Open**.</span></span>
    * <span data-ttu-id="7b505-146">流覽至您解壓縮專案檔案的位置。</span><span class="sxs-lookup"><span data-stu-id="7b505-146">Navigate to where you extracted the project files.</span></span>
    * <span data-ttu-id="7b505-147">按一下 [選擇資料夾]。</span><span class="sxs-lookup"><span data-stu-id="7b505-147">Click **Select Folder**.</span></span>
    * <span data-ttu-id="7b505-148">*Unity 需要一些時間才能第一次處理專案。*</span><span class="sxs-lookup"><span data-stu-id="7b505-148">*It will take a little while for Unity to process the project the first time.*</span></span>
* <span data-ttu-id="7b505-149">檢查 Unity 中是否已啟用混合現實。</span><span class="sxs-lookup"><span data-stu-id="7b505-149">Check that Mixed Reality is enabled in Unity.</span></span>
    * <span data-ttu-id="7b505-150">開啟 [組建設定] 對話方塊 ([**控制項 + Shift + B** ] 或 [檔案 **> 組建設定**...])。</span><span class="sxs-lookup"><span data-stu-id="7b505-150">Open the build settings dialog (**Control+Shift+B** or **File > Build Settings...**).</span></span>
    * <span data-ttu-id="7b505-151">選取**通用 Windows 平臺**, 然後按一下 [**切換平臺**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-151">Select **Universal Windows Platform** then click **Switch Platform**.</span></span>
    * <span data-ttu-id="7b505-152">選取 [**編輯 > 播放機設定**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-152">Select **Edit>Player Settings**.</span></span>
    * <span data-ttu-id="7b505-153">在右側的 [偵測**器**] 面板中, 展開 [ **XR 設定**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-153">In the **Inspector** panel on the right hand side, expand **XR Settings**.</span></span>
    * <span data-ttu-id="7b505-154">勾選 [**支援虛擬實境**] 方塊。</span><span class="sxs-lookup"><span data-stu-id="7b505-154">Check the **Virtual Reality Supported** box.</span></span>
    * <span data-ttu-id="7b505-155">*Windows Mixed Reality 應該是虛擬實境 SDK。*</span><span class="sxs-lookup"><span data-stu-id="7b505-155">*Windows Mixed Reality should be the Virtual Reality SDK.*</span></span>
* <span data-ttu-id="7b505-156">建立場景。</span><span class="sxs-lookup"><span data-stu-id="7b505-156">Create a scene.</span></span>
    * <span data-ttu-id="7b505-157">在階層中, 以滑鼠右鍵按一下**主要相機**選取 [**刪除**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-157">In the **Hierarchy** right click **Main Camera** select **Delete**.</span></span>
    * <span data-ttu-id="7b505-158">從**HoloToolkit > 輸入 > Prefabs**將**MixedRealityCameraParent**拖曳至階層。</span><span class="sxs-lookup"><span data-stu-id="7b505-158">From **HoloToolkit > Input > Prefabs** drag **MixedRealityCameraParent** to the **Hierarchy**.</span></span>
* <span data-ttu-id="7b505-159">將全息影像新增至場景</span><span class="sxs-lookup"><span data-stu-id="7b505-159">Add Holograms to the scene</span></span>
    * <span data-ttu-id="7b505-160">從 [ **AppPrefabs** ] 將 [ **Skybox** ] 拖曳至**場景視圖**。</span><span class="sxs-lookup"><span data-stu-id="7b505-160">From **AppPrefabs** drag **Skybox** to the **Scene View**.</span></span>
    * <span data-ttu-id="7b505-161">從**AppPrefabs**將**經理**拖曳至階層。</span><span class="sxs-lookup"><span data-stu-id="7b505-161">From **AppPrefabs** drag **Managers** to the **Hierarchy**.</span></span>
    * <span data-ttu-id="7b505-162">從 [ **AppPrefabs** ] 將 [**島**] 拖曳至階層。</span><span class="sxs-lookup"><span data-stu-id="7b505-162">From **AppPrefabs** drag **Island** to the **Hierarchy**.</span></span>
* <span data-ttu-id="7b505-163">儲存並建立</span><span class="sxs-lookup"><span data-stu-id="7b505-163">Save And build</span></span>
    * <span data-ttu-id="7b505-164">儲存 ( **Control + S**或**File > 儲存場景**)</span><span class="sxs-lookup"><span data-stu-id="7b505-164">Save (either **Control+S** or **File > Save Scene**)</span></span>
    * <span data-ttu-id="7b505-165">因為這是新場景, 所以您必須將其命名為。</span><span class="sxs-lookup"><span data-stu-id="7b505-165">Since this is a new scene, you'll need to name it.</span></span> <span data-ttu-id="7b505-166">名稱並不重要, 但我們會使用 SharedMixedReality。</span><span class="sxs-lookup"><span data-stu-id="7b505-166">Name doesn't matter, but we use SharedMixedReality.</span></span>
* <span data-ttu-id="7b505-167">匯出至 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="7b505-167">Export To Visual Studio</span></span>
    * <span data-ttu-id="7b505-168">開啟 [建立] 功能表 (**ctrl + Shift + B**或**File > 組建設定**)</span><span class="sxs-lookup"><span data-stu-id="7b505-168">Open the build menu (**Control+Shift+B** or **File > Build Settings**)</span></span>
    * <span data-ttu-id="7b505-169">按一下 [**新增開啟的場景]。**</span><span class="sxs-lookup"><span data-stu-id="7b505-169">Click **Add Open Scenes.**</span></span>
    * <span data-ttu-id="7b505-170">檢查**Unity C#專案**</span><span class="sxs-lookup"><span data-stu-id="7b505-170">Check **Unity C# Projects**</span></span>
    * <span data-ttu-id="7b505-171">按一下 [建置]。</span><span class="sxs-lookup"><span data-stu-id="7b505-171">Click **Build**.</span></span>
    * <span data-ttu-id="7b505-172">在出現的 [檔案瀏覽器] 視窗中, 建立名為 [**應用程式**] 的新資料夾。</span><span class="sxs-lookup"><span data-stu-id="7b505-172">In the file explorer window that appears, create a New Folder named **App**.</span></span>
    * <span data-ttu-id="7b505-173">按一下 [**應用程式**] 資料夾。</span><span class="sxs-lookup"><span data-stu-id="7b505-173">Single click the **App** folder.</span></span>
    * <span data-ttu-id="7b505-174">按 [**選取資料夾]。**</span><span class="sxs-lookup"><span data-stu-id="7b505-174">Press **Select Folder.**</span></span>
    * <span data-ttu-id="7b505-175">**等候組建完成**</span><span class="sxs-lookup"><span data-stu-id="7b505-175">**Wait for the build to complete**</span></span>
    * <span data-ttu-id="7b505-176">在出現的 [檔案瀏覽器] 視窗中, 流覽至 [**應用程式**] 資料夾。</span><span class="sxs-lookup"><span data-stu-id="7b505-176">In the file explorer window that appears, navigate into the **App** folder.</span></span>
    * <span data-ttu-id="7b505-177">按兩下 [ **SharedMixedReality** ] 以啟動 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="7b505-177">Double-click **SharedMixedReality.sln** to launch Visual Studio</span></span>
* <span data-ttu-id="7b505-178">從 Visual Studio 建立</span><span class="sxs-lookup"><span data-stu-id="7b505-178">Build From Visual Studio</span></span>
    * <span data-ttu-id="7b505-179">使用頂端工具列將目標變更為 [**發行**] 和 [ **x86**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-179">Using the top toolbar change target to **Release** and **x86**.</span></span>
    * <span data-ttu-id="7b505-180">按一下 [**本機電腦**] 旁的箭號, 然後選取 [要部署到 HoloLens 的**裝置**]</span><span class="sxs-lookup"><span data-stu-id="7b505-180">Click the arrow next to **Local Machine** and select **Device** to deploy to HoloLens</span></span>
    * <span data-ttu-id="7b505-181">按一下 [**裝置**] 旁的箭號, 然後選取 [**本機電腦**] 以部署混合現實耳機。</span><span class="sxs-lookup"><span data-stu-id="7b505-181">Click the arrow next to **Device** and select **Local Machine** to deploy for the mixed reality headset.</span></span>
    * <span data-ttu-id="7b505-182">按一下 [ **Debug-> 啟動但不**進行偵測] 或 [**控制 + F5** ] 來啟動應用程式。</span><span class="sxs-lookup"><span data-stu-id="7b505-182">Click **Debug->Start Without Debugging** or **Control+F5** to start the application.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="7b505-183">深入探討至程式碼</span><span class="sxs-lookup"><span data-stu-id="7b505-183">Digging into the code</span></span>

<span data-ttu-id="7b505-184">在 [專案] 面板中, 流覽至**Assets\HoloToolkit\Input\Scripts\Utilities** , 然後按兩下**MixedRealityCameraManager.cs**將其開啟。</span><span class="sxs-lookup"><span data-stu-id="7b505-184">In the project panel, navigate to **Assets\HoloToolkit\Input\Scripts\Utilities** and double click **MixedRealityCameraManager.cs** to open it.</span></span>

<span data-ttu-id="7b505-185">**簡要**MixedRealityCameraManager.cs 是一個簡單的腳本, 可根據裝置調整品質層級和背景設定。</span><span class="sxs-lookup"><span data-stu-id="7b505-185">**Overview:** MixedRealityCameraManager.cs is a simple script that adjusts quality level and background settings based on the device.</span></span> <span data-ttu-id="7b505-186">這裡的金鑰是 HolographicSettings. IsDisplayOpaque, 它可讓腳本偵測裝置是否為 HoloLens (IsDisplayOpaque 會傳回 false) 或沉浸式耳機 (IsDisplayOpaque 會傳回 true)。</span><span class="sxs-lookup"><span data-stu-id="7b505-186">Key here is HolographicSettings.IsDisplayOpaque, which allows a script to detect if the device is a HoloLens (IsDisplayOpaque returns false) or an immersive headset (IsDisplayOpaque returns true).</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="7b505-187">享用您的進度</span><span class="sxs-lookup"><span data-stu-id="7b505-187">Enjoy your progress</span></span>

<span data-ttu-id="7b505-188">此時, 應用程式只會轉譯一個全息影像。</span><span class="sxs-lookup"><span data-stu-id="7b505-188">At this point the application will just render a hologram.</span></span> <span data-ttu-id="7b505-189">我們會在稍後新增與全息影像的互動。</span><span class="sxs-lookup"><span data-stu-id="7b505-189">We will add interaction to the hologram later.</span></span> <span data-ttu-id="7b505-190">這兩個裝置都會呈現相同的全息影像。</span><span class="sxs-lookup"><span data-stu-id="7b505-190">Both devices will render the hologram the same.</span></span> <span data-ttu-id="7b505-191">沉浸式耳機也會呈現藍色的天空和雲端背景。</span><span class="sxs-lookup"><span data-stu-id="7b505-191">The immersive headset will also render a blue sky and clouds background.</span></span>

## <a name="chapter-2---interaction"></a><span data-ttu-id="7b505-192">第2章-互動</span><span class="sxs-lookup"><span data-stu-id="7b505-192">Chapter 2 - Interaction</span></span>

>[!VIDEO https://www.youtube.com/embed/Lrb1y4sQRvI]

### <a name="objectives"></a><span data-ttu-id="7b505-193">目標</span><span class="sxs-lookup"><span data-stu-id="7b505-193">Objectives</span></span>

<span data-ttu-id="7b505-194">示範如何處理 Windows Mixed Reality 應用程式的輸入。</span><span class="sxs-lookup"><span data-stu-id="7b505-194">Show how to handle input for a Windows Mixed Reality application.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="7b505-195">我們將建立的內容</span><span class="sxs-lookup"><span data-stu-id="7b505-195">What we will build</span></span>

<span data-ttu-id="7b505-196">從第1章的應用程式開始, 我們將新增功能, 讓使用者能夠挑選全像投影, 並將它放在 HoloLens 的實際表面上, 或放置在沉浸式耳機的虛擬資料表上。</span><span class="sxs-lookup"><span data-stu-id="7b505-196">Building on the application from chapter 1, we will add functionality to allow the user to pick up the hologram and place it on a real world surface in HoloLens or on a virtual table in an immersive headset.</span></span>

<span data-ttu-id="7b505-197">**輸入重新整理器:** 在 HoloLens 上, 選取筆勢是「**空中碰**」。</span><span class="sxs-lookup"><span data-stu-id="7b505-197">**Input Refresher:** On HoloLens the select gesture is the **air tap**.</span></span> <span data-ttu-id="7b505-198">在沉浸式耳機上, 我們將使用 Xbox 控制器上的 [ **A** ] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="7b505-198">On immersive headsets, we will use the **A** button on the Xbox controller.</span></span> <span data-ttu-id="7b505-199">如需輸入的詳細資訊, 請[從這裡開始](gestures.md)。</span><span class="sxs-lookup"><span data-stu-id="7b505-199">For more information on input [start here](gestures.md).</span></span>

### <a name="steps"></a><span data-ttu-id="7b505-200">步驟</span><span class="sxs-lookup"><span data-stu-id="7b505-200">Steps</span></span>
* <span data-ttu-id="7b505-201">新增輸入管理員</span><span class="sxs-lookup"><span data-stu-id="7b505-201">Add Input manager</span></span>
    * <span data-ttu-id="7b505-202">從**HoloToolkit > 輸入 > Prefabs**將 [ **InputManager** ] 拖曳至 [階層] 做為**經理**的子系。</span><span class="sxs-lookup"><span data-stu-id="7b505-202">From **HoloToolkit > Input > Prefabs** drag **InputManager** to **Hierarchy** as a child of **Managers**.</span></span>
    * <span data-ttu-id="7b505-203">從**HoloToolkit > 輸入 > Prefabs > 資料指標**將**游標**拖曳至階層。</span><span class="sxs-lookup"><span data-stu-id="7b505-203">From **HoloToolkit > Input > Prefabs > Cursor** drag **Cursor** to **Hierarchy**.</span></span>
* <span data-ttu-id="7b505-204">新增空間對應</span><span class="sxs-lookup"><span data-stu-id="7b505-204">Add Spatial Mapping</span></span>
    * <span data-ttu-id="7b505-205">從**HoloToolkit > SpatialMapping > Prefabs**將 [ **SpatialMapping** ] 拖曳至 [階層]。</span><span class="sxs-lookup"><span data-stu-id="7b505-205">From **HoloToolkit > SpatialMapping > Prefabs** drag **SpatialMapping** to **Hierarchy**.</span></span>
* <span data-ttu-id="7b505-206">新增虛擬 Playspace</span><span class="sxs-lookup"><span data-stu-id="7b505-206">Add Virtual Playspace</span></span>
    * <span data-ttu-id="7b505-207">在階層中展開**MixedRealityCameraParent**選取**界限**</span><span class="sxs-lookup"><span data-stu-id="7b505-207">In **Hierarchy** expand **MixedRealityCameraParent** select **Boundary**</span></span>
    * <span data-ttu-id="7b505-208">在 [偵測**器**] 面板中, 核取 [啟用**界限**] 方塊</span><span class="sxs-lookup"><span data-stu-id="7b505-208">In **Inspector** panel check the box to enable **Boundary**</span></span>
    * <span data-ttu-id="7b505-209">從 [ **AppPrefabs** ] 將[ **VRRoom** ] 拖曳至 [階層]。</span><span class="sxs-lookup"><span data-stu-id="7b505-209">From **AppPrefabs** drag **VRRoom** to **Hierarchy**.</span></span>
* <span data-ttu-id="7b505-210">新增 WorldAnchorManager</span><span class="sxs-lookup"><span data-stu-id="7b505-210">Add WorldAnchorManager</span></span>
    * <span data-ttu-id="7b505-211">在[階層] 中, 選取 [**管理員**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-211">In **Hierarchy**, Select **Managers**.</span></span>
    * <span data-ttu-id="7b505-212">在 [偵測**器**] 中, 按一下 [**新增元件**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-212">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="7b505-213">輸入**世界錨點管理員**。</span><span class="sxs-lookup"><span data-stu-id="7b505-213">Type **World Anchor Manager**.</span></span>
    * <span data-ttu-id="7b505-214">選取 [**全球錨點管理員**] 將它加入。</span><span class="sxs-lookup"><span data-stu-id="7b505-214">Select **World Anchor Manager** to add it.</span></span>
* <span data-ttu-id="7b505-215">將 TapToPlace 新增至島</span><span class="sxs-lookup"><span data-stu-id="7b505-215">Add TapToPlace to the Island</span></span>
    * <span data-ttu-id="7b505-216">在[階層] 中, 展開 [**島**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-216">In **Hierarchy**, expand **Island**.</span></span>
    * <span data-ttu-id="7b505-217">選取 [ **MixedRealityLand**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-217">Select **MixedRealityLand**.</span></span>
    * <span data-ttu-id="7b505-218">在 [偵測**器**] 中, 按一下 [**新增元件**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-218">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="7b505-219">輸入點一下並加以選取。</span><span class="sxs-lookup"><span data-stu-id="7b505-219">Type **Tap To Place** and select it.</span></span>
    * <span data-ttu-id="7b505-220">勾選 **[將父系放在點上**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-220">Check **Place Parent On Tap**.</span></span>
    * <span data-ttu-id="7b505-221">將**放置位移**設定為 **(0, 0.1, 0)** 。</span><span class="sxs-lookup"><span data-stu-id="7b505-221">Set **Placement Offset** to **(0, 0.1, 0)**.</span></span>
* <span data-ttu-id="7b505-222">儲存並建立成先前的</span><span class="sxs-lookup"><span data-stu-id="7b505-222">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="7b505-223">深入探討至程式碼</span><span class="sxs-lookup"><span data-stu-id="7b505-223">Digging into the code</span></span>

<span data-ttu-id="7b505-224">**腳本 1-GamepadInput.cs**</span><span class="sxs-lookup"><span data-stu-id="7b505-224">**Script 1 - GamepadInput.cs**</span></span>

<span data-ttu-id="7b505-225">在 [專案] 面板中, 流覽至**Assets\HoloToolkit\Input\Scripts\InputSources** , 然後按兩下**GamepadInput.cs**將其開啟。</span><span class="sxs-lookup"><span data-stu-id="7b505-225">In the project panel navigate to **Assets\HoloToolkit\Input\Scripts\InputSources** and double click **GamepadInput.cs** to open it.</span></span> <span data-ttu-id="7b505-226">在 [專案] 面板的相同路徑中, 也按兩下 [ **InteractionSourceInputSource.cs**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-226">From the same path in the project panel, also double click **InteractionSourceInputSource.cs**.</span></span>

<span data-ttu-id="7b505-227">請注意, 這兩個腳本都有通用的基類 BaseInputSource。</span><span class="sxs-lookup"><span data-stu-id="7b505-227">Note that both scripts have a common base class, BaseInputSource.</span></span>

<span data-ttu-id="7b505-228">BaseInputSource 會保留對 InputManager 的參考, 讓腳本能夠觸發事件。</span><span class="sxs-lookup"><span data-stu-id="7b505-228">BaseInputSource keeps a reference to an InputManager, which allows a script to trigger events.</span></span> <span data-ttu-id="7b505-229">在此情況下, InputClicked 事件是相關的。</span><span class="sxs-lookup"><span data-stu-id="7b505-229">In this case, the InputClicked event is relevant.</span></span> <span data-ttu-id="7b505-230">當我們進入腳本 2, TapToPlace 時, 請務必記住這一點。</span><span class="sxs-lookup"><span data-stu-id="7b505-230">This will be important to remember when we get to script 2, TapToPlace.</span></span> <span data-ttu-id="7b505-231">在 GamePadInput 的案例中, 我們會輪詢要按下控制器上的按鈕, 然後再引發 InputClicked 事件。</span><span class="sxs-lookup"><span data-stu-id="7b505-231">In the case of GamePadInput, we poll for the A button on the controller to be pressed, then we raise the InputClicked event.</span></span> <span data-ttu-id="7b505-232">在 InteractionSourceInputSource 的案例中, 我們會引發 InputClicked 事件以回應 TappedEvent。</span><span class="sxs-lookup"><span data-stu-id="7b505-232">In the case of InteractionSourceInputSource, we raise the InputClicked event in response to the TappedEvent.</span></span>

<span data-ttu-id="7b505-233">**腳本 2-TapToPlace.cs**</span><span class="sxs-lookup"><span data-stu-id="7b505-233">**Script 2 - TapToPlace.cs**</span></span>

<span data-ttu-id="7b505-234">在 [專案] 面板中, 流覽至**Assets\HoloToolkit\SpatialMapping\Scripts** , 然後按兩下**TapToPlace.cs**將其開啟。</span><span class="sxs-lookup"><span data-stu-id="7b505-234">In the project panel navigate to **Assets\HoloToolkit\SpatialMapping\Scripts** and double click **TapToPlace.cs** to open it.</span></span>

<span data-ttu-id="7b505-235">開發人員在建立全像攝影應用程式時想要執行的第一件事, 就是使用手勢輸入來移動全息影像。</span><span class="sxs-lookup"><span data-stu-id="7b505-235">The first thing many developers want to implement when creating a Holographic application is moving Holograms with gesture input.</span></span> <span data-ttu-id="7b505-236">因此, 我們已 endeavored 完整批註此腳本。</span><span class="sxs-lookup"><span data-stu-id="7b505-236">As such, we've endeavored to thoroughly comment this script.</span></span> <span data-ttu-id="7b505-237">在本教學課程中, 有幾件事值得特別強調。</span><span class="sxs-lookup"><span data-stu-id="7b505-237">A few things are worth highlighting for this tutorial.</span></span>

<span data-ttu-id="7b505-238">首先, 請注意, TapToPlace 會執行 IInputClickHandler。</span><span class="sxs-lookup"><span data-stu-id="7b505-238">First, note that TapToPlace implements IInputClickHandler.</span></span> <span data-ttu-id="7b505-239">IInputClickHandler 會公開函式, 這些函式會處理 GamePadInput.cs 或 InteractionSourceInputSource.cs 所引發的 InputClicked 事件。</span><span class="sxs-lookup"><span data-stu-id="7b505-239">IInputClickHandler exposes the functions that handle the InputClicked event raised by GamePadInput.cs or InteractionSourceInputSource.cs.</span></span> <span data-ttu-id="7b505-240">當 BaseInputSource 偵測到點擊, 而具有 TapToPlace 的物件處於焦點時, 就會呼叫 OnInputClicked。</span><span class="sxs-lookup"><span data-stu-id="7b505-240">OnInputClicked is called when a BaseInputSource detects a click while the object with TapToPlace is in focus.</span></span> <span data-ttu-id="7b505-241">Airtapping 在 HoloLens 上或按下 Xbox 控制器上的按鈕, 將會觸發事件。</span><span class="sxs-lookup"><span data-stu-id="7b505-241">Either airtapping on HoloLens or pressing the A button on the Xbox controller will trigger the event.</span></span>

<span data-ttu-id="7b505-242">第二種是在 update 中執行程式碼, 以查看是否正在查看表面, 讓我們可以將遊戲物件放在表面上, 例如資料表。</span><span class="sxs-lookup"><span data-stu-id="7b505-242">Second is the code be executed in update to see if a surface is being looked at so we can place the game object on a surface, like a table.</span></span> <span data-ttu-id="7b505-243">沉浸式耳機沒有實際表面的概念, 因此代表資料表 top (隆隆 > TableThingy > Cube) 的物件已標記 SpatialMapping 實體層, 因此更新中的光線轉型會與虛擬資料表頂端衝突。</span><span class="sxs-lookup"><span data-stu-id="7b505-243">The immersive headset doesn't have a concept of real surfaces, so the object that represents the table top (Vroom > TableThingy > Cube) has been marked with the SpatialMapping physics layer, so the ray cast in Update will collide with the virtual table top.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="7b505-244">享用您的進度</span><span class="sxs-lookup"><span data-stu-id="7b505-244">Enjoy your progress</span></span>

<span data-ttu-id="7b505-245">這次您可以選取要移動的島。</span><span class="sxs-lookup"><span data-stu-id="7b505-245">This time you can select the island to move it.</span></span> <span data-ttu-id="7b505-246">在 HoloLens 上, 您可以將島移至實際表面。</span><span class="sxs-lookup"><span data-stu-id="7b505-246">On HoloLens you can move the island to a real surface.</span></span> <span data-ttu-id="7b505-247">在沉浸式耳機中, 您可以將島移至我們新增的虛擬資料表。</span><span class="sxs-lookup"><span data-stu-id="7b505-247">In the immersive headset you can move the island to the virtual table we added.</span></span>

## <a name="chapter-3---sharing"></a><span data-ttu-id="7b505-248">第3章-共用</span><span class="sxs-lookup"><span data-stu-id="7b505-248">Chapter 3 - Sharing</span></span>

>[!VIDEO https://www.youtube.com/embed/1diycJvxfDc]

### <a name="objectives"></a><span data-ttu-id="7b505-249">目標</span><span class="sxs-lookup"><span data-stu-id="7b505-249">Objectives</span></span>

<span data-ttu-id="7b505-250">請確定已正確設定網路, 並詳細說明如何在裝置之間共用空間錨點。</span><span class="sxs-lookup"><span data-stu-id="7b505-250">Ensure that the network is correctly configured and detail how spatial anchors are shared between devices.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="7b505-251">我們將建立的內容</span><span class="sxs-lookup"><span data-stu-id="7b505-251">What we will build</span></span>

<span data-ttu-id="7b505-252">我們會將專案轉換成多人遊戲專案。</span><span class="sxs-lookup"><span data-stu-id="7b505-252">We will convert our project to a multiplayer project.</span></span> <span data-ttu-id="7b505-253">我們會將 UI 和邏輯新增至主機或加入會話。</span><span class="sxs-lookup"><span data-stu-id="7b505-253">We will add UI and logic to host or join sessions.</span></span> <span data-ttu-id="7b505-254">HoloLens 使用者會在會話中看到彼此的雲端, 而沉浸式耳機使用者在錨點所在位置附近有雲端。</span><span class="sxs-lookup"><span data-stu-id="7b505-254">HoloLens users will see each other in the session with clouds over their heads, and immersive headset users have clouds near to where the anchor is.</span></span> <span data-ttu-id="7b505-255">沉浸式耳機中的使用者會看到 HoloLens 使用者相對於場景的原點。</span><span class="sxs-lookup"><span data-stu-id="7b505-255">Users in the immersive headsets will see the HoloLens users relative to the origin of the scene.</span></span> <span data-ttu-id="7b505-256">HoloLens 使用者會在同一個位置看到島的全息影像。</span><span class="sxs-lookup"><span data-stu-id="7b505-256">HoloLens users will all see the hologram of the island in the same place.</span></span> <span data-ttu-id="7b505-257">重點是要注意的是, 沉浸式耳機中的使用者不會在這一章的島上, 但其行為非常類似 HoloLens, 而且具有鳥瞰圖。</span><span class="sxs-lookup"><span data-stu-id="7b505-257">It is key to note that the users in the immersive headsets will not be on the island during this chapter, but will behave very similarly to HoloLens, with a birds eye view of the island.</span></span>

### <a name="steps"></a><span data-ttu-id="7b505-258">步驟</span><span class="sxs-lookup"><span data-stu-id="7b505-258">Steps</span></span>
* <span data-ttu-id="7b505-259">移除島和 VRRoom</span><span class="sxs-lookup"><span data-stu-id="7b505-259">Remove Island and VRRoom</span></span>
    * <span data-ttu-id="7b505-260">在階層中, 以滑鼠右鍵按一下 [**島**] 選取 [**刪除**]</span><span class="sxs-lookup"><span data-stu-id="7b505-260">In **Hierarchy** right-click **Island** select **Delete**</span></span>
    * <span data-ttu-id="7b505-261">在階層中, 以滑鼠右鍵按一下**VRRoom**選取 [**刪除**]</span><span class="sxs-lookup"><span data-stu-id="7b505-261">In **Hierarchy** right-click **VRRoom** select **Delete**</span></span>
* <span data-ttu-id="7b505-262">新增 Usland</span><span class="sxs-lookup"><span data-stu-id="7b505-262">Add Usland</span></span>
    * <span data-ttu-id="7b505-263">從 [ **AppPrefabs** ] 將[ **Usland** ] 拖曳至 [階層]。</span><span class="sxs-lookup"><span data-stu-id="7b505-263">From **AppPrefabs** drag **Usland** to **Hierarchy**.</span></span>
* <span data-ttu-id="7b505-264">從 [ **AppPrefabs** ] 將下列每一個都拖曳至 [階層]:</span><span class="sxs-lookup"><span data-stu-id="7b505-264">From **AppPrefabs** drag each of the following to **Hierarchy**:</span></span>
    * <span data-ttu-id="7b505-265">**UNETSharingStage**</span><span class="sxs-lookup"><span data-stu-id="7b505-265">**UNETSharingStage**</span></span>
    * <span data-ttu-id="7b505-266">**UNetAnchorRoot**</span><span class="sxs-lookup"><span data-stu-id="7b505-266">**UNetAnchorRoot**</span></span>
    * <span data-ttu-id="7b505-267">**UIContainer**</span><span class="sxs-lookup"><span data-stu-id="7b505-267">**UIContainer**</span></span>
    * <span data-ttu-id="7b505-268">**DebugPanelButton**</span><span class="sxs-lookup"><span data-stu-id="7b505-268">**DebugPanelButton**</span></span>
* <span data-ttu-id="7b505-269">儲存並建立成先前的</span><span class="sxs-lookup"><span data-stu-id="7b505-269">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="7b505-270">深入探討至程式碼</span><span class="sxs-lookup"><span data-stu-id="7b505-270">Digging into the code</span></span>

<span data-ttu-id="7b505-271">在 [專案] 面板中, 流覽至**Assets\AppPrefabs\Support\SharingWithUnet\Scripts** , 然後按兩下 [ **UnetAnchorManager.cs**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-271">In the project panel, navigate to **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** and double-click on **UnetAnchorManager.cs**.</span></span> <span data-ttu-id="7b505-272">一個 HoloLens 與另一個 HoloLens 共用追蹤資訊的能力, 讓這兩個裝置都可以共用相同的空間, 接近神奇。</span><span class="sxs-lookup"><span data-stu-id="7b505-272">The ability for one HoloLens to share tracking information with another HoloLens such that both devices can share the same space is near magical.</span></span> <span data-ttu-id="7b505-273">當有兩個以上的人可以使用相同的數位資料共同作業時, 混合現實的威力就會保持運作。</span><span class="sxs-lookup"><span data-stu-id="7b505-273">The power of mixed reality comes alive when two or more people can collaborate using the same digital data.</span></span>

<span data-ttu-id="7b505-274">在此腳本中要指出的幾件事:</span><span class="sxs-lookup"><span data-stu-id="7b505-274">A few things to point out in this script:</span></span>

<span data-ttu-id="7b505-275">在 start 函式中, 注意**IsDisplayOpaque**的檢查。</span><span class="sxs-lookup"><span data-stu-id="7b505-275">In the start function, notice the check for **IsDisplayOpaque**.</span></span> <span data-ttu-id="7b505-276">在此情況下, 我們會假設已建立錨點。</span><span class="sxs-lookup"><span data-stu-id="7b505-276">In this case, we pretend that the Anchor is established.</span></span> <span data-ttu-id="7b505-277">這是因為沉浸式耳機不會公開匯入或匯出錨點的方式。</span><span class="sxs-lookup"><span data-stu-id="7b505-277">This is because the immersive headsets do not expose a way to import or export anchors.</span></span> <span data-ttu-id="7b505-278">不過, 如果我們在 HoloLens 上執行, 此腳本會在裝置之間執行共用錨點。</span><span class="sxs-lookup"><span data-stu-id="7b505-278">If we are running on a HoloLens, however, this script implements sharing anchors between the devices.</span></span> <span data-ttu-id="7b505-279">啟動會話的裝置將會建立錨點以供匯出。</span><span class="sxs-lookup"><span data-stu-id="7b505-279">The device that starts the session will create an anchor for exporting.</span></span> <span data-ttu-id="7b505-280">加入會話的裝置會向啟動會話的裝置要求錨點。</span><span class="sxs-lookup"><span data-stu-id="7b505-280">The device that joins a session will request the anchor from the device that started the session.</span></span>

<span data-ttu-id="7b505-281">**導**</span><span class="sxs-lookup"><span data-stu-id="7b505-281">**Exporting:**</span></span>

<span data-ttu-id="7b505-282">當使用者建立會話時, NetworkDiscoveryWithAnchors 將會呼叫 UNETAnchorManagers CreateAnchor function。</span><span class="sxs-lookup"><span data-stu-id="7b505-282">When a user creates a session, NetworkDiscoveryWithAnchors will call UNETAnchorManagers CreateAnchor function.</span></span> <span data-ttu-id="7b505-283">讓我們遵循 CreateAnchor flow。</span><span class="sxs-lookup"><span data-stu-id="7b505-283">Let's follow CreateAnchor flow.</span></span>

<span data-ttu-id="7b505-284">我們一開始會先進行一些維護, 清除我們針對先前錨點收集的任何資料。</span><span class="sxs-lookup"><span data-stu-id="7b505-284">We start by doing some housekeeping, clearing out any data we may have collected for previous anchors.</span></span> <span data-ttu-id="7b505-285">然後, 我們會檢查是否有要載入的快取錨點。</span><span class="sxs-lookup"><span data-stu-id="7b505-285">Then we check if there is a cached anchor to load.</span></span> <span data-ttu-id="7b505-286">錨點資料通常介於5到 20 MB 之間, 因此重複使用快取的錨點可以節省我們需要透過網路傳輸的資料量。</span><span class="sxs-lookup"><span data-stu-id="7b505-286">The anchor data tends to be between 5 and 20 MB, so reusing cached anchors can save on the amount of data we need to transfer over the network.</span></span> <span data-ttu-id="7b505-287">我們稍後會看到其運作方式。</span><span class="sxs-lookup"><span data-stu-id="7b505-287">We'll see how this works a bit later.</span></span> <span data-ttu-id="7b505-288">即使我們重複使用錨點, 我們還是需要在沒有錨點的新用戶端聯結時, 讓錨點資料準備就緒。</span><span class="sxs-lookup"><span data-stu-id="7b505-288">Even if we are reusing the anchor, we need to get the anchor data ready in case a new client joins that doesn't have the anchor.</span></span>

<span data-ttu-id="7b505-289">說到準備錨點資料, WorldAnchorTransferBatch 類別會公開功能來準備錨定資料, 以便傳送到其他裝置或應用程式, 以及匯入錨定資料的功能。</span><span class="sxs-lookup"><span data-stu-id="7b505-289">Speaking of getting the anchor data ready, the WorldAnchorTransferBatch class exposes the functionality to prepare anchor data for sending to another device or application and the functionality to import the anchor data.</span></span> <span data-ttu-id="7b505-290">因為我們是在匯出路徑, 所以我們會將錨點新增至 WorldAnchorTransferBatch 並呼叫 ExportAsync 函式。</span><span class="sxs-lookup"><span data-stu-id="7b505-290">Since we're on the export path, we will add our anchor to the WorldAnchorTransferBatch and call the ExportAsync function.</span></span> <span data-ttu-id="7b505-291">然後, ExportAsync 會在產生要匯出的資料時呼叫 WriteBuffer 回呼。</span><span class="sxs-lookup"><span data-stu-id="7b505-291">ExportAsync will then call the WriteBuffer callback as it generates data for export.</span></span> <span data-ttu-id="7b505-292">匯出所有資料之後, 就會呼叫 ExportComplete。</span><span class="sxs-lookup"><span data-stu-id="7b505-292">When all of the data has been exported ExportComplete will be called.</span></span> <span data-ttu-id="7b505-293">在 WriteBuffer 中, 我們會將資料區塊新增至我們保留以進行匯出的清單。</span><span class="sxs-lookup"><span data-stu-id="7b505-293">In WriteBuffer we add the chunk of data to a list we keep for exporting.</span></span> <span data-ttu-id="7b505-294">在 ExportComplete 中, 我們會將清單轉換成陣列。</span><span class="sxs-lookup"><span data-stu-id="7b505-294">In ExportComplete we convert the list to an array.</span></span> <span data-ttu-id="7b505-295">也會設定 AnchorName 變數, 這會觸發其他裝置來要求錨點 (如果沒有的話)。</span><span class="sxs-lookup"><span data-stu-id="7b505-295">The AnchorName variable is also set, which will trigger other devices to request the anchor if they don't have it.</span></span>

<span data-ttu-id="7b505-296">在某些情況下, 錨點不會匯出或建立幾乎不會再試一次的資料。</span><span class="sxs-lookup"><span data-stu-id="7b505-296">In some cases the anchor won't export or will create so little data that we will try again.</span></span> <span data-ttu-id="7b505-297">在這裡, 我們就再次呼叫 CreateAnchor。</span><span class="sxs-lookup"><span data-stu-id="7b505-297">Here we just call CreateAnchor again.</span></span>

<span data-ttu-id="7b505-298">匯出路徑中的最後一個函式是 AnchorFoundRemotely。</span><span class="sxs-lookup"><span data-stu-id="7b505-298">A final function in the export path is AnchorFoundRemotely.</span></span> <span data-ttu-id="7b505-299">當另一個裝置找到錨點時, 該裝置將會告訴主機, 而主機將會使用它來表示錨點為「良好錨點」, 而且可以快取。</span><span class="sxs-lookup"><span data-stu-id="7b505-299">When another device finds the anchor, that device will tell the host, and the host will use that as a signal that the anchor is a "good anchor" and can be cached.</span></span>

<span data-ttu-id="7b505-300">**導**</span><span class="sxs-lookup"><span data-stu-id="7b505-300">**Importing:**</span></span>

<span data-ttu-id="7b505-301">當 HoloLens 加入會話時, 它需要匯入錨點。</span><span class="sxs-lookup"><span data-stu-id="7b505-301">When a HoloLens joins a session, it needs to import an anchor.</span></span> <span data-ttu-id="7b505-302">在 UNETAnchorManager 的 Update 函式中, 會輪詢 AnchorName。</span><span class="sxs-lookup"><span data-stu-id="7b505-302">In UNETAnchorManager's Update function, the AnchorName is polled.</span></span> <span data-ttu-id="7b505-303">當錨點名稱變更時, 就會開始匯入程式。</span><span class="sxs-lookup"><span data-stu-id="7b505-303">When the anchor name changes, the import process begins.</span></span> <span data-ttu-id="7b505-304">首先, 我們會嘗試從本機錨點存放區載入具有指定名稱的錨點。</span><span class="sxs-lookup"><span data-stu-id="7b505-304">First, we try to load the anchor with the specified name from the local anchor store.</span></span> <span data-ttu-id="7b505-305">如果已經有, 我們就可以使用它, 而不需要再次下載資料。</span><span class="sxs-lookup"><span data-stu-id="7b505-305">If we already have it, we can use it without downloading the data again.</span></span> <span data-ttu-id="7b505-306">如果沒有, 則我們會呼叫 WaitForAnchor, 以起始下載。</span><span class="sxs-lookup"><span data-stu-id="7b505-306">If we don't have it, then we call WaitForAnchor which will initiate the download.</span></span>

<span data-ttu-id="7b505-307">當下載完成時, 會呼叫 NetworkTransmitter_dataReadyEvent。</span><span class="sxs-lookup"><span data-stu-id="7b505-307">When the download is completed, NetworkTransmitter_dataReadyEvent is called.</span></span> <span data-ttu-id="7b505-308">這會通知更新迴圈使用下載的資料來呼叫 ImportAsync。</span><span class="sxs-lookup"><span data-stu-id="7b505-308">This will signal the Update loop to call ImportAsync with the downloaded data.</span></span> <span data-ttu-id="7b505-309">當匯入程式完成時, ImportAsync 會呼叫 ImportComplete。</span><span class="sxs-lookup"><span data-stu-id="7b505-309">ImportAsync will call ImportComplete when the import process is complete.</span></span> <span data-ttu-id="7b505-310">如果匯入成功, 錨點會儲存在本機播放機存放區中。</span><span class="sxs-lookup"><span data-stu-id="7b505-310">If the import is successful, the anchor will be saved in the local player store.</span></span> <span data-ttu-id="7b505-311">PlayerController.cs 實際上會呼叫 AnchorFoundRemotely, 讓主機知道已建立良好的錨點。</span><span class="sxs-lookup"><span data-stu-id="7b505-311">PlayerController.cs actually makes the call to AnchorFoundRemotely to let the host know that a good anchor has been established.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="7b505-312">享用您的進度</span><span class="sxs-lookup"><span data-stu-id="7b505-312">Enjoy your progress</span></span>

<span data-ttu-id="7b505-313">這次具有 HoloLens 的使用者將會使用 UI 中的 [**啟動會話**] 按鈕來主控會話。</span><span class="sxs-lookup"><span data-stu-id="7b505-313">This time a user with a HoloLens will host a session using the **start session** button in the UI.</span></span> <span data-ttu-id="7b505-314">其他使用者 (在 HoloLens 或沉浸式頭戴式裝置上) 會選取該會話, 然後在 UI 中選取 [**加入會話**] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="7b505-314">Other users, both on HoloLens or an immersive headset, will select the session and then select the **join session** button in the UI.</span></span> <span data-ttu-id="7b505-315">如果您有多個使用 HoloLens 裝置的人員, 他們的標題將會有紅色雲端。</span><span class="sxs-lookup"><span data-stu-id="7b505-315">If you have multiple people with HoloLens devices, they will have red clouds over their heads.</span></span> <span data-ttu-id="7b505-316">每個沉浸式耳機也會有一個藍色的雲端, 但是藍色的雲不會在耳機上方, 因為耳機不會嘗試尋找與 HoloLens 裝置相同的全局座標空間。</span><span class="sxs-lookup"><span data-stu-id="7b505-316">There will also be a blue cloud for each immersive headset, but the blue clouds will not be above the headsets, as the headsets are not trying to find the same world coordinate space as the HoloLens devices.</span></span>

<span data-ttu-id="7b505-317">專案中的這個點是包含的共用應用程式;它不會執行太多動作, 而且可能做為基準。</span><span class="sxs-lookup"><span data-stu-id="7b505-317">This point in the project is a contained sharing application; it doesn't do very much, and could act as a baseline.</span></span> <span data-ttu-id="7b505-318">在接下來的章節中, 我們將開始打造讓大家享受的體驗。</span><span class="sxs-lookup"><span data-stu-id="7b505-318">In the next chapters, we will start building an experience for people to enjoy.</span></span> <span data-ttu-id="7b505-319">若要取得有關共用體驗設計的進一步指引, 請移至這裡。</span><span class="sxs-lookup"><span data-stu-id="7b505-319">To get further guidance on shared experience design, go here.</span></span>

## <a name="chapter-4---immersion-and-teleporting"></a><span data-ttu-id="7b505-320">第4章-深度和 teleporting</span><span class="sxs-lookup"><span data-stu-id="7b505-320">Chapter 4 - Immersion and teleporting</span></span>

>[!VIDEO https://www.youtube.com/embed/kUHZ5tCOfvY]

### <a name="objectives"></a><span data-ttu-id="7b505-321">目標</span><span class="sxs-lookup"><span data-stu-id="7b505-321">Objectives</span></span>

<span data-ttu-id="7b505-322">滿足每種混合現實裝置類型的體驗。</span><span class="sxs-lookup"><span data-stu-id="7b505-322">Cater the experience to each type of mixed reality device.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="7b505-323">我們將建立的內容</span><span class="sxs-lookup"><span data-stu-id="7b505-323">What we will build</span></span>

<span data-ttu-id="7b505-324">我們將更新應用程式, 以沉浸式視圖將沉浸式耳機使用者放在島上。</span><span class="sxs-lookup"><span data-stu-id="7b505-324">We will update the application to put immersive headset users on the island with an immersive view.</span></span> <span data-ttu-id="7b505-325">HoloLens 使用者仍然會看到島的鳥瞰圖。</span><span class="sxs-lookup"><span data-stu-id="7b505-325">HoloLens users will still have the bird's eye view of the island.</span></span> <span data-ttu-id="7b505-326">每種裝置類型的使用者都可以看到其他使用者出現在世界中的情況。</span><span class="sxs-lookup"><span data-stu-id="7b505-326">Users of each device type can see other users as they appear in the world.</span></span> <span data-ttu-id="7b505-327">比方說, 沉浸式耳機使用者可以看到其他虛擬人偶在島上的其他路徑, 並在島上看到 HoloLens 使用者為巨型雲端。</span><span class="sxs-lookup"><span data-stu-id="7b505-327">For instance, immersive headset users can see the other avatars on other paths on the island, and they see the HoloLens users as giant clouds above the island.</span></span> <span data-ttu-id="7b505-328">如果 HoloLens 使用者正在查看島, 則沉浸式耳機使用者也會看到 HoloLens 使用者的注視光線游標。</span><span class="sxs-lookup"><span data-stu-id="7b505-328">Immersive headset users will also see the cursor of the HoloLens user's gaze ray if the HoloLens user is looking at the island.</span></span> <span data-ttu-id="7b505-329">HoloLens 使用者會在島上看到代表每個沉浸式耳機使用者的圖片。</span><span class="sxs-lookup"><span data-stu-id="7b505-329">HoloLens users will see an avatar on the island to represent each immersive headset user.</span></span>

<span data-ttu-id="7b505-330">**已更新沉浸式裝置的輸入:**</span><span class="sxs-lookup"><span data-stu-id="7b505-330">**Updated Input for the Immersive device:**</span></span>
* <span data-ttu-id="7b505-331">Xbox 控制器上的左緩衝和右緩衝按鈕會旋轉玩家</span><span class="sxs-lookup"><span data-stu-id="7b505-331">The left bumper and right bumper buttons on the Xbox controller rotate the player</span></span>
* <span data-ttu-id="7b505-332">在 Xbox 控制器上保留 Y 按鈕, 將會啟用 [[傳送](navigating-the-windows-mixed-reality-home.md#getting-around-your-home)] 游標。</span><span class="sxs-lookup"><span data-stu-id="7b505-332">Holding the Y button on the Xbox controller will enable a [teleport](navigating-the-windows-mixed-reality-home.md#getting-around-your-home) cursor.</span></span> <span data-ttu-id="7b505-333">當您放開 Y 按鈕時, 如果游標具有旋轉箭號指標, 您就會傳送到游標的位置。</span><span class="sxs-lookup"><span data-stu-id="7b505-333">If the cursor has a spinning arrow indicator when you release the Y button, you will be teleported to the cursor's location.</span></span>

### <a name="steps"></a><span data-ttu-id="7b505-334">步驟</span><span class="sxs-lookup"><span data-stu-id="7b505-334">Steps</span></span>
* <span data-ttu-id="7b505-335">將 MixedRealityTeleport 新增至 MixedRealityCameraParent</span><span class="sxs-lookup"><span data-stu-id="7b505-335">Add MixedRealityTeleport to MixedRealityCameraParent</span></span>
    * <span data-ttu-id="7b505-336">在[階層] 中, 選取 [ **Usland**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-336">In **Hierarchy**, select **Usland**.</span></span>
    * <span data-ttu-id="7b505-337">在 [偵測**器**] 中, 啟用**層級控制**。</span><span class="sxs-lookup"><span data-stu-id="7b505-337">In **Inspector**, enable **Level Control**.</span></span>
    * <span data-ttu-id="7b505-338">在[階層] 中, 選取 [ **MixedRealityCameraParent**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-338">In **Hierarchy**, select **MixedRealityCameraParent**.</span></span>
    * <span data-ttu-id="7b505-339">在 [偵測**器**] 中, 按一下 [**新增元件**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-339">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="7b505-340">輸入**Mixed Reality 傳送**並加以選取。</span><span class="sxs-lookup"><span data-stu-id="7b505-340">Type **Mixed Reality Teleport** and select it.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="7b505-341">深入探討至程式碼</span><span class="sxs-lookup"><span data-stu-id="7b505-341">Digging into the code</span></span>

<span data-ttu-id="7b505-342">沉浸式耳機使用者將使用纜線行動網卡到他們的電腦上, 但我們的島大於纜線的長度。</span><span class="sxs-lookup"><span data-stu-id="7b505-342">Immersive headset users will be tethered to their PCs with a cable, but our island is larger than the cable is long.</span></span> <span data-ttu-id="7b505-343">若要補償, 我們必須能夠在使用者的動作以外獨立移動相機。</span><span class="sxs-lookup"><span data-stu-id="7b505-343">To compensate, we need the ability to move the camera independently of the user's motion.</span></span> <span data-ttu-id="7b505-344">如需有關設計混合現實應用程式 (特別是自我動作和 locomotion) 的詳細資訊, 請參閱[舒適頁面](comfort.md)。</span><span class="sxs-lookup"><span data-stu-id="7b505-344">Please see the [comfort page](comfort.md) for more information about designing your mixed reality application (in particular self motion and locomotion).</span></span>

<span data-ttu-id="7b505-345">為了描述此程式, 定義兩個詞彙將會很有説明。</span><span class="sxs-lookup"><span data-stu-id="7b505-345">In order to describe this process it will be useful to define two terms.</span></span> <span data-ttu-id="7b505-346">首先, **dolly**會是與使用者獨立移動相機的物件。</span><span class="sxs-lookup"><span data-stu-id="7b505-346">First, **dolly** will be the object that moves the camera independently from the user.</span></span> <span data-ttu-id="7b505-347">**Dolly**的子遊戲物件將會是**主要攝影機**。</span><span class="sxs-lookup"><span data-stu-id="7b505-347">A child game object of the **dolly** will be the **main camera**.</span></span> <span data-ttu-id="7b505-348">主要相機會附加到使用者的標頭。</span><span class="sxs-lookup"><span data-stu-id="7b505-348">The main camera is attached to the user's head.</span></span>

<span data-ttu-id="7b505-349">在 [專案] 面板中, 流覽至**Assets\AppPrefabs\Support\Scripts\GameLogic** , 然後按兩下 [ **MixedRealityTeleport.cs**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-349">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **MixedRealityTeleport.cs**.</span></span>

<span data-ttu-id="7b505-350">MixedRealityTeleport 有兩個作業。</span><span class="sxs-lookup"><span data-stu-id="7b505-350">MixedRealityTeleport has two jobs.</span></span> <span data-ttu-id="7b505-351">首先, 它會使用「緩衝器」來處理旋轉。</span><span class="sxs-lookup"><span data-stu-id="7b505-351">First, it handles rotation using the bumpers.</span></span> <span data-ttu-id="7b505-352">在 update 函式中, 我們會輪詢 LeftBumper 和 RightBumper 上的 ' ButtonUp '。</span><span class="sxs-lookup"><span data-stu-id="7b505-352">In the update function we poll for 'ButtonUp' on LeftBumper and RightBumper.</span></span> <span data-ttu-id="7b505-353">GetButtonUp 只會在第一個畫面格上傳回 true, 而按鈕在關閉之後就會出現。</span><span class="sxs-lookup"><span data-stu-id="7b505-353">GetButtonUp only returns true on the first frame a button is up after having been down.</span></span> <span data-ttu-id="7b505-354">如果已引發任一按鈕, 則我們知道使用者需要旋轉。</span><span class="sxs-lookup"><span data-stu-id="7b505-354">If either button had been raised, then we know the user needs to rotate.</span></span>

<span data-ttu-id="7b505-355">當我們旋轉時, 我們會使用稱為「淡化控制項」的簡單腳本, 淡出並淡入。</span><span class="sxs-lookup"><span data-stu-id="7b505-355">When we rotate we do a fade out and fade in using a simple script called 'fade control'.</span></span> <span data-ttu-id="7b505-356">這麼做是為了防止使用者看到可能導致 discomfort 的非自然移動。</span><span class="sxs-lookup"><span data-stu-id="7b505-356">We do this to prevent the user from seeing an unnatural movement which could lead to discomfort.</span></span> <span data-ttu-id="7b505-357">淡入和放大效果相當簡單。</span><span class="sxs-lookup"><span data-stu-id="7b505-357">The fade in and out effect is fairly simple.</span></span> <span data-ttu-id="7b505-358">在**主攝影機**前方, 我們有黑色的四場懸掛。</span><span class="sxs-lookup"><span data-stu-id="7b505-358">We have a black quad hanging in front of the **main camera**.</span></span> <span data-ttu-id="7b505-359">當您淡出時, 會將 Alpha 值從0轉換成1。</span><span class="sxs-lookup"><span data-stu-id="7b505-359">When fading out we transition the alpha value from 0 to 1.</span></span> <span data-ttu-id="7b505-360">這會逐漸導致四顆十字的黑色圖元呈現並遮蔽其背後的任何內容。</span><span class="sxs-lookup"><span data-stu-id="7b505-360">This gradually causes the black pixels of the quad to render and obscure anything behind them.</span></span> <span data-ttu-id="7b505-361">淡入後, 我們會將 Alpha 值轉換回零。</span><span class="sxs-lookup"><span data-stu-id="7b505-361">When fading back in we transition the alpha value back to zero.</span></span>

<span data-ttu-id="7b505-362">當我們計算旋轉時, 請注意, 我們會旋轉**dolly** , 但計算**主要攝影機**周圍的旋轉。</span><span class="sxs-lookup"><span data-stu-id="7b505-362">When we calculate the rotation, note that we are rotating our **dolly** but calculating the rotation around the **main camera**.</span></span> <span data-ttu-id="7b505-363">這一點很重要, 因為**主相機**遠離 0, 0, 0, 從使用者的觀點來看, dolly 的旋轉就愈不精確。</span><span class="sxs-lookup"><span data-stu-id="7b505-363">This is important as the farther the **main camera** is away from 0,0,0, the less accurate a rotation around the dolly would become from the point of view of the user.</span></span> <span data-ttu-id="7b505-364">事實上, 如果您不繞著相機位置旋轉, 使用者會在**dolly**前後移動, 而不是旋轉。</span><span class="sxs-lookup"><span data-stu-id="7b505-364">In fact, if you do not rotate around the camera position, the user will move on an arc around the **dolly** rather than rotating.</span></span>

<span data-ttu-id="7b505-365">MixedRealityTeleport 的第二個工作是處理移動**dolly**。</span><span class="sxs-lookup"><span data-stu-id="7b505-365">The second job for MixedRealityTeleport is to handle moving the **dolly**.</span></span> <span data-ttu-id="7b505-366">這會在 SetWorldPosition 中完成。</span><span class="sxs-lookup"><span data-stu-id="7b505-366">This is done in SetWorldPosition.</span></span> <span data-ttu-id="7b505-367">SetWorldPosition 會採用所需的世界位置, 也就是使用者想要 percieve 他們占的位置。</span><span class="sxs-lookup"><span data-stu-id="7b505-367">SetWorldPosition takes the desired world position, the position where the user wants to percieve that they inhabit.</span></span> <span data-ttu-id="7b505-368">我們必須將**dolly**放在該位置, 而不是**主攝影機**的本機位置, 因為每個畫面格都會加入該位移。</span><span class="sxs-lookup"><span data-stu-id="7b505-368">We need to put our **dolly** at that position minus the local position of the **main camera**, as that offset will be added each frame.</span></span>

<span data-ttu-id="7b505-369">第二個腳本會呼叫 SetWorldPosition。</span><span class="sxs-lookup"><span data-stu-id="7b505-369">A second script calls SetWorldPosition.</span></span> <span data-ttu-id="7b505-370">我們來看一下該腳本。</span><span class="sxs-lookup"><span data-stu-id="7b505-370">Let's look at that script.</span></span> <span data-ttu-id="7b505-371">在 [專案] 面板中, 流覽至**Assets\AppPrefabs\Support\Scripts\GameLogic** , 然後按兩下 [ **TeleportScript.cs**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-371">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **TeleportScript.cs**.</span></span>

<span data-ttu-id="7b505-372">這段腳本比 MixedRealityTeleport 稍微複雜一點。</span><span class="sxs-lookup"><span data-stu-id="7b505-372">This script is a little more involved than MixedRealityTeleport.</span></span> <span data-ttu-id="7b505-373">腳本正在檢查 Xbox controller 上的 Y 按鈕是否要保持關閉狀態。</span><span class="sxs-lookup"><span data-stu-id="7b505-373">The script is checking for the Y Button on the Xbox controller to be held down.</span></span> <span data-ttu-id="7b505-374">當按鈕被關閉時, 會轉譯一個傳送游標, 而腳本會將光線從使用者的注視位置轉換出來。</span><span class="sxs-lookup"><span data-stu-id="7b505-374">While the button is held down a teleport cursor is rendered and the script casts a ray from the user's gaze position.</span></span> <span data-ttu-id="7b505-375">如果該光線與較多或較不重要的表面衝突, 則會將介面視為要傳送至的表面, 並會啟用 [傳送] 游標上的動畫。</span><span class="sxs-lookup"><span data-stu-id="7b505-375">If that ray collides with a surface that is more or less pointing up, the surface will be considered a good surface to teleport to, and the animation on the teleport cursor will be enabled.</span></span> <span data-ttu-id="7b505-376">如果光線不會與表面出現較多或較少的指標, 則會停用游標上的動畫。</span><span class="sxs-lookup"><span data-stu-id="7b505-376">If the ray does not collide with a surface more or less pointing up, then the animation on the cursor will be disabled.</span></span> <span data-ttu-id="7b505-377">當 Y 按鈕放開, 而且光線的計算點是有效的位置時, 腳本會以光線相交的位置來呼叫 SetWorldPosition。</span><span class="sxs-lookup"><span data-stu-id="7b505-377">When the Y button is released and the calculated point of the ray is a valid position, the script calls SetWorldPosition with the position the ray intersected.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="7b505-378">享用您的進度</span><span class="sxs-lookup"><span data-stu-id="7b505-378">Enjoy your progress</span></span>

<span data-ttu-id="7b505-379">這次您需要尋找 friend。</span><span class="sxs-lookup"><span data-stu-id="7b505-379">This time you'll need to find a friend.</span></span>

<span data-ttu-id="7b505-380">同樣地, 具有 HoloLens 的使用者會主控一個會話。</span><span class="sxs-lookup"><span data-stu-id="7b505-380">Once again, a user with the HoloLens will host a session.</span></span> <span data-ttu-id="7b505-381">其他使用者將加入此會話。</span><span class="sxs-lookup"><span data-stu-id="7b505-381">Other users will join the session.</span></span> <span data-ttu-id="7b505-382">應用程式會將前三個使用者加入至島上三個路徑之一的沉浸式耳機。</span><span class="sxs-lookup"><span data-stu-id="7b505-382">The application will place the first three users to join from an immersive headset on one of the three paths on the island.</span></span> <span data-ttu-id="7b505-383">歡迎您流覽本節的小島。</span><span class="sxs-lookup"><span data-stu-id="7b505-383">Feel free to explore the island in this section.</span></span>

<span data-ttu-id="7b505-384">要注意的詳細資料:</span><span class="sxs-lookup"><span data-stu-id="7b505-384">Details to notice:</span></span>
1. <span data-ttu-id="7b505-385">您可以在雲端中看到臉部, 協助可以沉浸使用者查看 HoloLens 使用者所尋找的方向。</span><span class="sxs-lookup"><span data-stu-id="7b505-385">You can see faces in the clouds, which helps an immersed user see which direction a HoloLens user is looking.</span></span>
2. <span data-ttu-id="7b505-386">島上的虛擬人偶具有旋轉的 necks。</span><span class="sxs-lookup"><span data-stu-id="7b505-386">The avatars on the island have necks that rotate.</span></span> <span data-ttu-id="7b505-387">他們不會遵循使用者所做的實際事 (我們沒有這項資訊), 而是提供絕佳的體驗。</span><span class="sxs-lookup"><span data-stu-id="7b505-387">They won't follow what the user is doing is real reality (we don't have that information) but it makes for a nice experience.</span></span>
3. <span data-ttu-id="7b505-388">如果 HoloLens 使用者正在查看島, 可以沉浸使用者可以看到其游標。</span><span class="sxs-lookup"><span data-stu-id="7b505-388">If the HoloLens user is looking at the Island, the immersed users can see their cursor.</span></span>
4. <span data-ttu-id="7b505-389">代表 HoloLens 使用者轉換陰影的雲端。</span><span class="sxs-lookup"><span data-stu-id="7b505-389">The clouds that represent the HoloLens users cast shadows.</span></span>

## <a name="chapter-5---finale"></a><span data-ttu-id="7b505-390">第5章-Finale</span><span class="sxs-lookup"><span data-stu-id="7b505-390">Chapter 5 - Finale</span></span>

>[!VIDEO https://www.youtube.com/embed/n_HDWJbfpNg]

### <a name="objectives"></a><span data-ttu-id="7b505-391">目標</span><span class="sxs-lookup"><span data-stu-id="7b505-391">Objectives</span></span>

<span data-ttu-id="7b505-392">在兩種裝置類型之間建立共同作業的互動體驗。</span><span class="sxs-lookup"><span data-stu-id="7b505-392">Create a collaborative interactive experience between the two device types.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="7b505-393">我們將建立的內容</span><span class="sxs-lookup"><span data-stu-id="7b505-393">What we will build</span></span>

<span data-ttu-id="7b505-394">以第4章為基礎, 當具有沉浸式耳機的使用者接近島上的拼圖時, HoloLens 使用者會取得工具提示, 其中包含拼圖的線索。</span><span class="sxs-lookup"><span data-stu-id="7b505-394">Building on chapter 4, when a user with an immersive headset gets near a puzzle on the island, the HoloLens users will get a tool tip with a clue to the puzzle.</span></span> <span data-ttu-id="7b505-395">一旦所有的沉浸式耳機使用者都在 rocket 室的「ready pad」之後, rocket 就會啟動。</span><span class="sxs-lookup"><span data-stu-id="7b505-395">Once all of the immersive headset users get past their puzzles and onto the "ready pad" in the rocket room, the rocket will launch.</span></span>

### <a name="steps"></a><span data-ttu-id="7b505-396">步驟</span><span class="sxs-lookup"><span data-stu-id="7b505-396">Steps</span></span>
* <span data-ttu-id="7b505-397">在[階層] 中, 選取 [ **Usland**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-397">In **Hierarchy**, select **Usland**.</span></span>
* <span data-ttu-id="7b505-398">在 [**檢查**] 的 [**層級控制**] 中, 勾選 [**啟用**共同作業]。</span><span class="sxs-lookup"><span data-stu-id="7b505-398">In **Inspector**, in **Level Control**, check **Enable Collaboration**.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="7b505-399">深入探討至程式碼</span><span class="sxs-lookup"><span data-stu-id="7b505-399">Digging into the code</span></span>

<span data-ttu-id="7b505-400">現在讓我們來看一下 LevelControl.cs。</span><span class="sxs-lookup"><span data-stu-id="7b505-400">Now let us look at LevelControl.cs.</span></span> <span data-ttu-id="7b505-401">此腳本是遊戲邏輯的核心, 並會維護遊戲狀態。</span><span class="sxs-lookup"><span data-stu-id="7b505-401">This script is the core of the game logic and maintains the game state.</span></span> <span data-ttu-id="7b505-402">因為這是使用 UNET 的多玩家遊戲, 所以我們需要瞭解資料流程的運作方式, 至少是為了修改本教學課程。</span><span class="sxs-lookup"><span data-stu-id="7b505-402">Since this is a multiplayer game using UNET we need to understand how data flows, at least well enough to modify this tutorial.</span></span> <span data-ttu-id="7b505-403">如需 UNET 的完整總覽, 請參閱 Unity 檔。</span><span class="sxs-lookup"><span data-stu-id="7b505-403">For a more complete overview of UNET, please refer to Unity's documentation.</span></span>

<span data-ttu-id="7b505-404">在 [專案] 面板中, 流覽至**Assets\AppPrefabs\Support\Scripts\GameLogic** , 然後按兩下 [ **LevelControl.cs**]。</span><span class="sxs-lookup"><span data-stu-id="7b505-404">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **LevelControl.cs**.</span></span>

<span data-ttu-id="7b505-405">讓我們瞭解沉浸式耳機如何表示它們已準備好開始 rocket。</span><span class="sxs-lookup"><span data-stu-id="7b505-405">Let us understand how an immersive headset indicates that they are ready for the rocket launch.</span></span> <span data-ttu-id="7b505-406">在對應于島上三個路徑的布林清單中, 設定三個布林的其中一個, 即可傳達 Rocket 啟動的準備就緒。</span><span class="sxs-lookup"><span data-stu-id="7b505-406">Rocket Launch readiness is communicated by setting one of three bools in a list of bools that correspond to the three paths on the island.</span></span> <span data-ttu-id="7b505-407">當指派給路徑的使用者在 rocket 房間內的棕色填補上方時, 將會設定路徑的 bool。</span><span class="sxs-lookup"><span data-stu-id="7b505-407">A path's bool will be set when the user assigned to the path is on top of the brown pad inside the rocket room.</span></span> <span data-ttu-id="7b505-408">好, 現在就來瞭解詳細資料。</span><span class="sxs-lookup"><span data-stu-id="7b505-408">Okay, now to the details.</span></span>

<span data-ttu-id="7b505-409">我們會從 Update () 函數開始。</span><span class="sxs-lookup"><span data-stu-id="7b505-409">We will start in the Update() function.</span></span> <span data-ttu-id="7b505-410">您會注意到有一個「功能提要」函式。</span><span class="sxs-lookup"><span data-stu-id="7b505-410">You will note that there is a 'cheat' function.</span></span> <span data-ttu-id="7b505-411">我們在開發過程中使用此功能來測試 rocket 的啟動和重設順序。</span><span class="sxs-lookup"><span data-stu-id="7b505-411">We used this in development to test the rocket launch and reset sequence.</span></span> <span data-ttu-id="7b505-412">這無法在多使用者體驗中使用。</span><span class="sxs-lookup"><span data-stu-id="7b505-412">It won't work in the multi user experience.</span></span> <span data-ttu-id="7b505-413">希望您在地下列資訊時, 可以讓它發揮作用。</span><span class="sxs-lookup"><span data-stu-id="7b505-413">Hopefully by the time you internalize the following infromation you can make it work.</span></span> <span data-ttu-id="7b505-414">查看是否有任何功能之後, 我們會檢查本機播放機是否已可以沉浸。</span><span class="sxs-lookup"><span data-stu-id="7b505-414">After we check to see if we should cheat, we check to see if the local player is immersed.</span></span> <span data-ttu-id="7b505-415">我們想要專注于我們如何找出我們的目標。</span><span class="sxs-lookup"><span data-stu-id="7b505-415">We want to focus on how we find that we're at the goal.</span></span> <span data-ttu-id="7b505-416">在 if (可以沉浸) 檢查內, 會呼叫 CheckGoal 隱藏在**EnableCollaboration** bool 後面。</span><span class="sxs-lookup"><span data-stu-id="7b505-416">Inside of the if (Immersed) check, there is a call to CheckGoal hiding behind the **EnableCollaboration** bool.</span></span> <span data-ttu-id="7b505-417">這會對應到您在完成本章的步驟時所檢查的核取方塊。</span><span class="sxs-lookup"><span data-stu-id="7b505-417">This corresponds to the checkbox you checked while completing the steps for this chapter.</span></span> <span data-ttu-id="7b505-418">在 EnableCollaboration 內部, 我們看到 CheckGoal () 的呼叫。</span><span class="sxs-lookup"><span data-stu-id="7b505-418">Inside of EnableCollaboration we see a call to CheckGoal().</span></span>

<span data-ttu-id="7b505-419">CheckGoal 會執行一些數學運算, 以查看是否有更多或更低的面板。</span><span class="sxs-lookup"><span data-stu-id="7b505-419">CheckGoal does some math to see if we are more or less standing on the pad.</span></span> <span data-ttu-id="7b505-420">在我們的時候, 我們會進行 Debug。記錄「到達目標」, 然後呼叫「SendAtGoalMessage ()」。</span><span class="sxs-lookup"><span data-stu-id="7b505-420">When we are, we Debug.Log "Arrived at goal" and then we call 'SendAtGoalMessage()'.</span></span> <span data-ttu-id="7b505-421">在 SendAtGoalMessage 中, 我們會呼叫 playerController. SendAtGoal。</span><span class="sxs-lookup"><span data-stu-id="7b505-421">In SendAtGoalMessage we call playerController.SendAtGoal.</span></span> <span data-ttu-id="7b505-422">為了節省一些時間, 以下是程式碼:</span><span class="sxs-lookup"><span data-stu-id="7b505-422">To save you some time, here's the code:</span></span>

```cs
private void CmdSendAtGoal(int GoalIndex)
       {
           levelState.SetGoalIndex(GoalIndex);
       }
```

```cs
public void SendAtGoal(int GoalIndex)
       {
           if (isLocalPlayer)
           {
               Debug.Log("sending at goal " + GoalIndex);
               CmdSendAtGoal(GoalIndex);
           }
       }
```

<span data-ttu-id="7b505-423">請注意, SendAtGoalMessage 會呼叫 CmdSendAtGoal, 它會呼叫 levelState, 而此 SetGoalIndex 會回到 LevelControl.cs。</span><span class="sxs-lookup"><span data-stu-id="7b505-423">Note that SendAtGoalMessage calls CmdSendAtGoal, which calls levelState.SetGoalIndex, which is back in LevelControl.cs.</span></span> <span data-ttu-id="7b505-424">乍看之下, 這似乎有點奇怪。</span><span class="sxs-lookup"><span data-stu-id="7b505-424">At first glance this seems strange.</span></span> <span data-ttu-id="7b505-425">為什麼不直接呼叫 SetGoalIndex, 而不是透過 player 控制器來進行這種奇怪的路由？</span><span class="sxs-lookup"><span data-stu-id="7b505-425">Why not just call SetGoalIndex rather than this strange routing through the player controller?</span></span> <span data-ttu-id="7b505-426">原因是我們符合資料模型 UNET 用來讓資料保持同步。若要防止作弊和抖動, UNET 會要求每個物件都有有權變更已同步處理之變數的使用者。</span><span class="sxs-lookup"><span data-stu-id="7b505-426">The reason is that we are conforming to the data model UNET uses to keep data in sync. To prevent cheating and thrashing, UNET requires that each object has a user who has authority to change the synchronized variables.</span></span> <span data-ttu-id="7b505-427">此外, 只有主機 (啟動會話的使用者) 可以直接變更資料。</span><span class="sxs-lookup"><span data-stu-id="7b505-427">Further, only the host (the user that started the session) can change data directly.</span></span> <span data-ttu-id="7b505-428">不是主機但具有許可權的使用者, 必須將「命令」傳送到將變更變數的主機。</span><span class="sxs-lookup"><span data-stu-id="7b505-428">Users who are not the host, but have authority, need to send a 'command' to the host which will change the variable.</span></span> <span data-ttu-id="7b505-429">根據預設, 主機具有所有物件的授權, 但衍生來代表使用者的物件除外。</span><span class="sxs-lookup"><span data-stu-id="7b505-429">By default the host has authority over all objects, except for the object spawned to represent the user.</span></span> <span data-ttu-id="7b505-430">在我們的案例中, 此物件具有 playercontroller 腳本。</span><span class="sxs-lookup"><span data-stu-id="7b505-430">In our case this object has the playercontroller script.</span></span> <span data-ttu-id="7b505-431">有一種方法可以要求物件的授權, 然後進行變更, 但是我們選擇利用 player 控制器具有自我授權, 並透過 player 控制器路由傳送命令。</span><span class="sxs-lookup"><span data-stu-id="7b505-431">There is a way to request authority for an object and then make changes, but we choose to leverage the fact that the player controller has self authority and route commands through the player controller.</span></span>

<span data-ttu-id="7b505-432">換句話說, 當我們發現自己的目標時, 玩家必須告訴主機, 而主機會告訴其他人。</span><span class="sxs-lookup"><span data-stu-id="7b505-432">Said another way, when we've found ourselves at our goal, the player needs to tell the host, and the host will tell everyone else.</span></span>

<span data-ttu-id="7b505-433">回到 LevelControl.cs 查看 SetGoalIndex。</span><span class="sxs-lookup"><span data-stu-id="7b505-433">Back in LevelControl.cs look at SetGoalIndex.</span></span> <span data-ttu-id="7b505-434">在這裡, 我們將設定 synclist (AtGoal) 中的值。</span><span class="sxs-lookup"><span data-stu-id="7b505-434">Here we are setting the value of a value in a synclist (AtGoal).</span></span> <span data-ttu-id="7b505-435">請記住, 當我們執行這項操作時, 我們是在主機的內容中。</span><span class="sxs-lookup"><span data-stu-id="7b505-435">Remember that we are in the context of the host while we do this.</span></span> <span data-ttu-id="7b505-436">類似于命令, RPC 是主機可能發出的專案, 這會導致所有用戶端執行一些程式碼。</span><span class="sxs-lookup"><span data-stu-id="7b505-436">Similar to a command, an RPC is something the host can issue that will cause all clients to run some code.</span></span> <span data-ttu-id="7b505-437">在此我們稱之為「RpcCheckAllGoals」。</span><span class="sxs-lookup"><span data-stu-id="7b505-437">Here we call 'RpcCheckAllGoals'.</span></span> <span data-ttu-id="7b505-438">每個用戶端會個別檢查是否已設定這三個 AtGoals, 如果是, 則啟動 rocket。</span><span class="sxs-lookup"><span data-stu-id="7b505-438">Each client will individually check to see if all three AtGoals are set, and if so, launch the rocket.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="7b505-439">享用您的進度</span><span class="sxs-lookup"><span data-stu-id="7b505-439">Enjoy your progress</span></span>

<span data-ttu-id="7b505-440">在上一章中, 我們將以先前的方式開始會話。</span><span class="sxs-lookup"><span data-stu-id="7b505-440">Building on the previous chapter, we will start the session as before.</span></span> <span data-ttu-id="7b505-441">這次當沉浸式耳機中的使用者到達其路徑上的「門」時, 就會出現只有 HoloLens 使用者可以看到的工具提示。</span><span class="sxs-lookup"><span data-stu-id="7b505-441">This time as the users in the immersive headset get to the "door" on their path, a tooltip will appear that only the HoloLens users can see.</span></span> <span data-ttu-id="7b505-442">HoloLens 使用者會負責將此線索傳達給沉浸式耳機中的使用者。</span><span class="sxs-lookup"><span data-stu-id="7b505-442">The HoloLens users are responsible for communicating this clue to the users in the immersive headset.</span></span> <span data-ttu-id="7b505-443">當每個頭像在火山內的對應棕色填補之後, rocket 就會啟動到空間。</span><span class="sxs-lookup"><span data-stu-id="7b505-443">The rocket will launch to space once each avatar has stepped on its corresponding brown pad inside the volcano.</span></span> <span data-ttu-id="7b505-444">場景會在60秒後重設, 讓您可以再次執行。</span><span class="sxs-lookup"><span data-stu-id="7b505-444">The scene will reset after 60 seconds so you can do it again.</span></span>

## <a name="see-also"></a><span data-ttu-id="7b505-445">另請參閱</span><span class="sxs-lookup"><span data-stu-id="7b505-445">See also</span></span>
* [<span data-ttu-id="7b505-446">MR Input 213：運動控制器</span><span class="sxs-lookup"><span data-stu-id="7b505-446">MR Input 213: Motion controllers</span></span>](mixed-reality-213.md)
